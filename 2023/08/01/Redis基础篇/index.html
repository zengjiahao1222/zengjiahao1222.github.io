<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis基础篇 | 豪想敲代码的博客</title><meta name="author" content="abb"><meta name="copyright" content="abb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis基础篇">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis基础篇">
<meta property="og:url" content="https://zengjiahao1222.github.io/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/index.html">
<meta property="og:site_name" content="豪想敲代码的博客">
<meta property="og:description" content="Redis基础篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg">
<meta property="article:published_time" content="2023-08-01T08:56:28.000Z">
<meta property="article:modified_time" content="2023-08-11T02:18:58.449Z">
<meta property="article:author" content="abb">
<meta property="article:tag" content="小白">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="程序人生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zengjiahao1222.github.io/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/trueanchor" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis基础篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-11 10:18:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="豪想敲代码的博客"><span class="site-name">豪想敲代码的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis基础篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-01T08:56:28.000Z" title="发表于 2023-08-01 16:56:28">2023-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-11T02:18:58.449Z" title="更新于 2023-08-11 10:18:58">2023-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/">程序人生</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis基础篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Redis的十大数据类型"><a href="#Redis的十大数据类型" class="headerlink" title="Redis的十大数据类型"></a>Redis的十大数据类型</h2><h3 id="redis字符串（String）"><a href="#redis字符串（String）" class="headerlink" title="redis字符串（String）"></a>redis字符串（String）</h3><ul>
<li>string是redis最基本的类型，一个key对应一个value</li>
<li>string类型是二进制安全的，意思是redis的string可以包含任何数据，比如1jpg图片或者序列化的对象</li>
<li>string类型是redis对基本的数据类型，一个redis中字符串value最多可以是512M</li>
</ul>
<h3 id="redis列表（List）"><a href="#redis列表（List）" class="headerlink" title="redis列表（List）"></a>redis列表（List）</h3><ul>
<li>redis列表是最简单的字符串列表，按照插入的顺序排列。你可以添加一个元素到列表的头部（左边）或者是尾部（右边）</li>
<li>它的底层实际上是个双端链表，最多可以包含2^32-1个元素（4294967295，每个列表超过40亿个元素）</li>
</ul>
<h3 id="redis哈希表（Hash）"><a href="#redis哈希表（Hash）" class="headerlink" title="redis哈希表（Hash）"></a>redis哈希表（Hash）</h3><ul>
<li>redis hash是一个string类型的field（字段）和value（值）的映射表，hash特别适合用于存储对象。</li>
<li>redis中每个hash可以存储2^32-1个键值对</li>
</ul>
<h3 id="redis集合（Set）"><a href="#redis集合（Set）" class="headerlink" title="redis集合（Set）"></a>redis集合（Set）</h3><ul>
<li>redis的Set是String类型的无序集合。集合的成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是intset或者hashtable</li>
<li>redis中Set集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)。</li>
<li>集合中最大的成员数为2^32-1</li>
</ul>
<h3 id="reids有序集合（ZSet）"><a href="#reids有序集合（ZSet）" class="headerlink" title="reids有序集合（ZSet）"></a>reids有序集合（ZSet）</h3><ul>
<li>ZSet(sorted set：有序集合)</li>
<li>redis zset和set一样也是string类型元素的集合，且不允许有重复的成员</li>
<li>不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序</li>
<li>zset的成员是唯一的，但分数（score）却可以重复</li>
<li>zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1</li>
</ul>
<h3 id="redis地理空间（GEO）"><a href="#redis地理空间（GEO）" class="headerlink" title="redis地理空间（GEO）"></a>redis地理空间（GEO）</h3><ul>
<li>reids GEO主要用于存储地理位置信息，并对存储的信息进行操作，包括添加地理位置的坐标、获取地理位置的坐标、计算两个地理位置之间的距离、根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</li>
</ul>
<h3 id="redis基数统计（HyperLogLog）"><a href="#redis基数统计（HyperLogLog）" class="headerlink" title="redis基数统计（HyperLogLog）"></a>redis基数统计（HyperLogLog）</h3><ul>
<li>HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是：在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定且是很小的</li>
<li>在redis里面，每个HyperLogLog键只需要花费12KB内存就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多消耗的内存就越多的集合形成了鲜明的对比。</li>
<li>但是，因为HyperLogLog只会根据输入的元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</li>
</ul>
<h3 id="redis位图（bigmap）"><a href="#redis位图（bigmap）" class="headerlink" title="redis位图（bigmap）"></a>redis位图（bigmap）</h3><ul>
<li><p>Bit arrays（or simply bitmaps，我们可以称之为位图）</p>
</li>
<li><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604193941229.png" alt="image-20230604193941229"></p>
</li>
<li><p>由0和1状态表现的二进制位的bit数组</p>
</li>
</ul>
<h3 id="redis位域（bitfield）"><a href="#redis位域（bitfield）" class="headerlink" title="redis位域（bitfield）"></a>redis位域（bitfield）</h3><ul>
<li>通过bitfield命令可以一次性操作多个<strong>比特位域</strong>（指的是连续的多个比特位），它会执行一系列操作并且返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</li>
<li>说白了就是通过bitfield命令我们可以一次性对多个比特位域进行操作</li>
</ul>
<h3 id="redis流（Stream）"><a href="#redis流（Stream）" class="headerlink" title="redis流（Stream）"></a>redis流（Stream）</h3><ul>
<li>redis Stream是redis 5.0版本新增加的数据结构。</li>
<li>redis Stream主要用于消息队列（MQ），redis本身是有一个redis发布订阅（pub&#x2F;sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开，redis宕机等，消息就会被丢弃。</li>
<li>简单来说发布订阅可以分发消息，但无法记录历史消息</li>
<li>而redis Stream提供的消息持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</li>
</ul>
<h2 id="Redis键（Key）"><a href="#Redis键（Key）" class="headerlink" title="Redis键（Key）"></a>Redis键（Key）</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ul>
<li>del key：删除存在的key</li>
<li>dump key：序列化给定key，并返回被序列化的值</li>
<li>exists key：检查给定key是否存在</li>
<li>expire key seconds：为给定的key设置过期时间</li>
<li>keys pattern：查找所有符合给定模式（pattern）的key</li>
<li>move key db：将当前数据库的key移动到给定的数据库db中</li>
<li>persist  key：移除key的过期时间，key将持久保持</li>
<li>pttl key：以毫秒返回key的剩余的过期时间</li>
<li>ttl key：以秒为单位，返回给定key的剩余生存时间</li>
<li>randomkey：从当前数据库随机返回一个key</li>
<li>rename key newkey：修改key的名称</li>
<li>renamenx key newkey：仅当newkey不存在时，将key改名为newkey</li>
<li>type key：返回key所存储的值的类型</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>keys *：查看当前库的所有key</li>
<li>unlink key：非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续的异步中操作</li>
<li>select dbindex（0-15）：切换数据库，默认为0</li>
<li>dbsize：查看当前数据库key的数量</li>
<li>flushdb：清空当前库</li>
<li>flushall：通杀全部库</li>
</ul>
<h2 id="数据类型命令及落地运用"><a href="#数据类型命令及落地运用" class="headerlink" title="数据类型命令及落地运用"></a>数据类型命令及落地运用</h2><h3 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604212922726.png" alt="image-20230604212922726"></p>
<h4 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h4><ul>
<li>set key value</li>
<li>get key</li>
</ul>
<h4 id="同时设置-x2F-获取多个键值"><a href="#同时设置-x2F-获取多个键值" class="headerlink" title="同时设置&#x2F;获取多个键值"></a>同时设置&#x2F;获取多个键值</h4><ul>
<li>mset key value[key value….]</li>
<li>mget key[key…]</li>
<li>msetnx：同时设置一个或多个键值对时当且仅当所有给定的key都不存在</li>
</ul>
<h4 id="获取-x2F-设置指定范围的值"><a href="#获取-x2F-设置指定范围的值" class="headerlink" title="获取&#x2F;设置指定范围的值"></a>获取&#x2F;设置指定范围的值</h4><ul>
<li>getrange&#x2F;setrange key between…and</li>
</ul>
<h4 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h4><p>一定要是数字才能进行加减</p>
<ul>
<li>递增&#x2F;递减：incr key&#x2F;decr key</li>
<li>增加&#x2F;减少指定的整数：incrby&#x2F;decrby key 多少</li>
</ul>
<h4 id="获取字符串长度和内容追加"><a href="#获取字符串长度和内容追加" class="headerlink" title="获取字符串长度和内容追加"></a>获取字符串长度和内容追加</h4><ul>
<li>strlen key</li>
<li>append key value</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul>
<li>setnx key value：只有在key不存在时设置key的值</li>
<li>setex：设置带过期时间的key，动态设置</li>
</ul>
<h4 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h4><ul>
<li>getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)</li>
</ul>
<h3 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604213144877.png" alt="image-20230604213144877"></p>
<h4 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h4><p>单key多value</p>
<ul>
<li><p>一个双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。</p>
</li>
<li><p>left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p>
</li>
<li><p>它的底层实际是个<strong>双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</strong></p>
</li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ul>
<li>lpush&#x2F;rpush&#x2F;lrange</li>
<li>lpop&#x2F;rpop</li>
<li>lindex：按照索引下标获得元素（从上到下）</li>
<li>llen：获取列表中元素的个数</li>
<li>lrem key 数字N 给定值v1：删除N个值等于v1的元素</li>
<li>ltrim key 开始index 结束index：截取指定范围的值后再赋值给key</li>
<li>rpoplpush 源列表 目的列表：移除列表的最后一个元素，并将该元素添加到另一个列表并返回</li>
<li>lset key index value：将下标位置的值设置为value</li>
<li>linsert key before&#x2F;after ：在list某个已有值的前后再添加具体值</li>
</ul>
<p>微信公众号订阅的消息</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604215441175.png" alt="image-20230604215441175"></p>
<h3 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604215608650.png" alt="image-20230604215608650"></p>
<p><strong>KV模式不变，但V是一个键值对</strong></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>JD购物车早期，设计目前不再采用，当前中小厂可用</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220140355.png" alt="image-20230604220140355"></p>
<h3 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220501578.png" alt="image-20230604220501578"></p>
<p><strong>单值多value，且无重复</strong></p>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>微信抽奖小程序</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220652689.png" alt="image-20230604220652689"></p>
<p>朋友圈点赞</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222142611.png" alt="image-20230604222142611"></p>
<h3 id="Redis有序集合（ZSet）"><a href="#Redis有序集合（ZSet）" class="headerlink" title="Redis有序集合（ZSet）"></a>Redis有序集合（ZSet）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222402880.png" alt="image-20230604222402880"></p>
<p>在set的基础上，每个value前加了一个score分数值。之前set k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2</p>
<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222638776.png" alt="image-20230604222638776"></p>
<h3 id="Redis位图（bitmap）"><a href="#Redis位图（bitmap）" class="headerlink" title="Redis位图（bitmap）"></a>Redis位图（bitmap）</h3><p>由0和1状态表现的二进制位的bit数组</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222850415.png" alt="image-20230604222850415"></p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222947562.png" alt="image-20230604222947562"></p>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223220863.png" alt="image-20230604223220863"></p>
<h3 id="Redis基数统计（HyperLogLog）"><a href="#Redis基数统计（HyperLogLog）" class="headerlink" title="Redis基数统计（HyperLogLog）"></a>Redis基数统计（HyperLogLog）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223534692.png" alt="image-20230604223534692"></p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223630392.png" alt="image-20230604223630392"></p>
<h3 id="Redis地理空间（GEO）"><a href="#Redis地理空间（GEO）" class="headerlink" title="Redis地理空间（GEO）"></a>Redis地理空间（GEO）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>移动互联网时代LBS应用越来越多，交友软件中附近的小姐姐、外卖软件中附近的美食店铺、高德地图附近的核酸检查点等等，那这种附近各种形形色色的XXX地址位置选择是如何实现的？</li>
<li>地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。</li>
<li>例如滴滴打车，最直观的操作就是实时记录更新各个车的位置，然后当我们要找车时，在数据库中查找距离我们(坐标x0,y0)附近r公里范围内部的车辆</li>
</ul>
<p>使用下面的SQL即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> taxi <span class="keyword">from</span> position <span class="keyword">where</span> x0<span class="operator">-</span>r <span class="operator">&lt;</span> x <span class="operator">&lt;</span> x0 <span class="operator">+</span> r <span class="keyword">and</span> y0<span class="operator">-</span>r <span class="operator">&lt;</span> y <span class="operator">&lt;</span> y0<span class="operator">+</span>r</span><br></pre></td></tr></table></figure>

<p>但是这样会出现什么问题？</p>
<ul>
<li>查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的</li>
<li>这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问</li>
<li>精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差</li>
</ul>
<h3 id="Redis流（Stream）"><a href="#Redis流（Stream）" class="headerlink" title="Redis流（Stream）"></a>Redis流（Stream）</h3><p>Redis版的MQ消息中间件+阻塞队列</p>
<p>Stream还是不能百分百等价于Kafka、RabbitMQ来使用，生产案例少</p>
<h3 id="Redis位域（bitfield）"><a href="#Redis位域（bitfield）" class="headerlink" title="Redis位域（bitfield）"></a>Redis位域（bitfield）</h3><p>将一个Redis字符串看作是一个由二进制位组成的数组，并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604225341790.png" alt="image-20230604225341790"></p>
<h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul>
<li>实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写道磁盘上，也就是快照。这样一来即使故障宕机，快照也不会丢失，数据的可靠性也就得到了保证。</li>
<li>这个快照文件就称为RDB文件（dump.rdb）</li>
</ul>
<h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot内存快照，它恢复时再将硬盘快照文件直接读回到内存里</li>
<li>redis的数据都在内存中，保存备份时它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中，一锅端</li>
</ul>
<h4 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h4><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul>
<li>Save：在主程序中执行会阻塞当前的Redis服务器，直到持久化工作完成。执行sava命令期间，Redis不能处理其他命令，线上禁止使用</li>
<li>BGSAVE（默认）：Redis会在后台异步进行快照操作，不阻塞快照的同时还可以响应客户端请求，该触发方式会fork一个子进程由子进程复制持久化过程</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>适合大规模的数据恢复</li>
<li>按照业务定时备份</li>
<li>对数据完整性和一致性要求不高</li>
<li>RDB文件在内存中的加载速度要比AOF快得多</li>
</ul>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong></li>
<li>内存数据的全量同步，如果数据量太大会导致I&#x2F;O严重影响服务器性能</li>
<li>RDB依赖于主进程的fork，在更大的数据集中，这可能导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑</li>
</ul>
<h4 id="什么时候会触发RDB快照"><a href="#什么时候会触发RDB快照" class="headerlink" title="什么时候会触发RDB快照"></a>什么时候会触发RDB快照</h4><ul>
<li>配置文件中默认的快照配置</li>
<li>手动sava&#x2F;bgsave命令</li>
<li>执行flushall&#x2F;flushdb命令也会产生dump.rdb文件，但是里面是空的，无意义</li>
<li>执行shutdown且没有设置开启AOF持久化</li>
<li>主从复制时，主节点自动触发</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604235839606.png" alt="image-20230604235839606"></p>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><ul>
<li>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li>
<li>默认情况下，redis是没有开启AOF的。开启AOF功能需要设置配置：appendonly yes</li>
<li>AOF保存的是appendonly.aof文件</li>
</ul>
<h4 id="AOF持久化工作流程"><a href="#AOF持久化工作流程" class="headerlink" title="AOF持久化工作流程"></a>AOF持久化工作流程</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605001309817.png" alt="image-20230605001309817"></p>
<h4 id="AOF缓冲区三种写回策略"><a href="#AOF缓冲区三种写回策略" class="headerlink" title="AOF缓冲区三种写回策略"></a>AOF缓冲区三种写回策略</h4><ul>
<li>Always:同步写回，每个写命令执行完立刻同步的将日志写回磁盘</li>
<li>everysec：每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓存区中的内容写入磁盘</li>
<li>no:操作系统控制的写回，每个写命令执行完，只是先把日志文件写到AOF文件的内存缓存区，由操作系统决定何时将缓冲区内容写回到磁盘</li>
</ul>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605185533896.png" alt="image-20230605185533896"></p>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>更好的保护数据不丢失、性能高、可做紧急恢复</p>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li>
</ul>
<h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><ul>
<li>由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。</li>
<li>为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的峰值时，Redis就会<strong>自动</strong>启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集或者可以手动使用命令 bgrewriteaof 来重新。</li>
</ul>
<h5 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h5><ol>
<li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li>
<li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</li>
<li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li>
<li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中</li>
<li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li>
</ol>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605190311924.png" alt="image-20230605190311924"></p>
<h3 id="RDB-AOF混合持久化"><a href="#RDB-AOF混合持久化" class="headerlink" title="RDB+AOF混合持久化"></a>RDB+AOF混合持久化</h3><p>结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。</p>
<h4 id="开启混合方式设置"><a href="#开启混合方式设置" class="headerlink" title="开启混合方式设置"></a>开启混合方式设置</h4><p>设置aof-use-rdb-preamble的值为 yes  yes表示开启，设置为no表示禁用</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>RDB镜像做全量持久化，AOF做增量持久化</strong></p>
<p>先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。**—-》AOF包括了RDB头部+AOF混写**</p>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>可以一次性执行多个命令，本质是一组命令的集合。一个事务的所有命令都会被序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞</p>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>一个队列中，一次性、顺序性、排他性地执行一系列命令</p>
<h3 id="Redis事务VS数据量事务"><a href="#Redis事务VS数据量事务" class="headerlink" title="Redis事务VS数据量事务"></a>Redis事务VS数据量事务</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605191245403.png" alt="image-20230605191245403"></p>
<h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605191354653.png" alt="image-20230605191354653"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul>
<li>开启：以multi开始一个事务</li>
<li>入队：将多个命令入队到事务中，接到这些命令不会立刻执行，而是放到等待执行地事务队列里面</li>
<li>执行：由exec命令触发事务</li>
</ul>
<h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>由一个面试题引出管道</p>
<p><strong>如何优化频繁命令往返造成地性能瓶颈？</strong></p>
<p>Redis是一种基于客户端-服务端模型以及请求&#x2F;响应协议的TCP服务。一个请求会遵循以下步骤：</p>
<ol>
<li>客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ol>
<p><strong>上述两步称为：Round Trip Time(简称RTT,数据包往返于两端的时间)</strong></p>
<p>如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好</p>
<h3 id="解决思路（使用管道）"><a href="#解决思路（使用管道）" class="headerlink" title="解决思路（使用管道）"></a>解决思路（使用管道）</h3><p>管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605205315616.png" alt="image-20230605205315616"></p>
<h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><h4 id="Pipeline与原生批量命令对比"><a href="#Pipeline与原生批量命令对比" class="headerlink" title="Pipeline与原生批量命令对比"></a>Pipeline与原生批量命令对比</h4><ul>
<li>原生批量命令是原子性（例如：mset，mget），pipeline是非原子性</li>
<li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令</li>
<li>原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成</li>
</ul>
<h4 id="Pipeline与事务对比"><a href="#Pipeline与事务对比" class="headerlink" title="Pipeline与事务对比"></a>Pipeline与事务对比</h4><ul>
<li>事务具有原子性，管道不具有原子性</li>
<li>管道一次性将多条命令发送到服务器，事务是一条一条地发，事务只有在接收到exec命令之后才会执行，管道不会</li>
<li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会</li>
</ul>
<h4 id="使用Pipeline注意事项"><a href="#使用Pipeline注意事项" class="headerlink" title="使用Pipeline注意事项"></a>使用Pipeline注意事项</h4><ul>
<li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中发生异常，将会继续执行后续的指令</li>
<li>使用pipeline组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存</li>
</ul>
<h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种消息通信模式：发送者（PUBLISH）发送消息，订阅者（SUBSCRIBE）接受消息，可以实现进程间的消息传递</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>发布的消息在Redis系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃。</li>
<li>消息只管发送，对于发布者而言消息是即发即失的，不管接受，也没有ACK机制，无法保证消息的消费成功</li>
<li>以上缺点导致Redis的Pub&#x2F;Sub模式就像个小玩具，在生产环境中无用武之地，为此Redis5.0版本新增了Stream数据结构，不但支持多播，还支持数据持久化，相比Pub&#x2F;Sub更加的强大</li>
</ul>
<h2 id="Redis复制（replica）"><a href="#Redis复制（replica）" class="headerlink" title="Redis复制（replica）"></a>Redis复制（replica）</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p>就是主从复制，master以写为主，Slave以读为主。当master数据变化的时候，自动将新的数据异步同步到其他slave数据库</p>
<h3 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>读写分离</li>
<li>容灾恢复</li>
<li>数据备份</li>
<li>水平扩容支持高并发</li>
</ul>
<h3 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a>怎么玩</h3><p><strong>配从（库）不配主（库）</strong></p>
<p><strong>权限细节-重要</strong>：</p>
<p>master如果配置了requirepass参数，需要密码登录，那么slave就要配置masterauth来设置校验密码，否则的话master就会拒绝slave的访问请求</p>
<p><strong>基本操作命令</strong></p>
<ul>
<li><p>info replication:可以查看复制节点的主从关系和配置信息</p>
</li>
<li><p>replicaof 主库IP 主库端口（一般写入redis.conf配置文件内）</p>
</li>
<li><p>slaveof 主库IP 主库端口</p>
<ul>
<li>每次与master断开之后，都需要重写连接，除非你配置进redis.conf文件</li>
<li>在运行期间修改slave节点的信息，如果该数据库已经是某个朱主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，重新拜码头</li>
</ul>
</li>
<li><p>slaveof no one：使当前数据库停止与其他数据库的同步，转为主数据库，自立为王</p>
</li>
</ul>
<h3 id="复制原理和工作流程"><a href="#复制原理和工作流程" class="headerlink" title="复制原理和工作流程"></a>复制原理和工作流程</h3><ul>
<li><p>slave启动，同步初请</p>
<ul>
<li>slave启动成功连接到master后会发送一个sync命令</li>
<li>slave首次全新连接master，一次完全同步（全量复制）将自动执行，slave自身原有的数据会被master数据覆盖清除</li>
</ul>
</li>
<li><p>首次连接，全量复制</p>
<ul>
<li>master节点受到sync命令后开始在后台保存快照（即RDB持久化，主从复制时会触发RDB），同时收集所有接受到的用于修改数据集命令缓存起来，master节点执行RDB持久化完后，master将rdb快照文件和所有缓存的命令发送到所有slave，以完成一次完全同步</li>
<li>而slave服务在接受到数据库文件数据后，将其存盘并加载到内存中，从而完成复制初始化</li>
</ul>
</li>
<li><p>心跳持续，保持通信：repl-ping-replica-period 10（配置文件）</p>
</li>
<li><p>进入平稳，增量复制：master继续将新的所有收集到的修改命令自动依次传给slave，完成同步</p>
</li>
<li><p>从机下线，重连续传：master会检查backlog里面的offset，master和slave都会保存一个复制的offset还有一个masterId，offset是保存在backlog中的。master智慧把已经复制的offset后面的数据复制给slave，类似于断点续传</p>
</li>
</ul>
<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><ul>
<li>复制延迟，信号衰减：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li>
<li>master挂了如何办?:默认情况下，不会再slave节点中自动重选一个master</li>
</ul>
<h2 id="Redis哨兵（sentinel）"><a href="#Redis哨兵（sentinel）" class="headerlink" title="Redis哨兵（sentinel）"></a>Redis哨兵（sentinel）</h2><h3 id="是什么-5"><a href="#是什么-5" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>吹哨人巡查监控后台master主机是否故障，如果故障了根据<strong>投票数</strong>自动将某一个从库转化为新主库，继续对外服务</li>
<li>哨兵的作用<ul>
<li>监控redis运行状态，包括master和slave</li>
<li>当master down机，能自动将slave切换成新master</li>
</ul>
</li>
</ul>
<h3 id="能干嘛-3"><a href="#能干嘛-3" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>主从监控：监控主从redis库是否正常</li>
<li>消息通知：哨兵可以将故障转移的结果发送给客户端</li>
<li>故障转移：如果master异常，则会进行主从切换，将其中一个slave作为新master</li>
<li>配置中心：客户端通过连接哨兵来获得当前Redis服务的主节点地址</li>
</ul>
<h3 id="怎么玩-2"><a href="#怎么玩-2" class="headerlink" title="怎么玩"></a>怎么玩</h3><ul>
<li>3个哨兵：自动监控和维护集群，不存放数据，只是吹哨人</li>
<li>1主2从：用于数据读取和存放</li>
</ul>
<h3 id="哨兵运行流程和选举流程"><a href="#哨兵运行流程和选举流程" class="headerlink" title="哨兵运行流程和选举流程"></a>哨兵运行流程和选举流程</h3><p>当一个主从配置中的master失效之后，sentinel可以选举出一个新的master用于自动接替原master的工作，主从配置中的其他Redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换</p>
<p><strong>运行流程，故障切换</strong></p>
<ul>
<li><p>三个哨兵监控一主二从，正常运行中</p>
</li>
<li><p>SDown主观下线（Subjectively Down）：所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。主观下线就是说如果服务器在[sentinel down-after-milliseconds]给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了</p>
</li>
<li><p>ODown客观下线（Objectively Down）：<img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606014519549.png" alt="image-20230606014519549"></p>
</li>
<li><p>选举出领导者哨兵（哨兵中选出兵王）：当主节点被判断客观下线以后，各个哨兵节点会进行协商，先选举出一个<strong>领导哨兵节点（兵王）</strong>并由该领导者节点，也即被选举出的兵王进行failover（故障迁移）</p>
<ul>
<li>哨兵领导者如何选出来的？Raft算法：监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路<strong>是先到先得</strong>：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者</li>
</ul>
</li>
<li><p>由兵王开始推动故障切换流程并选出一个新master</p>
<ul>
<li>新主登基</li>
<li>群臣俯首</li>
<li>旧主拜服</li>
</ul>
</li>
</ul>
<p>上述的failover流程操作均由sentinel自己独立完成，完全无需人工干预</p>
<h3 id="哨兵的使用建议"><a href="#哨兵的使用建议" class="headerlink" title="哨兵的使用建议"></a>哨兵的使用建议</h3><ul>
<li>哨兵节点的数量应为多个，哨兵本身应该为集群，保证高可用</li>
<li>哨兵节点的数量应该是奇数</li>
<li>各个哨兵节点的配置应一致</li>
<li>如果哨兵节点部署在Docker等容器里面，尤其要注意端口的正确映射</li>
<li>哨兵集群+主从复制，<strong>并不能保证数据零丢失</strong>（承上启下引出集群）</li>
</ul>
<h2 id="Redis集群（cluster）"><a href="#Redis集群（cluster）" class="headerlink" title="Redis集群（cluster）"></a>Redis集群（cluster）</h2><h3 id="是什么-6"><a href="#是什么-6" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li><p><strong>由于数据量过大</strong>，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。</p>
</li>
<li><p>Redis集群是一个提供在多个Redis节点间共享数据的程序集</p>
</li>
<li><p>Redis集群可以支持多个master</p>
</li>
</ul>
<h3 id="能干嘛-4"><a href="#能干嘛-4" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li><p>Redis集群支持多个Master，每个Master又可以挂载多个Slave</p>
<ul>
<li>读写分离</li>
<li>支持数据的高可用</li>
<li>支持海量数据的读写存储操作</li>
</ul>
</li>
<li><p>由于Cluster自带Sentinel的故障迁移机制，内置了高可用的支持，无需再去使用哨兵功能</p>
</li>
<li><p>客户端与Redis的节点连接，不再需要连接集群中的所有的节点，只需要任意连接集群中的一个可用节点即可</p>
</li>
<li><p>槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</p>
</li>
</ul>
<h3 id="集群算法-分片-槽位slot"><a href="#集群算法-分片-槽位slot" class="headerlink" title="集群算法-分片-槽位slot"></a>集群算法-分片-槽位slot</h3><h4 id="redis集群的槽位slot"><a href="#redis集群的槽位slot" class="headerlink" title="redis集群的槽位slot"></a>redis集群的槽位slot</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191650387.png" alt="image-20230606191650387"></p>
<h4 id="redis集群的分类"><a href="#redis集群的分类" class="headerlink" title="redis集群的分类"></a>redis集群的分类</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191758578.png" alt="image-20230606191758578"></p>
<h4 id="它俩的优势"><a href="#它俩的优势" class="headerlink" title="它俩的优势"></a>它俩的优势</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191915673.png" alt="image-20230606191915673"></p>
<h4 id="slot槽位映射，一般业界有3种解决方案"><a href="#slot槽位映射，一般业界有3种解决方案" class="headerlink" title="slot槽位映射，一般业界有3种解决方案"></a>slot槽位映射，一般业界有3种解决方案</h4><h5 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h5><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606192717947.png" alt="image-20230606192717947"></p>
<h5 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h5><p><strong>三大步骤：</strong></p>
<ul>
<li><p>算法构建一致性哈希环</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193610219.png" alt="image-20230606193610219"></p>
</li>
<li><p>redis服务器IP节点映射</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193652277.png" alt="image-20230606193652277"></p>
</li>
<li><p>key落到服务器的落键规则</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193723898.png" alt="image-20230606193723898"></p>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><p>一致性哈希算法的<strong>容错性</strong></p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194015649.png" alt="image-20230606194015649"></p>
</li>
<li><p>一致性哈希算法的<strong>扩展性</strong></p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194040349.png" alt="image-20230606194040349"></p>
</li>
</ul>
<p><strong>缺点</strong></p>
<p>一致性哈希算法的<strong>数据倾斜</strong>的问题</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194127978.png" alt="image-20230606194127978"></p>
<h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194409589.png" alt="image-20230606194409589"></p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194444099.png" alt="image-20230606194444099"></p>
<h4 id="经典面试题：为什么redis集群的最大槽数是16384个"><a href="#经典面试题：为什么redis集群的最大槽数是16384个" class="headerlink" title="经典面试题：为什么redis集群的最大槽数是16384个?"></a>经典面试题：为什么redis集群的最大槽数是16384个?</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606200937900.png" alt="image-20230606200937900"></p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213142693.png" alt="image-20230606213142693"></p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213156235.png" alt="image-20230606213156235"></p>
<h4 id="redis集群不保证强一致性"><a href="#redis集群不保证强一致性" class="headerlink" title="redis集群不保证强一致性"></a>redis集群不保证强一致性</h4><p>意味着在特定的条件下，redis集群可能会丢掉一些被系统收到的写入请求命令</p>
<h3 id="集群常用操作命令和CRC16算法分析"><a href="#集群常用操作命令和CRC16算法分析" class="headerlink" title="集群常用操作命令和CRC16算法分析"></a>集群常用操作命令和CRC16算法分析</h3><ul>
<li><p>不在同一slot槽位下的多键操作支持不好，通识占位符登场</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213612595.png" alt="image-20230606213612595"></p>
</li>
<li><p>Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽</p>
</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li><p>cluster-require-full-coverage：集群是否完整才能对外提供服务</p>
<p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213817703.png" alt="image-20230606213817703"></p>
</li>
<li><p>cluster countkeysinslot 槽位数字编号：1，该槽位被占用，0，该槽位没有被占用</p>
</li>
<li><p>cluster keyslot 键名称：该键应该存在哪个槽位上</p>
</li>
</ul>
<h2 id="SpringBoot集成Redis"><a href="#SpringBoot集成Redis" class="headerlink" title="SpringBoot集成Redis"></a>SpringBoot集成Redis</h2><h3 id="集成Jedis"><a href="#集成Jedis" class="headerlink" title="集成Jedis"></a>集成Jedis</h3><h3 id="集成lettuce"><a href="#集成lettuce" class="headerlink" title="集成lettuce"></a>集成lettuce</h3><h3 id="集成RedisTemplate-推荐使用"><a href="#集成RedisTemplate-推荐使用" class="headerlink" title="集成RedisTemplate-推荐使用"></a>集成RedisTemplate-推荐使用</h3><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>上面的都是自己通过学习Redis网课的时候整理的Redis的基本知识，后续也会更新Redis的高级部分。如有不足和错误的地方请联系小编来改正。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zengjiahao1222.github.io">abb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zengjiahao1222.github.io/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/">https://zengjiahao1222.github.io/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zengjiahao1222.github.io" target="_blank">豪想敲代码的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B0%8F%E7%99%BD/">小白</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/">程序人生</a></div><div class="post_share"><div class="social-share" data-image="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/04/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/" title="Redis面试篇"><img class="cover" src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis面试篇</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/20/Arrays-asList-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/" title="Arrays.asList()避坑指南"><img class="cover" src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Arrays.asList()避坑指南</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/09/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="HashMap的七种遍历方式与性能分析"><img class="cover" src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">HashMap的七种遍历方式与性能分析</div></div></a></div><div><a href="/2023/07/20/Arrays-asList-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/" title="Arrays.asList()避坑指南"><img class="cover" src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-20</div><div class="title">Arrays.asList()避坑指南</div></div></a></div><div><a href="/2023/08/04/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/" title="Redis面试篇"><img class="cover" src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-04</div><div class="title">Redis面试篇</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">abb</div><div class="author-info__description">记录生活与学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zengjiahao1222"><i class="fab fa-github"></i><span>关注</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zengjiahao1222" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2939921882@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/2939921882" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #304880;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">微信公众号：豪想敲代码</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8D%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">Redis的十大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-text">redis字符串（String）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-text">redis列表（List）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash%EF%BC%89"><span class="toc-text">redis哈希表（Hash）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="toc-text">redis集合（Set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reids%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88ZSet%EF%BC%89"><span class="toc-text">reids有序集合（ZSet）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%EF%BC%88GEO%EF%BC%89"><span class="toc-text">redis地理空间（GEO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%88HyperLogLog%EF%BC%89"><span class="toc-text">redis基数统计（HyperLogLog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BD%8D%E5%9B%BE%EF%BC%88bigmap%EF%BC%89"><span class="toc-text">redis位图（bigmap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BD%8D%E5%9F%9F%EF%BC%88bitfield%EF%BC%89"><span class="toc-text">redis位域（bitfield）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%B5%81%EF%BC%88Stream%EF%BC%89"><span class="toc-text">redis流（Stream）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%94%AE%EF%BC%88Key%EF%BC%89"><span class="toc-text">Redis键（Key）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8"><span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%90%BD%E5%9C%B0%E8%BF%90%E7%94%A8"><span class="toc-text">数据类型命令及落地运用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-text">Redis字符串（String）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="toc-text">最常用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE-x2F-%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC"><span class="toc-text">同时设置&#x2F;获取多个键值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-x2F-%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9A%84%E5%80%BC"><span class="toc-text">获取&#x2F;设置指定范围的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%A2%9E%E5%87%8F"><span class="toc-text">数值增减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E5%92%8C%E5%86%85%E5%AE%B9%E8%BF%BD%E5%8A%A0"><span class="toc-text">获取字符串长度和内容追加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getset"><span class="toc-text">getset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-text">Redis列表（List）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E"><span class="toc-text">简单说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%93%88%E5%B8%8C%EF%BC%88Hash%EF%BC%89"><span class="toc-text">Redis哈希（Hash）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="toc-text">Redis集合（Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88ZSet%EF%BC%89"><span class="toc-text">Redis有序集合（ZSet）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BD%8D%E5%9B%BE%EF%BC%88bitmap%EF%BC%89"><span class="toc-text">Redis位图（bitmap）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-text">命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%88HyperLogLog%EF%BC%89"><span class="toc-text">Redis基数统计（HyperLogLog）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">基本命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%EF%BC%88GEO%EF%BC%89"><span class="toc-text">Redis地理空间（GEO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%B5%81%EF%BC%88Stream%EF%BC%89"><span class="toc-text">Redis流（Stream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BD%8D%E5%9F%9F%EF%BC%88bitfield%EF%BC%89"><span class="toc-text">Redis位域（bitfield）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%EF%BC%88Redis-DataBase%EF%BC%89"><span class="toc-text">RDB（Redis DataBase）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91"><span class="toc-text">如何触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">自动触发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">手动触发</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A3%E5%8A%BF"><span class="toc-text">劣势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91RDB%E5%BF%AB%E7%85%A7"><span class="toc-text">什么时候会触发RDB快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%EF%BC%88Append-Only-File%EF%BC%89"><span class="toc-text">AOF（Append Only File）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">AOF持久化工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="toc-text">AOF缓冲区三种写回策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-1"><span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A3%E5%8A%BF-1"><span class="toc-text">劣势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-text">AOF重写机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-text">重写原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-AOF%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">RDB+AOF混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%B7%B7%E5%90%88%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">开启混合方式设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-text">Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1VS%E6%95%B0%E6%8D%AE%E9%87%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">Redis事务VS数据量事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9"><span class="toc-text">怎么玩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%AE%A1%E9%81%93"><span class="toc-text">Redis管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%EF%BC%88%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%EF%BC%89"><span class="toc-text">解决思路（使用管道）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-1"><span class="toc-text">小总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline%E4%B8%8E%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94"><span class="toc-text">Pipeline与原生批量命令对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%AF%B9%E6%AF%94"><span class="toc-text">Pipeline与事务对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Pipeline%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用Pipeline注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">Redis发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%A4%8D%E5%88%B6%EF%BC%88replica%EF%BC%89"><span class="toc-text">Redis复制（replica）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-2"><span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9-1"><span class="toc-text">怎么玩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">复制原理和工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">复制的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%93%A8%E5%85%B5%EF%BC%88sentinel%EF%BC%89"><span class="toc-text">Redis哨兵（sentinel）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-5"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-3"><span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9-2"><span class="toc-text">怎么玩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8C%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B"><span class="toc-text">哨兵运行流程和选举流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-text">哨兵的使用建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%EF%BC%88cluster%EF%BC%89"><span class="toc-text">Redis集群（cluster）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-6"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-4"><span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%97%E6%B3%95-%E5%88%86%E7%89%87-%E6%A7%BD%E4%BD%8Dslot"><span class="toc-text">集群算法-分片-槽位slot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%A7%BD%E4%BD%8Dslot"><span class="toc-text">redis集群的槽位slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">redis集群的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E4%BF%A9%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">它俩的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slot%E6%A7%BD%E4%BD%8D%E6%98%A0%E5%B0%84%EF%BC%8C%E4%B8%80%E8%88%AC%E4%B8%9A%E7%95%8C%E6%9C%893%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">slot槽位映射，一般业界有3种解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA"><span class="toc-text">哈希取余分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%88%86%E5%8C%BA"><span class="toc-text">一致性哈希算法分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-text">哈希槽分区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E6%A7%BD%E6%95%B0%E6%98%AF16384%E4%B8%AA"><span class="toc-text">经典面试题：为什么redis集群的最大槽数是16384个?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">redis集群不保证强一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%92%8CCRC16%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">集群常用操作命令和CRC16算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">常用命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E9%9B%86%E6%88%90Redis"><span class="toc-text">SpringBoot集成Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90Jedis"><span class="toc-text">集成Jedis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90lettuce"><span class="toc-text">集成lettuce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90RedisTemplate-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="toc-text">集成RedisTemplate-推荐使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/22/JVM%E9%9D%A2%E8%AF%95%E7%AF%87/" title="JVM面试篇"><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM面试篇"/></a><div class="content"><a class="title" href="/2023/08/22/JVM%E9%9D%A2%E8%AF%95%E7%AF%87/" title="JVM面试篇">JVM面试篇</a><time datetime="2023-08-22T13:07:37.000Z" title="发表于 2023-08-22 21:07:37">2023-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%AF%87/" title="并发编程面试篇"><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程面试篇"/></a><div class="content"><a class="title" href="/2023/08/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%AF%87/" title="并发编程面试篇">并发编程面试篇</a><time datetime="2023-08-21T11:02:10.000Z" title="发表于 2023-08-21 19:02:10">2023-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E7%AF%87/" title="Java集合面试篇"><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java集合面试篇"/></a><div class="content"><a class="title" href="/2023/08/19/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E7%AF%87/" title="Java集合面试篇">Java集合面试篇</a><time datetime="2023-08-18T16:08:49.000Z" title="发表于 2023-08-19 00:08:49">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E7%AF%87/" title="消息中间件面试篇"><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="消息中间件面试篇"/></a><div class="content"><a class="title" href="/2023/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E7%AF%87/" title="消息中间件面试篇">消息中间件面试篇</a><time datetime="2023-08-17T08:42:38.000Z" title="发表于 2023-08-17 16:42:38">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E7%AF%87/" title="微服务面试篇"><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务面试篇"/></a><div class="content"><a class="title" href="/2023/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E7%AF%87/" title="微服务面试篇">微服务面试篇</a><time datetime="2023-08-16T01:55:32.000Z" title="发表于 2023-08-16 09:55:32">2023-08-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By abb</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'we9IASkINyyVQwNtO2nNEqIF-gzGzoHsz',
      appKey: 'UqlEJ9quJW7xDTq2U5FvuOoy',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-sigma-peach.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-sigma-peach.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Valine' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>