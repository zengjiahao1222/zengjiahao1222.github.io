<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之代理模式</title>
      <link href="/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>最近要进行软件工程设计模式的小组讨论了，正好借着这个机会来复习一下设计模式，这次为大家带来我在学习代理模式的一些笔记和心得。</p><h2 id="2-代理模式的基本介绍"><a href="#2-代理模式的基本介绍" class="headerlink" title="2.代理模式的基本介绍"></a>2.代理模式的基本介绍</h2><blockquote><ul><li>代理模式：为一个对象<strong>提供一个替身</strong>，以控制对这个对象的访问，则通过代理对象访问目标对象。这样做的好处是：可以对目标对象实现的基础上，增强额外的功能。</li><li>被代理的对象可以是远程对象、创建开销大的对象或者是需要安全控制的对象。</li><li>代理模式主要有三种<strong>静态代理</strong>、<strong>动态代理（JDK代理、接口代理）</strong>、<strong>Cglib代理（可以在内存中动态的创建对象，而不需要实现接口。属于动态代理的范畴）</strong></li></ul></blockquote><h2 id="3-静态代理"><a href="#3-静态代理" class="headerlink" title="3.静态代理"></a>3.静态代理</h2><h3 id="3-1-静态代理模式的基本介绍"><a href="#3-1-静态代理模式的基本介绍" class="headerlink" title="3.1.静态代理模式的基本介绍"></a>3.1.静态代理模式的基本介绍</h3><p>静态代理在使用时，需要定义接口或者父类，被代理对象（目标对象）与代理对象一起实现相同的接口或者是继承相同的父类</p><h3 id="3-2-应用实例"><a href="#3-2-应用实例" class="headerlink" title="3.2.应用实例"></a>3.2.应用实例</h3><h4 id="3-2-1-具体要求"><a href="#3-2-1-具体要求" class="headerlink" title="3.2.1.具体要求"></a>3.2.1.具体要求</h4><blockquote><ol><li>定义一个接口：<code>ITeacherDAO</code></li><li>目标对象<code>TeacherDAO</code>实现接口<code>ITeacherDAO</code></li><li>使用静态代理的方式，就需要代理对象<code>TeacherDAOProxy</code>也实现<code>ITeacherDAO</code></li><li>调用的时候通过调用代理对象的方法来调用目标对象</li><li><strong>特别注意</strong>：代理对象要与目标对象实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。</li></ol></blockquote><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml.png" alt="staticProxy" style="zoom:67%;"><h4 id="3-2-2-代码演示"><a href="#3-2-2-代码演示" class="headerlink" title="3.2.2.代码演示"></a>3.2.2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//讲课的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 目标对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理对象，静态代理</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAOProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITeacherDAO target;<span class="comment">//目标对象，通过接口来聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherDAOProxy</span><span class="params">(ITeacherDAO target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增强功能...&quot;</span>);</span><br><span class="line">        target.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;增强功能...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象（被代理对象）</span></span><br><span class="line">        TeacherDAO teacherDAO=<span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line">        <span class="comment">//创建代理对象，同时将被代理对象传给代理对象</span></span><br><span class="line">        <span class="type">TeacherDAOProxy</span> <span class="variable">teacherDAOProxy</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TeacherDAOProxy</span>(teacherDAO);</span><br><span class="line">        <span class="comment">//通过代理对象调用到被代理对象的方法</span></span><br><span class="line">        teacherDAOProxy.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-静态代理的优缺点"><a href="#3-3-静态代理的优缺点" class="headerlink" title="3.3.静态代理的优缺点"></a>3.3.静态代理的优缺点</h3><h4 id="3-3-1-优点"><a href="#3-3-1-优点" class="headerlink" title="3.3.1.优点"></a>3.3.1.优点</h4><p>在不修改目标对象功能的前提下，能通过代理对象对目标功能进行扩展</p><h4 id="3-3-2-缺点"><a href="#3-3-2-缺点" class="headerlink" title="3.3.2.缺点"></a>3.3.2.缺点</h4><ul><li>因为代理对象需要与目标对象实现一样的接口，所以会有很多的代理类</li><li>一旦接口增加方法，目标对象与代理对象都要维护</li></ul><h2 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h2><h3 id="4-1-动态代理的基本介绍"><a href="#4-1-动态代理的基本介绍" class="headerlink" title="4.1.动态代理的基本介绍"></a>4.1.动态代理的基本介绍</h3><blockquote><ul><li>代理对象不需要实现接口，但是目标对象需要实现接口，否则不能使用动态代理</li><li>代理对象的生成，是利用JDK中的API，动态的在内存中构建代理对象</li><li>动态代理要叫：JDK代理、接口代理</li></ul></blockquote><h3 id="4-2-JDK中生成代理对象的API"><a href="#4-2-JDK中生成代理对象的API" class="headerlink" title="4.2.JDK中生成代理对象的API"></a>4.2.JDK中生成代理对象的API</h3><blockquote><ul><li>代理类所在的包：<code>java.lang.reflect.Proxy</code></li><li>JDK的代理实现只需要使用<code>newProxyInstance</code>方法,完整写法<code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></li></ul></blockquote><h3 id="4-3-应用实例"><a href="#4-3-应用实例" class="headerlink" title="4.3.应用实例"></a>4.3.应用实例</h3><h4 id="4-3-1-具体要求"><a href="#4-3-1-具体要求" class="headerlink" title="4.3.1.具体要求"></a>4.3.1.具体要求</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml2.png" alt="dynamicProxy" style="zoom:67%;"><h4 id="4-3-2-代码实现"><a href="#4-3-2-代码实现" class="headerlink" title="4.3.2.代码实现"></a>4.3.2.代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//讲课的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 目标对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 14:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理工厂类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象，Object</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给目标对象生成一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">         *                                           Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">         *                                           InvocationHandler h)</span></span><br><span class="line"><span class="comment">         * ClassLoader loader:指定目标对象使用的类加载器，获取类加载器的方法固定</span></span><br><span class="line"><span class="comment">         * Class&lt;?&gt;[] interfaces:目标对象实现鹅接口类型，使用泛型的方法确定类型</span></span><br><span class="line"><span class="comment">         * InvocationHandler h:事件处理，执行目标对象方法时，会促发事件处理器的方法，</span></span><br><span class="line"><span class="comment">         * 会把当前执行的目标对象方法作为一个参数传入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;JDK代理开始...&quot;</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理提交...&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 14:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        ITeacherDAO target=<span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给目标对象，创建代理对象，转化为ITeacherDAO</span></span><br><span class="line">        <span class="type">ITeacherDAO</span> <span class="variable">proxyInstance</span> <span class="operator">=</span>(ITeacherDAO) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//class com.sun.proxy.$Proxy0内存中动态生成了代理对象</span></span><br><span class="line">        System.out.println(proxyInstance.getClass());</span><br><span class="line">        <span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">        proxyInstance.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Cglib代理"><a href="#5-Cglib代理" class="headerlink" title="5.Cglib代理"></a>5.Cglib代理</h2><h3 id="5-1-Cglib代理模式的基本介绍"><a href="#5-1-Cglib代理模式的基本介绍" class="headerlink" title="5.1.Cglib代理模式的基本介绍"></a>5.1.Cglib代理模式的基本介绍</h3><blockquote><ul><li>静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可以使用目标对象的子类来实现代理，这就是Cglib代理</li><li>Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展，有时候也将<strong>Cglib代理归属到动态代理</strong></li><li>Cglib是一个强大的高性能的代码生成包，它可以在运行期间扩展java类与实现java接口。它广泛的被许多AOP框架使用，比如Spring AOP，实现方法拦截。</li><li>在AOP编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理</li></ul></li><li>Cglib包的底层是通过使用字节码处理框架ASM来转化字节码并生成新的</li></ul></blockquote><h3 id="5-2-应用实例"><a href="#5-2-应用实例" class="headerlink" title="5.2.应用实例"></a>5.2.应用实例</h3><h4 id="5-2-1-Cglib代理模式的实现步骤"><a href="#5-2-1-Cglib代理模式的实现步骤" class="headerlink" title="5.2.1.Cglib代理模式的实现步骤"></a>5.2.1.Cglib代理模式的实现步骤</h4><blockquote><ol><li>需要引入Cglib的jar文件<ul><li>asm.jar</li><li>asm-commons.jar</li><li>asm-tree.jar</li><li>cglib-2.2.jar</li></ul></li><li>在内存中动态构建子类，注意代理的内不能为**<code>final</code>**,否则会报<code>java.lang.IllegalArgumentException</code></li><li>目标对象的方法如果为<code>final/static</code>，那么就不会被拦截，即不会执行目标对象额外的业务方法</li></ol></blockquote><h4 id="5-2-2-具体要求"><a href="#5-2-2-具体要求" class="headerlink" title="5.2.2.具体要求"></a>5.2.2.具体要求</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml3.png" alt="Cglib代理" style="zoom:67%;"><h4 id="5-2-3-代码实现"><a href="#5-2-3-代码实现" class="headerlink" title="5.2.3.代码实现"></a>5.2.3.代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 15:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...,我是Cglib代理，不需要实现接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 15:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理工厂</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象：是target对象的代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、创建一个工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2、设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3、设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4、创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写intercept方法，会调用目标对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理模式开始...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理提交...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 16:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">TeacherDAO</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line">        <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        <span class="type">TeacherDAO</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (TeacherDAO) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//执行代理对象的方法,触发intercept方法，从而实现对目标对象的调用</span></span><br><span class="line">        proxyInstance.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-代理模式的变体"><a href="#6-代理模式的变体" class="headerlink" title="6.代理模式的变体"></a>6.代理模式的变体</h2><h3 id="6-1-几种常见的代理模式介绍"><a href="#6-1-几种常见的代理模式介绍" class="headerlink" title="6.1.几种常见的代理模式介绍"></a>6.1.几种常见的代理模式介绍</h3><h4 id="6-1-1-防火墙代理"><a href="#6-1-1-防火墙代理" class="headerlink" title="6.1.1.防火墙代理"></a>6.1.1.防火墙代理</h4><p>内网通过代理穿透防火墙，实现对公网的访问</p><h4 id="6-1-2-缓存代理"><a href="#6-1-2-缓存代理" class="headerlink" title="6.1.2.缓存代理"></a>6.1.2.缓存代理</h4><p>比如：当请求图片文件等资源时，先缓存代理取，如果取到资源则ok，如果去报道资源，再到公网或者数据库取，然后缓存。</p><h4 id="6-1-3-远程代理"><a href="#6-1-3-远程代理" class="headerlink" title="6.1.3.远程代理"></a>6.1.3.远程代理</h4><p><strong>远程对象的本地代表</strong>，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p><h4 id="6-1-4-同步代理"><a href="#6-1-4-同步代理" class="headerlink" title="6.1.4.同步代理"></a>6.1.4.同步代理</h4><p>主要运用在多线程编程中，完成多线程间同步工作。</p><h2 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7.结束语"></a>7.结束语</h2><p>这次的设计模式之代理模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo+github从0到1搭建个人博客</title>
      <link href="/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><h3 id="1-1-想说的话"><a href="#1-1-想说的话" class="headerlink" title="1.1.想说的话"></a>1.1.想说的话</h3><p>最近在学习 markdown 语法的时候，想着何不搭建一个个人的博客网站来进行分享一下自己的学习经验和心得了，于是马上开干，很快啊，一个简单的 blog 网站就诞生了，下面就来和大家分享一下使用 hexo+GitHub 从 0 到 1 搭建个人博客。</p><h3 id="1-2-准备工作"><a href="#1-2-准备工作" class="headerlink" title="1.2.准备工作"></a>1.2.准备工作</h3><p>在进行搭建博客之前，你需要:</p><blockquote><ul><li>拥有一个 GitHub 账号，没有的话去注册一个</li><li>安装了 node.js、npm，并且了解相关的知识</li><li>安装了 git</li></ul></blockquote><p>小编使用的环境：</p><blockquote><ul><li>Windows10</li><li><a href="mailto:&#110;&#111;&#100;&#x65;&#46;&#x6a;&#115;&#64;&#49;&#x38;&#x2e;&#x31;&#x35;&#46;&#x30;">&#110;&#111;&#100;&#x65;&#46;&#x6a;&#115;&#64;&#49;&#x38;&#x2e;&#x31;&#x35;&#46;&#x30;</a></li><li><a href="mailto:&#x67;&#105;&#116;&#64;&#50;&#x2e;&#51;&#x39;&#x2e;&#50;">&#x67;&#105;&#116;&#64;&#50;&#x2e;&#51;&#x39;&#x2e;&#50;</a></li><li><a href="mailto:&#104;&#x65;&#x78;&#111;&#x40;&#54;&#x2e;&#x33;&#46;&#48;">&#104;&#x65;&#x78;&#111;&#x40;&#54;&#x2e;&#x33;&#46;&#48;</a></li></ul></blockquote><h2 id="2-搭建-GitHub-博客"><a href="#2-搭建-GitHub-博客" class="headerlink" title="2.搭建 GitHub 博客"></a>2.搭建 GitHub 博客</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1.创建仓库"></a>2.1.创建仓库</h3><p>新建一个名为<code>你的github用户名.github.io</code>的仓库，比如说，如果你的 github 用户名是 zengjiahao1222，那么你就新建<code>zengjiahao1222.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就 s 是<a href="http://zengjiahao1222.github.io](http://test.github.io/)">http://zengjiahao1222.github.io](http://test.github.io/)</a> 了！</p><p>注意事项：</p><blockquote><ol><li>注册的邮箱一定要验证，否则不会成功</li><li>仓库名字必须是<code>username.github.io</code>,其中 username 是你的 GitHub 的用户名</li><li>仓库创建成功不会立即生效，需要过一段时间，大概 10-30 分钟。这个我踩坑了！！！</li></ol></blockquote><h3 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2.绑定域名"></a>2.2.绑定域名</h3><p>这个不绑定也是可以的，就用默认的<code>xxx.github.io</code>也是可以进行访问的，但是如果你想更加个性化，并且想拥有一个自己的域名，那就去买一个域名吧。</p><p>这里推荐去阿里云注册域名，大公司，有保障！！！</p><h2 id="3-配置-SSH-key"><a href="#3-配置-SSH-key" class="headerlink" title="3.配置 SSH key"></a>3.配置 SSH key</h2><h3 id="3-1-Github-配置-SSH-Key"><a href="#3-1-Github-配置-SSH-Key" class="headerlink" title="3.1.Github 配置 SSH Key"></a>3.1.Github 配置 SSH Key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用 git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure><p>然后连续 3 次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的 github 主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key——&gt;将刚复制的内容粘贴到 key 那里，title 随便填，保存:</p><p><img src="/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh.png" alt="配置"></p><h3 id="3-2-测试配置是否成功"><a href="#3-2-测试配置是否成功" class="headerlink" title="3.2.测试配置是否成功"></a>3.2.测试配置是否成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com <span class="comment"># 注意邮箱地址不用改</span></span><br></pre></td></tr></table></figure><p>如果提示<code>Hi zengjiahao1222! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>，那么恭喜你 SSH 已经配置成功</p><p>此时你还需要配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;liuxianan&quot;</span>// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><h2 id="4-使用-hexo-框架写博客"><a href="#4-使用-hexo-框架写博客" class="headerlink" title="4.使用 hexo 框架写博客"></a>4.使用 hexo 框架写博客</h2><h3 id="4-1-hexo-简介"><a href="#4-1-hexo-简介" class="headerlink" title="4.1.hexo 简介"></a>4.1.hexo 简介</h3><p>Hexo 是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持 Markdown 格式，有众多优秀插件和主题。</p><p>官网：<a href="http://hexo.io/">http://hexo.io</a></p><p>github：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h3 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2.原理"></a>4.2.原理</h3><p>由于 github pages 存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以 hexo 所做的就是将这些 md 文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到 github。</p><h3 id="4-3-安装"><a href="#4-3-安装" class="headerlink" title="4.3.安装"></a>4.3.安装</h3><p>建议使用 git bash 来执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>hexo 有 2 种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</p><h3 id="4-4-初始化"><a href="#4-4-初始化" class="headerlink" title="4.4.初始化"></a>4.4.初始化</h3><p>在电脑的某个地方新建一个名为 hexo 的文件夹（名字可以随便取），比如我的是<code>D:\hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /d/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo 会自动下载一些文件到这个目录，包括 node_modules</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo 就会在 public 文件夹生成相关 html 文件，这些文件将来都是要提交到 github 去的：</p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容</p><p>第一次初始化的时候 hexo 已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：</p><h3 id="4-5-修改主题"><a href="#4-5-修改主题" class="headerlink" title="4.5.修改主题"></a>4.5.修改主题</h3><p>个人觉得官方主题有点不好看，所有就继续了主题的更换，我在进行了一圈主题对比后，个人比较喜欢<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></p><p>首先我们来下载这个主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /d/hexo/</span><br><span class="line">$ npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ol><li>还可以用<code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code>来代替，但是我用这个在后续的修改主题样式的过程中经常出现样式不生效的情况，换成这个<code>npm install hexo-theme-butterfly</code>安装方式后基本解决了这个问题。</li><li>值得一提的是，通过 npm 安装并不会在 themes 里生成主题文件夹，而是在 node_modules 里生成</li><li>butterfly 主题美化教程<a href="https://butterfly.js.org/">butterfly</a></li></ol></blockquote><p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。每次修改了配置文件都要记得先进行<code>hexo clean</code>来清理一下<code>public</code>的内容，然后<code>hexo g</code></p><h3 id="4-5-上传到-Github"><a href="#4-5-上传到-Github" class="headerlink" title="4.5.上传到 Github"></a>4.5.上传到 Github</h3><p>我们先来安装一个插件，要不然后续的<code>hexo d</code>操作会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关 deploy 的部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:zengjiahao1222/zengjiahao1222.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><blockquote><p>在这里，branch 要写 main，因为 2020 年 10 月 1 日 GitHub 官方将默认分支 master 改为了 main</p></blockquote><h3 id="4-6-常用-hexo-命令"><a href="#4-6-常用-hexo-命令" class="headerlink" title="4.6.常用 hexo 命令"></a>4.6.常用 hexo 命令</h3><p>常见命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure><h3 id="4-7-写博客"><a href="#4-7-写博客" class="headerlink" title="4.7.写博客"></a>4.7.写博客</h3><p>定位到我们的 hexo 根目录，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br></pre></td></tr></table></figure><p>hexo 会帮我们在<code>_posts</code>下生成相关 md 文件,我们只需要打开这个文件就可以开始写博客了。当然你也可以直接自己新建 md 文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1, tag2, tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line"><span class="section">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><h4 id="4-7-1-写博客的工具"><a href="#4-7-1-写博客的工具" class="headerlink" title="4.7.1.写博客的工具"></a>4.7.1.写博客的工具</h4><p>这里推荐 Typora</p><h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5.结束语"></a>5.结束语</h2><p>这次的用 hexo+github 搭建个人博客网站的教程到此就结束了，不知道大家是否已经搭建完成了呢，如有知识点和内容上面的错误，请及时联系我来改正</p><p>部分内容转载自<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">小茗同学的博客园</a>,如有侵权，请立刻联系我，进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
