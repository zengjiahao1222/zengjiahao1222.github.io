<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务面试篇</title>
      <link href="/2023/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringCloud5大组件有哪些"><a href="#SpringCloud5大组件有哪些" class="headerlink" title="SpringCloud5大组件有哪些"></a>SpringCloud5大组件有哪些</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815145535466.png" alt="image-20230815145535466"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815145554710.png" alt="image-20230815145554710"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815145625097.png" alt="image-20230815145625097"></p><h2 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h2><ul><li>微服务中必须要使用到的组件</li><li>注册中心的核心作用是：服务注册和发现</li><li>常见的注册中心：eureka、Zookeeper、consul、nacos</li></ul><h3 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a>Eureka的作用</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815152905965.png" alt="image-20230815152905965"></p><ul><li>服务注册：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等</li><li>服务发现：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</li><li>服务监控：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没有接受到心跳，从eureka中剔除</li></ul><h3 id="Nacos的工作流程"><a href="#Nacos的工作流程" class="headerlink" title="Nacos的工作流程"></a>Nacos的工作流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815153718348.png" alt="image-20230815153718348"></p><h3 id="nacos与eureka的区别"><a href="#nacos与eureka的区别" class="headerlink" title="nacos与eureka的区别"></a>nacos与eureka的区别</h3><ul><li>nacos与eureka的共同点（注册中心）<ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li>nacos与eureka的区别（注册中心）<ul><li>nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>nacos集群默认采用AP方式，当集群中存在非临时实例，采用CP模式；eureka采用AP方式</li></ul></li><li>nacos还支持配置中心和服务总线，eureka则只有注册中心，也是选择使用nacos的一个重要原因</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="Ribbon负载均衡流程"><a href="#Ribbon负载均衡流程" class="headerlink" title="Ribbon负载均衡流程"></a>Ribbon负载均衡流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815161454878.png" alt="image-20230815161454878"></p><h3 id="Ribbon负载均衡策略有哪些"><a href="#Ribbon负载均衡策略有哪些" class="headerlink" title="Ribbon负载均衡策略有哪些"></a>Ribbon负载均衡策略有哪些</h3><ul><li><strong>RoundRobinRule：简单轮询服务列表来选择服务器</strong></li><li><strong>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</strong></li><li><strong>RandomRule：随机选择一个可用的服务器</strong></li><li>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li><li>RetryRule：重试机制的选择逻辑</li><li>AvailablilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li><li><strong>ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询（默认）</strong></li></ul><h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><p> 可以自己创建类实现IRule接口，然后再通过配置类或者配置文件配置即可，通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li><p>全局生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>局部生效：</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>一个服务失败，导致整条链路的服务都失败的情形</p><ul><li>熔断降级（解决）</li><li>限流（预防）</li></ul><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815170352777.png" alt="image-20230815170352777"></p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>Hystrix熔断机制，用于监控微服务调用情况，默认是关闭的，如果需要开启需要在引导类上添加注解：@EnableCircuitBreaker</p><p>如果检测到10秒内请求的失败率超过50%，就触发熔断机制。之后每隔5秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815170719342.png" alt="image-20230815170719342"></p><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>为什么需要监控？</p><ul><li>问题定位</li><li>性能分析</li><li>服务关系</li><li>服务告警</li></ul><p>监控方法</p><ul><li>SpringBoo-admin</li><li><strong>prometheus+Grafana</strong>：搭建困难</li><li>zipkin</li><li><strong>skywalking</strong></li></ul><p>最后两个都是链路追踪工具</p><h3 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h3><p>一个分布式系统的应用持续性能监控工具（Application Performance Managment），提供了完善的链路追踪能力，apache的顶级项目</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815191746310.png" alt="image-20230815191746310"></p><ul><li>服务（service）：业务资源应用系统（微服务）</li><li>端点（endpoint）：应用系统对外暴露的功能接口（接口）</li><li>实例（instance）：物理机</li></ul><p>图中&#x2F;api&#x2F;user&#x2F;login就是端点</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>为什么要限流</p><ol><li>并发很大（突发流量）</li><li>防止用户恶意刷接口</li></ol><p>限流的实现方式：</p><ul><li>Tomcat：可以设置最大连接数</li><li>Nginx，漏桶算法</li><li>网关，令牌桶算法</li><li>自定义拦截器</li></ul><h3 id="Nginx限流"><a href="#Nginx限流" class="headerlink" title="Nginx限流"></a>Nginx限流</h3><h4 id="控制速率（突发流量）"><a href="#控制速率（突发流量）" class="headerlink" title="控制速率（突发流量）"></a>控制速率（突发流量）</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815203203943.png" alt="image-20230815203203943"></p><ul><li>语法：<code>limit_req_zone key zone rate</code></li><li>key：定义限流对象，binary_remote_addr就是一种key，基于客户端ip限流</li><li>Zone：定义共享存储区来存储访问信息，10m可以存储16wip地址访问信息</li><li>Rate：最大访问速率，rate&#x3D;10r&#x2F;s 表示每秒最多10个请求</li><li>burst&#x3D;20：相当于桶的大小</li><li>Nodelay：快速处理</li></ul><h4 id="控制并发连接数"><a href="#控制并发连接数" class="headerlink" title="控制并发连接数"></a>控制并发连接数</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815203703750.png" alt="image-20230815203703750"></p><ul><li>limit_conn perip 20：对应的key是$binary_remote_addr，表示限制单个IP同时最多能持有20个连接</li><li>limit_conn perserver 100：对应的key是$server_name，表示虚拟主机（server）同时能处理并发连接的总数</li></ul><h3 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815204335128.png" alt="image-20230815204335128"></p><ul><li>key-resolver：定义限流对象（ip、路径、参数），需代码实现，使用spel表达式获取</li><li>replenishRate：令牌桶每秒填充平均速率</li><li>urstCapacity：令牌桶总容量</li></ul><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance（分区容错性）</li></ul><p><strong>分布式系统无法同时满足这三个指标</strong></p><h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到大的数据必须一致</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815210633139.png" alt="image-20230815210633139" style="zoom:50%;"><h3 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h3><p>Availability（可用性）：用户访问集群中的任意健康节点，必须得到响应，而不是超时或拒绝</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815211028026.png" alt="image-20230815211028026" style="zoom:50%;"><h3 id="Partition-tolerance"><a href="#Partition-tolerance" class="headerlink" title="Partition tolerance"></a>Partition tolerance</h3><p>Partition（分区）：因为网络故障或其他原因导致分布式系统中的部分节点与其他节点时区连接，形成独立分区</p><p>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815211508318.png" alt="image-20230815211508318" style="zoom:50%;"><p>结论：</p><ul><li>分布式系统节点之间肯定是需要网络连接的，分区（P）是必然存在的</li><li>如果保证访问的高可用性（A），可用持续对外提供服务，但不能保证数据的强一致性——&gt;AP</li><li>如果保证访问的数据强一致性（C），就要放弃高可用性——&gt;CP</li></ul><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li>Basically Available（基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li><li>Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li><li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815213248862.png" alt="image-20230815213248862" style="zoom:50%;"><p><strong>解决分布式事务的思想和模型：</strong></p><ul><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后同一提交或回滚（CP）</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul><li>Seata框架（XA、AT、TCC）</li><li>MQ</li></ul><h3 id="Seatac框架"><a href="#Seatac框架" class="headerlink" title="Seatac框架"></a>Seatac框架</h3><p>Seata事务管理中有三个重要的角色：</p><ul><li>TC（Transaction Coordinate）-事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚</li><li>TM（Transaction Manager）-事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务</li><li>RM（Resource Manager）-资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815215443226.png" alt="image-20230815215443226"></p><h3 id="Seata的XA模式"><a href="#Seata的XA模式" class="headerlink" title="Seata的XA模式"></a>Seata的XA模式</h3><p><strong>CP模式</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815220333781.png" alt="image-20230815220333781"></p><h3 id="Seata的AT模式"><a href="#Seata的AT模式" class="headerlink" title="Seata的AT模式"></a>Seata的AT模式</h3><p><strong>AP模式</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815220604180.png" alt="image-20230815220604180"></p><h3 id="Seata的TCC模式"><a href="#Seata的TCC模式" class="headerlink" title="Seata的TCC模式"></a>Seata的TCC模式</h3><p>AP模式</p><p>人工编码实现</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815220856088.png" alt="image-20230815220856088"></p><h3 id="MQ分布式事务"><a href="#MQ分布式事务" class="headerlink" title="MQ分布式事务"></a>MQ分布式事务</h3><p>在A服务写数据时，需要在同一个事务内发送消息到另外一个事务，异步，性能最好</p><p>异步，实时性不是很高，不考虑一致性的情况下可以使用</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815221057016.png" alt="image-20230815221057016"></p><h2 id="分布式服务的接口幂等性"><a href="#分布式服务的接口幂等性" class="headerlink" title="分布式服务的接口幂等性"></a>分布式服务的接口幂等性</h2><p>幂等：多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用结果是一样的</p><p>需要幂等场景</p><ul><li>用户重复点击（网络波动）</li><li>MQ消息重复</li><li>应用使用失败或者超时重试机制</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815223214674.png" alt="image-20230815223214674"></p><h3 id="token-redis"><a href="#token-redis" class="headerlink" title="token+redis"></a>token+redis</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815223441455.png" alt="image-20230815223441455"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815223557463.png" alt="image-20230815223557463"></p><h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p><strong>xxl-job</strong></p><p>xxl-job解决的问题：</p><ul><li>解决集群任务重复执行问题</li><li>cron表达式定义灵活</li><li>定时任务失败了，重试和统计</li><li>任务量大，分片执行</li></ul><h3 id="xxl-job路由策略"><a href="#xxl-job路由策略" class="headerlink" title="xxl-job路由策略"></a>xxl-job路由策略</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815224606625.png" alt="image-20230815224606625"></p><h3 id="xxl-job任务执行失败"><a href="#xxl-job任务执行失败" class="headerlink" title="xxl-job任务执行失败"></a>xxl-job任务执行失败</h3><p>故障转移+失败重试，查看日志分析——&gt;邮件告警</p><h3 id="大数量的任务同时都需要执行"><a href="#大数量的任务同时都需要执行" class="headerlink" title="大数量的任务同时都需要执行"></a>大数量的任务同时都需要执行</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815225101129.png" alt="image-20230815225101129"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次关于微服务及其业务相关的一些常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。内存如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架面试篇</title>
      <link href="/2023/08/15/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/15/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring框架中的bean是单例的</p><ul><li>singleton：bean在每个Spring IOC容器中只有一个实例</li><li>prototype：一个bean的定义可以有多个实例</li></ul><p> <strong>不是线程安全的</strong></p><p>Spring框架中有一个@scope注解，默认的值就是singleton，单例的。</p><p>因为一般在spring的bean都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决问题</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP称为面向切面编程，用于将那些与业务无光，但对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性</p><h3 id="什么地方用到了AOP"><a href="#什么地方用到了AOP" class="headerlink" title="什么地方用到了AOP"></a>什么地方用到了AOP</h3><p>记录操作日志，缓存，spring实现的事务，权限</p><p>核心是：使用aop中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等），获取到这些参数以后，保存到数据库</p><h3 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a>Spring中的事务是如何实现的</h3><ul><li>编程式事务控制：需要使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li><li>声明式事务管理：声明式事务管理建立在AOP之上。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法之前加入一个事务，在执行完目标方法之后根据情况提交或者回滚事务</li></ul><h2 id="事务失效的场景"><a href="#事务失效的场景" class="headerlink" title="事务失效的场景"></a>事务失效的场景</h2><ul><li>异常捕获处理</li><li>抛出检查异常</li><li>非public方法</li></ul><h3 id="异常捕获处理"><a href="#异常捕获处理" class="headerlink" title="异常捕获处理"></a>异常捕获处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//转账的用户不能为空</span></span><br><span class="line">        Account fromAccount accountDao.selectByld(from);</span><br><span class="line">        <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">        <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">            accountDao.updateByld(fromAccount);</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//被转账的用户</span></span><br><span class="line">            Account toAccount accountDao.selectByld(to);</span><br><span class="line">            toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">            accountDao.updateByld(toAccount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：事务通知值捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知则无法知悉</p><p>解决：在catch块中添加<code>throw new RuntimeException(e)</code>抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//转账的用户不能为空</span></span><br><span class="line">        Account fromAccount accountDao.selectByld(from);</span><br><span class="line">        <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">        <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">            accountDao.updateByld(fromAccount);</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//被转账的用户</span></span><br><span class="line">            Account toAccount accountDao.selectByld(to);</span><br><span class="line">            toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">            accountDao.updateByld(toAccount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抛出检查性异常"><a href="#抛出检查性异常" class="headerlink" title="抛出检查性异常"></a>抛出检查性异常</h3><p>什么是检查性异常？</p><ul><li>所有的检查性异常都继承自java.lang.Exception；所有的非检查性异常都继承自java.lang.RuntimeException。</li><li>检查性异常和非检查性异常最主要的区别在于其处理异常的方式：检查性异常必须使用try catch或者throws等关键字进行处理，否则编译器会报错;非检查性异常一般是程序代码写的不够严谨而导致的问题，可以通过修改代码来规避。</li><li>常见的运行时异常：空指针异常(NullPointerException)、除零异常(ArithmeticException)、数组越界异常(ArrayIndexOutOfBoundsException)等;</li><li>常见的检查性异常：输入输出异常(IOException)、文件不存在异常(FileNotFoundException)、SQL语句异常(SQLException)等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">    <span class="comment">//转账的用户不能为空</span></span><br><span class="line">    Account fromAccount accountDao.selectByld(from);</span><br><span class="line">    <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">    <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">        accountDao.updateByld(fromAccount);</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        <span class="comment">//被转账的用户</span></span><br><span class="line">        Account toAccount accountDao.selectByld(to);</span><br><span class="line">        toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateByld(toAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：Spring默认只回滚非检查性异常</p><p>解决：配置rollbackFfor属性</p><p><code>@Transactional(rollbackFor=Exception.calss)</code></p><h3 id="非public方法导致的事务失效"><a href="#非public方法导致的事务失效" class="headerlink" title="非public方法导致的事务失效"></a>非public方法导致的事务失效</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">    <span class="comment">//转账的用户不能为空</span></span><br><span class="line">    Account fromAccount accountDao.selectByld(from);</span><br><span class="line">    <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">    <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">        accountDao.updateByld(fromAccount);</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        <span class="comment">//被转账的用户</span></span><br><span class="line">        Account toAccount accountDao.selectByld(to);</span><br><span class="line">        toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateByld(toAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：Spring为方法创建代理、添加事务通知、前提条件都是该方法是public的</p><p>解决：改为public方法</p><h2 id="Spring的bean的生命周期"><a href="#Spring的bean的生命周期" class="headerlink" title="Spring的bean的生命周期"></a>Spring的bean的生命周期</h2><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>Spring容器在进行实例化时，会将xml配置的<bean>的信息封装成一个BeanDefinition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean</bean></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaolmpl&quot;</span><span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.itheima.service.UserServicelmpl&quot;</span><span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span><span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814201434684.png" alt="image-20230814201434684"></p><ul><li>beanClassName:bean的类名</li><li>initMethodName：初始化方法名称</li><li>properryValues：bean的属性值</li><li>scope：作用域</li><li>lazyInit：延迟初始化</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814203852453.png" alt="image-20230814203852453"></p><ol><li>通过BeanDefinition获取bean的定义信息</li><li>调用构造函数实例化bean</li><li>bean的依赖注入</li><li>处理Aware接口（BeanNameAware、BeanFactoryAware、ApplicationContextAware）</li><li>Bean的后置处理器BeanPostProcessor-前置</li><li>初始化方法（InitializingBean、init-method）</li><li>Bean的后置处理器BeanPostProcessor-后置</li><li>销毁Bean</li></ol><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>下面先看两段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建A对象的同时需要使用B对象，在创建B对象的同时需要使用到A对象</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814204917847.png" alt="image-20230814204917847"></p><h3 id="三级缓存解决循环依赖"><a href="#三级缓存解决循环依赖" class="headerlink" title="三级缓存解决循环依赖"></a>三级缓存解决循环依赖</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210703972.png" alt="image-20230814210703972"></p><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210713822.png" alt="image-20230814210713822"></p><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210810279.png" alt="image-20230814210810279"></p><p><strong>二级缓存不能解决代理对象</strong></p><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210902661.png" alt="image-20230814210902661"></p><h3 id="构造方法出现了循环依赖"><a href="#构造方法出现了循环依赖" class="headerlink" title="构造方法出现了循环依赖"></a>构造方法出现了循环依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//B成员变量</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法执行了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//B成员变量</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法执行了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的依赖注入</p><p>报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure><p>解决：</p><p>使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A的构造方法执行了&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.b=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><blockquote><p>SpringMVC的执行流程是这个框架最核心的内容</p><ul><li>视图阶段（老旧JSP等）</li><li>前后端分离阶段（接口开发，异步）</li></ul></blockquote><h3 id="视图阶段（JSP）"><a href="#视图阶段（JSP）" class="headerlink" title="视图阶段（JSP）"></a>视图阶段（JSP）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814223414623.png" alt="image-20230814223414623"></p><ol><li>用户发送请求到前端控制器DispatcherServlet</li><li>DispatcherServlet受到请求后调用HandlerMapping（处理器映射器）</li><li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），再一起返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配器调用具体的处理器（Handler&#x2F;Controller）</li><li>Controller执行完成后返回ModelAndView对象</li><li>HandlerAdapter将Controller执行结果返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）</li><li>ViewResolver解析后返回具体的View（视图）</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充到视图中）</li><li>DispatcherServlet响应用户</li></ol><h3 id="前后端分离阶段（接口开发，异步请求）"><a href="#前后端分离阶段（接口开发，异步请求）" class="headerlink" title="前后端分离阶段（接口开发，异步请求）"></a>前后端分离阶段（接口开发，异步请求）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814223642023.png" alt="image-20230814223642023"></p><ol><li>用户发送请求到前端控制器DispatcherServlet</li><li>DispatcherServlet受到请求后调用HandlerMapping（处理器映射器）</li><li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），再一起返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配器调用具体的处理器（Handler&#x2F;Controller）</li><li>方法上添加了@ResponseBody</li><li>通过HttpMessageConverter来返回结果转换为JSON并响应</li></ol><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>在SpringBoot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是：</p><ul><li>@SpringBootConfiguration：该注解与@Configuration注解作用相同，用来声明当前也是一个配置类</li><li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包</li><li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814225822043.png" alt="image-20230814225822043"></p><p>@EnableAutoConfiguration是实现自动化配置的核心注解。该注解通过@Import注解导入对应的配置选择器。内部就是读取了该项目和该项目引用的Jar包的classpath路径下META-INF&#x2F;spring.factories文件中的所配置的类的全类名。在这些配置类中定义的Bean会根据<strong>条件注解</strong>所指定的条件来决定是否需要将其导入到Spring容器中。</p><p>条件判断会有像@ConditionOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入到spring容器中使用。</p><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814230657815.png" alt="image-20230814230657815"></p><h2 id="SpringMVC-1"><a href="#SpringMVC-1" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814230715312.png" alt="image-20230814230715312"></p><h2 id="SpringBoot-1"><a href="#SpringBoot-1" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814230831291.png" alt="image-20230814230831291"></p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程"></a>Mybatis执行流程</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815095250611.png" alt="image-20230815095250611"></p><ol><li>读取Mybatis配置文件：mybatis-config.xml加载运行环境和映射文件</li><li>构造会话工厂SqlSessionFactory</li><li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li><li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li><li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li><li>输入参数映射</li><li>输出结果映射</li></ol><h2 id="Mybatis延迟加载"><a href="#Mybatis延迟加载" class="headerlink" title="Mybatis延迟加载"></a>Mybatis延迟加载</h2><p>延迟加载：需要用到数据时才进行加载，不需要用到数据时就不加载</p><p>Mybatis支持延迟加载，但默认没有开启</p><ul><li>Mybatis中支持一对一关联对象和一对多关联集合对象的延迟加载</li><li>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyloadingEnabled=true|false</code>,默认关闭</li></ul><h3 id="延迟加载底层原理"><a href="#延迟加载底层原理" class="headerlink" title="延迟加载底层原理"></a>延迟加载底层原理</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815100624740.png" alt="image-20230815100624740"></p><ol><li>使用CGLIB创建目标对象的代理对象</li><li>当调用目标方法<code>user.getOrderList()</code>时，进入拦截器<code>invoke</code>方法，发现<code>user.getOrderList()</code>是<code>null</code>值，执行sql查询order列表</li><li>把order查询上来，然后调用<code>user.setOrderList(List&lt;Order&gt; orderList)</code>，接着完成<code>user,getOrderList()</code>方法的调用</li></ol><h2 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h2><ul><li>本地缓存，基于PerpetualCache，本质是一个HashMap</li><li>一级缓存：作用域是session级别</li><li>二级缓存：作用域是namespace和mapper的作用域，不依赖于session</li></ul><h3 id="一级缓存-1"><a href="#一级缓存-1" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认开启了一级缓存</p><h3 id="二级缓存-1"><a href="#二级缓存-1" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存是基于namespace和mapper的作用域其作用的，不是依赖于SQL Session，默认也是采用PerpetualCache的HashMap存储</p><p><strong>默认关闭</strong></p><p>开启：</p><ol><li><p>全局配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>映射文件</p><p>使用<cache>标签让当前mapper生效二级缓存</cache></p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>对于缓存数据更新机制，当某一个作用域（一级缓存Session&#x2F;二级缓存Namespaces）进行了增删改操作后，默认该作用域下的所有select中的缓存将被clear</li><li>二级缓存需要缓存的数据实现Serializable接口</li><li>只有会话提交或关闭以后，一级缓存中的数据才会被转移到二级缓存中</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本次关于常用框架一些常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。内存如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试篇</title>
      <link href="/2023/08/08/MySQL%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/08/MySQL%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="优化之定位慢查询"><a href="#优化之定位慢查询" class="headerlink" title="优化之定位慢查询"></a>优化之定位慢查询</h2><ul><li>聚合查询</li><li>多表查询</li><li>表数据量过大查询</li><li>深度分页查询</li></ul><p>表象：页面加载过慢、接口压测响应时间过长（超过1s）</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><ul><li>调试工具：Arthas</li><li>运维工具：Prometheus、Skywalking</li></ul><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>MySQL自带慢日志</strong></p><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志</p><p>如果需要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启MySQL慢日志查询开关</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="comment">#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p><p><code>/var/lib/mysql/localhost-slow.log</code></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811194645962.png" alt="image-20230811194645962"></p><h2 id="SQL语句执行很慢，如何分析"><a href="#SQL语句执行很慢，如何分析" class="headerlink" title="SQL语句执行很慢，如何分析"></a>SQL语句执行很慢，如何分析</h2><p>可以采用<strong>EXPLAIN</strong>或者<strong>DESC</strong>命令获取MySQL如何执行SELECT语句的信息</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811200331680.png" alt="image-20230811200331680"></p><ul><li><p>possible_keys 当前sql可能会使用到索引</p></li><li><p>key当前sql实际命中的索引</p></li><li><p>key_len 索引占用的大小</p></li></ul><p>通过它们两个查看是否可能会命中索引</p><ul><li><p>Extra 额外的优化建议</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811200634608.png" alt="image-20230811200634608"></p></li><li><p>type 这条sql的连接类型，性能由好到差为NULL、system、const、eq_ref、ref、range、index、all</p><ul><li>system:查询系统中的表</li><li>const：根据主键查询</li><li>eq_ref：主键索引查询或唯一索引查询</li><li>ref：索引查询</li><li>range：范围查询</li><li><strong>index：索引树查询</strong></li><li><strong>all：全盘扫描</strong></li></ul></li></ul><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>可以采用MySQL自带的分析工具EXPLAIN</p><ul><li>通过key和key_len检查是否命中了索引（索引本身存在是否失效的情况）</li><li>通过type字段查看sql是否有进一步优化的空间，是否存在全索引扫描或全盘扫描</li><li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库还维护者满足特定查询算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><h3 id="数据结构对比"><a href="#数据结构对比" class="headerlink" title="数据结构对比"></a>数据结构对比</h3><p>  <img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811203948819.png" alt="image-20230811203948819"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811204005723.png" alt="image-20230811204005723"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811204024947.png" alt="image-20230811204024947"></p><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul><li>索引是帮助MySQL高效获取数据的数据结构（有序）</li><li>提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p><ul><li>阶数更多，路径更短</li><li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子节点存储数据</li><li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li></ul><h2 id="聚簇索引（聚集索引）和非聚簇索引（二级索引）"><a href="#聚簇索引（聚集索引）和非聚簇索引（二级索引）" class="headerlink" title="聚簇索引（聚集索引）和非聚簇索引（二级索引）"></a>聚簇索引（聚集索引）和非聚簇索引（二级索引）</h2><ul><li><strong>聚集索引：</strong>将数据存储与索引放到一块，索引结构的叶子节点保存行数据（必须用，而且只有一个）</li><li><strong>二级索引：</strong>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键（可以存在多个）</li></ul><p>聚集索引选举规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812151510853.png" alt="image-20230812151510853"></p><p>通过二级索引找到对应的主键值，然后再通过主键值找到聚集索引中所对应的整行数据，这个过程就是回表</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能找到（没有进行回表查询）</p><ul><li>使用id查询，直接走聚集索引查询，一次索引查询，直接返回数据，性能高</li><li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用<code>select *</code></li></ul><h3 id="MySQL超大分页处理"><a href="#MySQL超大分页处理" class="headerlink" title="MySQL超大分页处理"></a>MySQL超大分页处理</h3><p>在数据量比较大的时候，如果进行limit分页查询，在查询时，越往后，分页1查询效率越低</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812154000508.png" alt="image-20230812154000508"></p><p>因为，当在进行分页查询时，如果执行limit 9000000，10，此时需要MySQL排序前9000010记录，仅仅返回9000000-9000010的记录，其他记录丢弃，查询排序的代价非常大</p><p><strong>优化思路：</strong>一般分页查询时，通过创建覆盖索引能够比较好的提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from tb_sku t,</span><br><span class="line">(select id from tb_sku order by id limiit 9000000,10) a</span><br><span class="line">where t.id=a.id;</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812154511068.png" alt="image-20230812154511068"></p><h2 id="索引创建的原则"><a href="#索引创建的原则" class="headerlink" title="索引创建的原则"></a>索引创建的原则</h2><p>索引一般包括：</p><ul><li>主键索引</li><li>唯一索引</li><li>根据业务创建的索引（复合索引）</li></ul><p><strong>原则：</strong></p><ul><li>针对于数据量较大，且查询比较频繁的表建立索引。（单表超过10w数据，增加用户体验）</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL指，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ul><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>怎么判断索引是否失效了呢？ <strong>执行计划explain</strong></p><ol><li><p>违反最左前缀法则</p><p>如果索引了多列，要遵循最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引</p><p>如果符合最左法则，但是出现跳跃了某一列，只有最左列索引生效</p></li><li><p>范围查询右边地列，不能使用索引</p></li><li><p>不要在索引列上进行运算操作，索引将失效</p></li><li><p>字符串不加单引号，造成索引失效</p><p>MySQL的查询优化器，会自动地进行类型转换，造成索引失效</p></li><li><p>以%开头的like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p></li></ol><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ul><li>表的设计优化（参考阿里开发手册《嵩山版》）</li><li>索引优化</li><li>SQL语句优化</li><li>主从复制、读写分离</li><li>分库分表</li></ul><h3 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h3><ul><li>比如设置合适地数值（tinyint、int、bigint），要根据实际情况选择</li><li>比如设置合适地字符串类型（char、varchar）char定长效率高，varchar可变长度，效率较低</li></ul><h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><ul><li>select语句务必指明字段名称（避免直接使用select *）</li><li>SQL语句要避免造成索引失效地写法</li><li>尽量使用union all代替union 因为union会多过滤一次，效率低</li><li>避免在where子句中对字段进行表达式操作</li><li>Join优化：能用innerjoin就不用left join、right join，如必须使用一定要以小表为驱动，内连接会对两个表进行优化，优先把小的表放到外边，把大地表放到里边。left join或right join，不会重新调整顺序</li></ul><h3 id="主从复制、读写分离"><a href="#主从复制、读写分离" class="headerlink" title="主从复制、读写分离"></a>主从复制、读写分离</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812172114879.png" alt="image-20230812172114879"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败</p><p><strong>ACID：</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或者回滚，它对数据库中的数据的改变就是永久的。</li></ul><h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><ul><li>脏读：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>不可重复读： 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li>幻读：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>不可重复读和幻读区别：</strong></p><p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交（READ UNCOMMITTED）：什么都不能解决</li><li>读提交 （READ COMMITTED）：解决了脏读</li><li>可重复读 （REPEATABLE READ）：解决不可重复读和脏读</li><li>串行化 （SERIALIZABLE）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。<strong>解决了幻读</strong>的提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。</li></ul><h2 id="undo-log和redo-log的区别"><a href="#undo-log和redo-log的区别" class="headerlink" title="undo log和redo log的区别"></a>undo log和redo log的区别</h2><ul><li>缓冲池（buffer pool）：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li><li>数据页（page）：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16kb。页中存储的是行数据</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813094355800.png" alt="image-20230813094355800"></p><p>如果服务器宕机，可能内存中的数据还没有同步到磁盘中，会出现数据不一致的问题</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong></p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813094855143.png" alt="image-20230813094855143"></p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和<strong>MVCC</strong>（多版本并发控制）。undo log和redo log记录物理日志不一样，它是逻辑日志</p><ul><li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li><li>当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并且进行回滚</li></ul><p><strong>undo log可以实现事务的一致性和原子性</strong></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>redo log：记录的是数据页的物理变化，服务器宕机可以用来同步数据</li><li>undo log：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据</li><li>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</li></ul><h2 id="事务的隔离性如何保证"><a href="#事务的隔离性如何保证" class="headerlink" title="事务的隔离性如何保证"></a>事务的隔离性如何保证</h2><p>锁：排他锁（如一个事务获取了一个数据行的排他锁，其他事务就不能在获取该行的其他锁）</p><p>mvcc：多版本并发控制</p><h3 id="解释一下MVCC"><a href="#解释一下MVCC" class="headerlink" title="解释一下MVCC"></a>解释一下MVCC</h3><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p><p>MVCC的具体实现，主要依赖于数据库记录中的隐式字段、undo log日志、readView</p><h3 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC-实现原理"></a>MVCC-实现原理</h3><ul><li><p>记录中的隐藏字段</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813105731519.png" alt="image-20230813105731519"></p></li><li><p>undo log</p><ul><li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志</li><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除</li><li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除</li></ul></li><li><p>undo log版本链</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813120842925.png" alt="image-20230813120842925"></p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生产一条记录版本链表，链表的头部是最新的旧记录，链表的尾部是最早的旧记录</p></li><li><p>readvi ew</p><p>ReadView（读视图）是<strong>快照读</strong>SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p><ul><li><p>当前读</p><p>读取的是记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select…lock in share mode（共享锁），select…for update、update、insert、delete（排他锁）都是一种当前读</p></li><li><p>快照读</p><p>简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p><ul><li>Read Committed：每次select，都生成一个快照读</li><li>Repeatable Read：开启事务后第一个select语句语句才是快照读的地方</li></ul></li></ul></li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813150523257.png" alt="image-20230813150523257"></p><p>其中m_ids是<strong>未提交的事务</strong>  </p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813150838902.png" alt="image-20230813150838902"></p><p>  <img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813151138712.png" alt="image-20230813151138712"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813151203898.png" alt="image-20230813151203898"></p><h2 id="MySQL主从同步原理"><a href="#MySQL主从同步原理" class="headerlink" title="MySQL主从同步原理"></a>MySQL主从同步原理</h2><p>MySQL主从复制的核心就是二进制日志</p><blockquote><p>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句</p></blockquote><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813151916561.png" alt="image-20230813151916561"></p><p>复制分为三步：</p><ol><li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li><li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志RelayLog</li><li>slave重做中继日志中的事件，将改变反映它自己的数据</li></ol><h2 id="MySQL分库分表"><a href="#MySQL分库分表" class="headerlink" title="MySQL分库分表"></a>MySQL分库分表</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813152351552.png" alt="image-20230813152351552"></p><p>分库分表的时机：</p><ul><li><strong>前提</strong>，项目业务数据逐渐增多，或业务发展比较迅速（单表的数据量达到1000W或20G）</li><li>优化解决不了性能的问题（主从读写分离、查询索引…）</li><li>IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询，连接数太多）</li></ul><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>以表为依据，根据业务将不同表拆分到不同库中</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813152821813.png" alt="image-20230813152821813"></p><p>特点：</p><ul><li>按业务对数据分级管理、维护、监控、扩展</li><li>在高并发下，提高磁盘IO的数据量连接数</li></ul><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>以字段为依据，根据字段属性将字段拆分到不同表中</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813153037699.png" alt="image-20230813153037699"></p><p>拆分规则：</p><ul><li>把不常用的字段单独放在一张表</li><li>把text、blob等大字段拆分出来放到附表中</li></ul><p>特点：</p><ul><li>冷热数据分离</li><li>减少IO过度争抢，两表互不影响</li></ul><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>将一个库的数据库拆分到多个库中</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813153341310.png" alt="image-20230813153341310"></p><p>路由规则：</p><ul><li>根据id节点取模</li><li>按id也就是范围路由，节点1（1-100W），节点2（100W-200W）</li></ul><p>特点：</p><ul><li>解决了单库大数量，高并发的性能瓶颈</li><li>提高了系统的稳定性和可用性</li></ul><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>将一个表的数据拆分到多个表中（可以在同一个库内）</p><p>特点：</p><ul><li>优化单一表数据量过大而产生的性能问题</li><li>避免IO争抢并减少锁表的几率</li></ul><h3 id="分库之后的问题"><a href="#分库之后的问题" class="headerlink" title="分库之后的问题"></a>分库之后的问题</h3><ul><li>分布式事务一致性问题</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul><p><strong>解决：</strong></p><p>分库分表中间件：</p><ul><li>sharding-sphere</li><li>mycat</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次关于MySQL面试常被问到的问题分享就到这了，小编也是通过网上的学习来总结的。如有不足和错误的地方请联系小编来改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试篇</title>
      <link href="/2023/08/04/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/04/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>查询到一个不存在的的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>缓存空数据，查询返回的数据为空，空结果也缓存</strong></p><p>优点：简单</p><p>缺点：消耗内存，可能会发生数据不一致的问题（后续数据库中又有数据了）</p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p><strong>布隆过滤器</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809193034083.png" alt="image-20230809193034083"></p><p>优点：内存占用少，没有多余key</p><p>缺点：实现复杂（Redisson、Guava），存在误判</p><p><a href="https://blog.csdn.net/dreaming9420/article/details/124153422">布隆+redisson配置</a></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>给某一个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这写并发的请求可能会瞬间吧DB压垮</p><h3 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>互斥锁</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809195304787.png" alt="image-20230809195304787"></p><h3 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h3><p><strong>逻辑过期</strong></p><p>不能保证数据的绝对一致</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809195327521.png" alt="image-20230809195327521"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量的请求到达数据库，带来巨大压力</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>给不同的key的TTL添加随机值</p></li><li><p>利用Redis集群提高高服务的可用性 （哨兵模式、集群模式）</p></li><li><p>给缓存业务添加降级限流策略  （nginx、SpringCloud gateway）</p></li><li><p>给业务添加多级缓存 （Guava、Caffeine）</p><h2 id="穿透、击穿、雪崩总结"><a href="#穿透、击穿、雪崩总结" class="headerlink" title="穿透、击穿、雪崩总结"></a>穿透、击穿、雪崩总结</h2></li></ul><blockquote><p>穿透无中生有key，布隆过滤null隔离</p><p>缓存击穿过期key，锁与非期解难题</p><p>雪崩大量过期key，过期时间要随机</p><p>面试必考三兄弟，可用限流来保底</p></blockquote><h2 id="双写一致"><a href="#双写一致" class="headerlink" title="双写一致"></a>双写一致</h2><p>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p><ul><li>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</li><li>写操作：延迟双删</li></ul><p>删除缓存——修改数据库—(延迟)—删除缓存</p><p>注意：先删除缓存回事先修改数据库都会出问题-脏数据(所以需要删除两次缓存)</p><h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p><strong>分布式锁</strong></p><p>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</p><p>排他锁：独占锁writeLock，加锁之后，阻塞其他线程的读写操作</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809205812468.png" alt="image-20230809205812468"></p><h3 id="延迟一致性"><a href="#延迟一致性" class="headerlink" title="延迟一致性"></a>延迟一致性</h3><p><strong>异步通知保证数据的最终一致性</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809205915306.png" alt="image-20230809205915306"></p><p>基于Canal的异步通知</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809205944365.png" alt="image-20230809205944365"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>允许延迟一致的业务，采用异步通知<ul><li>使用MQ中间件，更新数据之后，通知缓存删除</li><li>利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存</li></ul></li><li>强一致性的，采用Redisson提供的读写锁<ul><li>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</li><li>排他锁：独占锁writeLock，加锁之后，阻塞其他线程的读写操作</li></ul></li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB全称Redis Database Backup file（Redis数据备份文件），也叫做Redis数据快照。简单来说就是把内存中的所有数据记录到磁盘中。当Redis实例故障重启后，从磁盘中读取快照文件，恢复数据。</p><p><strong>主动备份</strong></p><p>save：由Redis主进程来执行RDB，会阻塞所有命令</p><p>bgsave：开启子进程执行RDB，避免主进程受到影响</p><p><strong>自动备份</strong></p><p>Redis内部有触发RDB的机制，可以在Redis.conf文件中找到，格式如下：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810143040716.png" alt="image-20230810143040716"></p><p><strong>RDB的执行原理</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810144106530.png" alt="image-20230810144106530"></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p>AOF默认是关闭的，需要修改redis.conf配置文件开启AOF：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810145042104.png" alt="image-20230810145042104"></p><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810145200302.png" alt="image-20230810145200302"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810145219166.png" alt="image-20230810145219166"></p><p> 因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<strong>bgrewriteaof</strong>命令，可以让AOF文件执行重写功能，用最少的命令达到相同的效果。</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810150041188.png" alt="image-20230810150041188"></p><p>Redis也会在触发阈值时自动取重写AOF文件。阈值也可以在redis.conf中配置：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810150218610.png" alt="image-20230810150218610"></p><h3 id="RBD和AOF对比"><a href="#RBD和AOF对比" class="headerlink" title="RBD和AOF对比"></a>RBD和AOF对比</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810150545557.png" alt="image-20230810150545557"></p><h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><p>Redis对数据设置数据的有效时间，数据过期之后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>设置过期Key的过期时间后，我们不去管它，当需要该key时，我们再检查是否过期，如果过期，我们就删除它，反之返回该key</p><p><strong>优点：</strong>对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p><p><strong>缺点：</strong>对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>每隔一段时间，我们就会对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key）</p><p>定期清理有两种模式：</p><ul><li>SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf的<strong>hz</strong>选项来调整这个次数</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><p><strong>优点：</strong>可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存</p><p><strong>缺点：</strong>难以确定删除操作执行的时长和频率</p><p><strong>Redis的过期删除策略：惰性删除+定期删除两种策略配合使用</strong></p><h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>当Redis中的内存不够用时，此时在向Redis中添加新的key,那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>Redis支持八种不同策略来选择要删除的key：</p><ul><li>noeviction:不淘汰如任何的key，但是内存满时不允许写入新数据，<strong>默认</strong></li><li>volatile-ttl：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key，随机进行淘汰</li><li>volatile-random：对设置了TTL的key，随机进行淘汰</li><li>allkeys-lru：对全体key，基于LRU算法进行淘汰</li><li>volatile-lru：对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu：对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu：对设置了TTL的key，基于LFU算法进行淘汰</li></ul><blockquote><ul><li>LRU（Least Recently Used）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰的优先级越高</li><li>LFU（Least Frequently Used）最少频率使用。会统计每一个key的访问频率，值越小淘汰优先级越高</li></ul></blockquote><p><strong>记单词</strong></p><blockquote><ul><li>eviction：驱逐</li><li>volatile：挥发性的</li><li>Least：最少</li><li>Recently：最近</li><li>Frequently：频率</li></ul></blockquote><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul><li>优先使用allkeys-lru策略。充分利用LRU算法的优势，把最近常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用</li><li>如果业务的数据访问频率差别不大，没有明显的冷热数据区分，建议使用allkeys-random，随机选择淘汰</li><li>如果业务中有置顶的需求，可以使用volatile-lru策略，同时把置顶的数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据</li><li>如果业务中有短时高频访问的数据，可以使用allkeys-lfu或volatile-lfu策略</li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>Redis实现分布式锁主要利用Redis的**<code>setnx</code>**命令。setnx是SET if not exists（如果不存在，则SET）的简写</p><p>获取锁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加锁，nx是互斥，ex是设置超时时间</span></span><br><span class="line">SET lock value NX EX 10</span><br></pre></td></tr></table></figure><p>问题来了，为什么不用setnx，然后再设置过期时间勒？</p><p>因为如果用<strong>两条命令的话，可能不能保证原子性</strong></p><p>释放锁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可</span></span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure><p>Redis实现分布式锁如何合理控制锁的有效时长？不能让它一直占着锁啊或者不能让它没有实现业务就释放锁啊</p><ul><li>根据业务执行时间预估（难以预估）</li><li>给锁续期（Redisson的看门狗）</li></ul><h3 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h3><p><strong>底层是setnx和lua脚本（保证原子性）</strong></p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810185856392.png" alt="image-20230810185856392"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redisLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//获取锁（重入锁），执行锁的名称</span></span><br><span class="line">    RLock lock=redissonClient.getLock(<span class="string">&quot;lockName&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别为：获取锁的最大等待时间（期间会重试），锁自动释放的时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock) &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>看门狗默认是每隔10秒续期</li><li>如果设置了锁自动释放的时间，那么Redisson认为你能把握业务执行的时间，看门狗机制就会失效</li><li>加锁、设置过期时间等操作都是基于lua脚本完成，保证了原子性</li></ul><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add1</span><span class="params">()</span> &#123;</span><br><span class="line">    RLock lock redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> isLock lock.tryLock(;</span><br><span class="line">    ∥执行业务</span><br><span class="line">    add2();</span><br><span class="line">    ∥释放锁</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add2</span><span class="params">()</span> &#123;</span><br><span class="line">    RLock lock redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> isLock lock.tryLock(;</span><br><span class="line">    ∥执行业务</span><br><span class="line">    ∥释放锁</span><br><span class="line">    lock.unlock(;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810191218071.png" alt="image-20230810191218071"></p><p><strong>必须要同一线程</strong></p><h4 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810191708302.png" alt="image-20230810191708302"></p><p>RedLock（红锁）：不能再一个redis实例上创建锁，应该是在多个redis实例上创建锁（n&#x2F;2+1），避免在一个redis实例上加锁</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810191739505.png" alt="image-20230810191739505"></p><blockquote><ul><li>CAP：C（一致性），A（可用性），P（分区容错）</li><li>AP思想：高可用和分区容错性</li><li>CP思想：一致性和分区容错性</li></ul></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810194450035.png" alt="image-20230810194450035"></p><h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><h4 id="主从全量同步"><a href="#主从全量同步" class="headerlink" title="主从全量同步"></a>主从<strong>全量同步</strong></h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810195159915.png" alt="image-20230810195159915"></p><p>Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p><p>offset：偏移量，随着记录在repl_baklog中的数据增多而越来越大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后与master，需要更新</p><h4 id="主从增量同步（slave重启或者后期数据变化）"><a href="#主从增量同步（slave重启或者后期数据变化）" class="headerlink" title="主从增量同步（slave重启或者后期数据变化）"></a>主从<strong>增量同步</strong>（slave重启或者后期数据变化）</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810195621517.png" alt="image-20230810195621517"></p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><ul><li><strong>监控：</strong>Sentinel会不断检查您的master和slave是否按照预期工作</li><li><strong>自动故障恢复：</strong>如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也将以新的master为主</li><li><strong>通知：</strong>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新的信息推给Redis的客户端</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810210534973.png" alt="image-20230810210534973"></p><h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p>Sentinel基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：如果超过指定数量（quorum）的sentinel都认为i该实例主观下线，则该实例<strong>客观下线</strong>。quorum最好超过Sentinel实例数量的一半。</li></ul><h3 id="哨兵选主规则"><a href="#哨兵选主规则" class="headerlink" title="哨兵选主规则"></a>哨兵选主规则</h3><ul><li>首先判断主与从节点断开时间长短，如超过指定值就排除该从节点</li><li>如果判断从节点的slave-priority值，越小优先级越高</li><li>如果slave-priority一样，则判断slave节点的offset值，越大优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高</li></ul><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>由于某种网络原因，主节点与sentinel集群断开连接了，但是没有宕机，sentinel集群会在剩下的从节点中选举一个为主节点。然后原来的主节点恢复后，只能成为新主节点的从节点。那么问题来了，在那段时间，客户端给老主节点的数据都丢失了</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810211746776.png" alt="image-20230810211746776"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810212046177.png" alt="image-20230810212046177"></p><p><strong>解决：</strong>Redis中有两个参数配置</p><p><code>min-replicas-to-write 1</code> 表示最少的salve节点为1个</p><p><code>min-replicas-max-lag 5</code> 表示数据复制和同步的延迟不能超过5秒</p><h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul><p>使用分片集群可以解决上诉问题，分片集群特征：</p><ul><li>集群中有多个master，每个master保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping检测彼此健康状态</li><li>客户端1请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810214027959.png" alt="image-20230810214027959"></p><h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><p>Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置到哪个槽，集群中每个节点负责一部分hash槽。</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810214435441.png" alt="image-20230810214435441"></p><h2 id="Redis是单线程的，但是为什么还是那么快-1"><a href="#Redis是单线程的，但是为什么还是那么快-1" class="headerlink" title="Redis是单线程的，但是为什么还是那么快-1"></a>Redis是单线程的，但是为什么还是那么快-1</h2><ul><li><p>Redis是纯内存操作，执行速度非常快</p></li><li><p>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</p></li><li><p>使用I&#x2F;O多路复用模型，非阻塞IO</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810221709994.png" alt="image-20230810221709994"></p></li></ul><h2 id="I-x2F-O多路复用模型-2"><a href="#I-x2F-O多路复用模型-2" class="headerlink" title="I&#x2F;O多路复用模型-2"></a>I&#x2F;O多路复用模型-2</h2><p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p><p><strong>先搞清下面概率：</strong></p><ul><li>用户空间和内核空间</li><li>常见的IO模型<ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li></ul></li><li>Redis网络模型</li></ul><h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><ul><li>Liux系统中一个进程使用的内存情况划分两部分：内核空间、用户空间</li><li>用户空间只能执行受限的命令(Rig3)，而且不能直接调用系统资源，必须通过内核提供的接口来访问</li><li>内核空间可以执行特权命令(Rig0)，调用一切系统资源</li></ul><p>Lux系统为了提高引O效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲☒</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220055789.png" alt="image-20230810220055789"></p><p>下面讲的模型是为了解决等待数据就绪时间和读数据读来读去的问题</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220313091.png" alt="image-20230810220313091"></p><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220452514.png" alt="image-20230810220452514"></p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220821787.png" alt="image-20230810220821787"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810221022716.png" alt="image-20230810221022716"></p><h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810221353978.png" alt="image-20230810221353978"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次关于Redis面试常被问到的问题分享就到这了，小编也是通过网上的学习来总结的。如有不足和错误的地方请联系小编来改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础篇</title>
      <link href="/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的十大数据类型"><a href="#Redis的十大数据类型" class="headerlink" title="Redis的十大数据类型"></a>Redis的十大数据类型</h2><h3 id="redis字符串（String）"><a href="#redis字符串（String）" class="headerlink" title="redis字符串（String）"></a>redis字符串（String）</h3><ul><li>string是redis最基本的类型，一个key对应一个value</li><li>string类型是二进制安全的，意思是redis的string可以包含任何数据，比如1jpg图片或者序列化的对象</li><li>string类型是redis对基本的数据类型，一个redis中字符串value最多可以是512M</li></ul><h3 id="redis列表（List）"><a href="#redis列表（List）" class="headerlink" title="redis列表（List）"></a>redis列表（List）</h3><ul><li>redis列表是最简单的字符串列表，按照插入的顺序排列。你可以添加一个元素到列表的头部（左边）或者是尾部（右边）</li><li>它的底层实际上是个双端链表，最多可以包含2^32-1个元素（4294967295，每个列表超过40亿个元素）</li></ul><h3 id="redis哈希表（Hash）"><a href="#redis哈希表（Hash）" class="headerlink" title="redis哈希表（Hash）"></a>redis哈希表（Hash）</h3><ul><li>redis hash是一个string类型的field（字段）和value（值）的映射表，hash特别适合用于存储对象。</li><li>redis中每个hash可以存储2^32-1个键值对</li></ul><h3 id="redis集合（Set）"><a href="#redis集合（Set）" class="headerlink" title="redis集合（Set）"></a>redis集合（Set）</h3><ul><li>redis的Set是String类型的无序集合。集合的成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是intset或者hashtable</li><li>redis中Set集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)。</li><li>集合中最大的成员数为2^32-1</li></ul><h3 id="reids有序集合（ZSet）"><a href="#reids有序集合（ZSet）" class="headerlink" title="reids有序集合（ZSet）"></a>reids有序集合（ZSet）</h3><ul><li>ZSet(sorted set：有序集合)</li><li>redis zset和set一样也是string类型元素的集合，且不允许有重复的成员</li><li>不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序</li><li>zset的成员是唯一的，但分数（score）却可以重复</li><li>zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1</li></ul><h3 id="redis地理空间（GEO）"><a href="#redis地理空间（GEO）" class="headerlink" title="redis地理空间（GEO）"></a>redis地理空间（GEO）</h3><ul><li>reids GEO主要用于存储地理位置信息，并对存储的信息进行操作，包括添加地理位置的坐标、获取地理位置的坐标、计算两个地理位置之间的距离、根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</li></ul><h3 id="redis基数统计（HyperLogLog）"><a href="#redis基数统计（HyperLogLog）" class="headerlink" title="redis基数统计（HyperLogLog）"></a>redis基数统计（HyperLogLog）</h3><ul><li>HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是：在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定且是很小的</li><li>在redis里面，每个HyperLogLog键只需要花费12KB内存就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多消耗的内存就越多的集合形成了鲜明的对比。</li><li>但是，因为HyperLogLog只会根据输入的元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</li></ul><h3 id="redis位图（bigmap）"><a href="#redis位图（bigmap）" class="headerlink" title="redis位图（bigmap）"></a>redis位图（bigmap）</h3><ul><li><p>Bit arrays（or simply bitmaps，我们可以称之为位图）</p></li><li><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604193941229.png" alt="image-20230604193941229"></p></li><li><p>由0和1状态表现的二进制位的bit数组</p></li></ul><h3 id="redis位域（bitfield）"><a href="#redis位域（bitfield）" class="headerlink" title="redis位域（bitfield）"></a>redis位域（bitfield）</h3><ul><li>通过bitfield命令可以一次性操作多个<strong>比特位域</strong>（指的是连续的多个比特位），它会执行一系列操作并且返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</li><li>说白了就是通过bitfield命令我们可以一次性对多个比特位域进行操作</li></ul><h3 id="redis流（Stream）"><a href="#redis流（Stream）" class="headerlink" title="redis流（Stream）"></a>redis流（Stream）</h3><ul><li>redis Stream是redis 5.0版本新增加的数据结构。</li><li>redis Stream主要用于消息队列（MQ），redis本身是有一个redis发布订阅（pub&#x2F;sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开，redis宕机等，消息就会被丢弃。</li><li>简单来说发布订阅可以分发消息，但无法记录历史消息</li><li>而redis Stream提供的消息持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</li></ul><h2 id="Redis键（Key）"><a href="#Redis键（Key）" class="headerlink" title="Redis键（Key）"></a>Redis键（Key）</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ul><li>del key：删除存在的key</li><li>dump key：序列化给定key，并返回被序列化的值</li><li>exists key：检查给定key是否存在</li><li>expire key seconds：为给定的key设置过期时间</li><li>keys pattern：查找所有符合给定模式（pattern）的key</li><li>move key db：将当前数据库的key移动到给定的数据库db中</li><li>persist  key：移除key的过期时间，key将持久保持</li><li>pttl key：以毫秒返回key的剩余的过期时间</li><li>ttl key：以秒为单位，返回给定key的剩余生存时间</li><li>randomkey：从当前数据库随机返回一个key</li><li>rename key newkey：修改key的名称</li><li>renamenx key newkey：仅当newkey不存在时，将key改名为newkey</li><li>type key：返回key所存储的值的类型</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>keys *：查看当前库的所有key</li><li>unlink key：非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续的异步中操作</li><li>select dbindex（0-15）：切换数据库，默认为0</li><li>dbsize：查看当前数据库key的数量</li><li>flushdb：清空当前库</li><li>flushall：通杀全部库</li></ul><h2 id="数据类型命令及落地运用"><a href="#数据类型命令及落地运用" class="headerlink" title="数据类型命令及落地运用"></a>数据类型命令及落地运用</h2><h3 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604212922726.png" alt="image-20230604212922726"></p><h4 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h4><ul><li>set key value</li><li>get key</li></ul><h4 id="同时设置-x2F-获取多个键值"><a href="#同时设置-x2F-获取多个键值" class="headerlink" title="同时设置&#x2F;获取多个键值"></a>同时设置&#x2F;获取多个键值</h4><ul><li>mset key value[key value….]</li><li>mget key[key…]</li><li>msetnx：同时设置一个或多个键值对时当且仅当所有给定的key都不存在</li></ul><h4 id="获取-x2F-设置指定范围的值"><a href="#获取-x2F-设置指定范围的值" class="headerlink" title="获取&#x2F;设置指定范围的值"></a>获取&#x2F;设置指定范围的值</h4><ul><li>getrange&#x2F;setrange key between…and</li></ul><h4 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h4><p>一定要是数字才能进行加减</p><ul><li>递增&#x2F;递减：incr key&#x2F;decr key</li><li>增加&#x2F;减少指定的整数：incrby&#x2F;decrby key 多少</li></ul><h4 id="获取字符串长度和内容追加"><a href="#获取字符串长度和内容追加" class="headerlink" title="获取字符串长度和内容追加"></a>获取字符串长度和内容追加</h4><ul><li>strlen key</li><li>append key value</li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li>setnx key value：只有在key不存在时设置key的值</li><li>setex：设置带过期时间的key，动态设置</li></ul><h4 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h4><ul><li>getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)</li></ul><h3 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604213144877.png" alt="image-20230604213144877"></p><h4 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h4><p>单key多value</p><ul><li><p>一个双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。</p></li><li><p>left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p></li><li><p>它的底层实际是个<strong>双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</strong></p></li></ul><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ul><li>lpush&#x2F;rpush&#x2F;lrange</li><li>lpop&#x2F;rpop</li><li>lindex：按照索引下标获得元素（从上到下）</li><li>llen：获取列表中元素的个数</li><li>lrem key 数字N 给定值v1：删除N个值等于v1的元素</li><li>ltrim key 开始index 结束index：截取指定范围的值后再赋值给key</li><li>rpoplpush 源列表 目的列表：移除列表的最后一个元素，并将该元素添加到另一个列表并返回</li><li>lset key index value：将下标位置的值设置为value</li><li>linsert key before&#x2F;after ：在list某个已有值的前后再添加具体值</li></ul><p>微信公众号订阅的消息</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604215441175.png" alt="image-20230604215441175"></p><h3 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604215608650.png" alt="image-20230604215608650"></p><p><strong>KV模式不变，但V是一个键值对</strong></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>JD购物车早期，设计目前不再采用，当前中小厂可用</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220140355.png" alt="image-20230604220140355"></p><h3 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220501578.png" alt="image-20230604220501578"></p><p><strong>单值多value，且无重复</strong></p><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>微信抽奖小程序</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220652689.png" alt="image-20230604220652689"></p><p>朋友圈点赞</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222142611.png" alt="image-20230604222142611"></p><h3 id="Redis有序集合（ZSet）"><a href="#Redis有序集合（ZSet）" class="headerlink" title="Redis有序集合（ZSet）"></a>Redis有序集合（ZSet）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222402880.png" alt="image-20230604222402880"></p><p>在set的基础上，每个value前加了一个score分数值。之前set k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2</p><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222638776.png" alt="image-20230604222638776"></p><h3 id="Redis位图（bitmap）"><a href="#Redis位图（bitmap）" class="headerlink" title="Redis位图（bitmap）"></a>Redis位图（bitmap）</h3><p>由0和1状态表现的二进制位的bit数组</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222850415.png" alt="image-20230604222850415"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222947562.png" alt="image-20230604222947562"></p><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223220863.png" alt="image-20230604223220863"></p><h3 id="Redis基数统计（HyperLogLog）"><a href="#Redis基数统计（HyperLogLog）" class="headerlink" title="Redis基数统计（HyperLogLog）"></a>Redis基数统计（HyperLogLog）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223534692.png" alt="image-20230604223534692"></p><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223630392.png" alt="image-20230604223630392"></p><h3 id="Redis地理空间（GEO）"><a href="#Redis地理空间（GEO）" class="headerlink" title="Redis地理空间（GEO）"></a>Redis地理空间（GEO）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>移动互联网时代LBS应用越来越多，交友软件中附近的小姐姐、外卖软件中附近的美食店铺、高德地图附近的核酸检查点等等，那这种附近各种形形色色的XXX地址位置选择是如何实现的？</li><li>地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。</li><li>例如滴滴打车，最直观的操作就是实时记录更新各个车的位置，然后当我们要找车时，在数据库中查找距离我们(坐标x0,y0)附近r公里范围内部的车辆</li></ul><p>使用下面的SQL即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> taxi <span class="keyword">from</span> position <span class="keyword">where</span> x0<span class="operator">-</span>r <span class="operator">&lt;</span> x <span class="operator">&lt;</span> x0 <span class="operator">+</span> r <span class="keyword">and</span> y0<span class="operator">-</span>r <span class="operator">&lt;</span> y <span class="operator">&lt;</span> y0<span class="operator">+</span>r</span><br></pre></td></tr></table></figure><p>但是这样会出现什么问题？</p><ul><li>查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的</li><li>这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问</li><li>精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差</li></ul><h3 id="Redis流（Stream）"><a href="#Redis流（Stream）" class="headerlink" title="Redis流（Stream）"></a>Redis流（Stream）</h3><p>Redis版的MQ消息中间件+阻塞队列</p><p>Stream还是不能百分百等价于Kafka、RabbitMQ来使用，生产案例少</p><h3 id="Redis位域（bitfield）"><a href="#Redis位域（bitfield）" class="headerlink" title="Redis位域（bitfield）"></a>Redis位域（bitfield）</h3><p>将一个Redis字符串看作是一个由二进制位组成的数组，并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604225341790.png" alt="image-20230604225341790"></p><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul><li>实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写道磁盘上，也就是快照。这样一来即使故障宕机，快照也不会丢失，数据的可靠性也就得到了保证。</li><li>这个快照文件就称为RDB文件（dump.rdb）</li></ul><h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot内存快照，它恢复时再将硬盘快照文件直接读回到内存里</li><li>redis的数据都在内存中，保存备份时它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中，一锅端</li></ul><h4 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h4><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li>Save：在主程序中执行会阻塞当前的Redis服务器，直到持久化工作完成。执行sava命令期间，Redis不能处理其他命令，线上禁止使用</li><li>BGSAVE（默认）：Redis会在后台异步进行快照操作，不阻塞快照的同时还可以响应客户端请求，该触发方式会fork一个子进程由子进程复制持久化过程</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>适合大规模的数据恢复</li><li>按照业务定时备份</li><li>对数据完整性和一致性要求不高</li><li>RDB文件在内存中的加载速度要比AOF快得多</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong></li><li>内存数据的全量同步，如果数据量太大会导致I&#x2F;O严重影响服务器性能</li><li>RDB依赖于主进程的fork，在更大的数据集中，这可能导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑</li></ul><h4 id="什么时候会触发RDB快照"><a href="#什么时候会触发RDB快照" class="headerlink" title="什么时候会触发RDB快照"></a>什么时候会触发RDB快照</h4><ul><li>配置文件中默认的快照配置</li><li>手动sava&#x2F;bgsave命令</li><li>执行flushall&#x2F;flushdb命令也会产生dump.rdb文件，但是里面是空的，无意义</li><li>执行shutdown且没有设置开启AOF持久化</li><li>主从复制时，主节点自动触发</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604235839606.png" alt="image-20230604235839606"></p><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><ul><li>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li><li>默认情况下，redis是没有开启AOF的。开启AOF功能需要设置配置：appendonly yes</li><li>AOF保存的是appendonly.aof文件</li></ul><h4 id="AOF持久化工作流程"><a href="#AOF持久化工作流程" class="headerlink" title="AOF持久化工作流程"></a>AOF持久化工作流程</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605001309817.png" alt="image-20230605001309817"></p><h4 id="AOF缓冲区三种写回策略"><a href="#AOF缓冲区三种写回策略" class="headerlink" title="AOF缓冲区三种写回策略"></a>AOF缓冲区三种写回策略</h4><ul><li>Always:同步写回，每个写命令执行完立刻同步的将日志写回磁盘</li><li>everysec：每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓存区中的内容写入磁盘</li><li>no:操作系统控制的写回，每个写命令执行完，只是先把日志文件写到AOF文件的内存缓存区，由操作系统决定何时将缓冲区内容写回到磁盘</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605185533896.png" alt="image-20230605185533896"></p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>更好的保护数据不丢失、性能高、可做紧急恢复</p><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul><li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li><li>aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li></ul><h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><ul><li>由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。</li><li>为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的峰值时，Redis就会<strong>自动</strong>启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集或者可以手动使用命令 bgrewriteaof 来重新。</li></ul><h5 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h5><ol><li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li><li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</li><li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li><li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中</li><li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li></ol><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605190311924.png" alt="image-20230605190311924"></p><h3 id="RDB-AOF混合持久化"><a href="#RDB-AOF混合持久化" class="headerlink" title="RDB+AOF混合持久化"></a>RDB+AOF混合持久化</h3><p>结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。</p><h4 id="开启混合方式设置"><a href="#开启混合方式设置" class="headerlink" title="开启混合方式设置"></a>开启混合方式设置</h4><p>设置aof-use-rdb-preamble的值为 yes  yes表示开启，设置为no表示禁用</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>RDB镜像做全量持久化，AOF做增量持久化</strong></p><p>先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。**—-》AOF包括了RDB头部+AOF混写**</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>可以一次性执行多个命令，本质是一组命令的集合。一个事务的所有命令都会被序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞</p><h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>一个队列中，一次性、顺序性、排他性地执行一系列命令</p><h3 id="Redis事务VS数据量事务"><a href="#Redis事务VS数据量事务" class="headerlink" title="Redis事务VS数据量事务"></a>Redis事务VS数据量事务</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605191245403.png" alt="image-20230605191245403"></p><h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605191354653.png" alt="image-20230605191354653"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li>开启：以multi开始一个事务</li><li>入队：将多个命令入队到事务中，接到这些命令不会立刻执行，而是放到等待执行地事务队列里面</li><li>执行：由exec命令触发事务</li></ul><h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>由一个面试题引出管道</p><p><strong>如何优化频繁命令往返造成地性能瓶颈？</strong></p><p>Redis是一种基于客户端-服务端模型以及请求&#x2F;响应协议的TCP服务。一个请求会遵循以下步骤：</p><ol><li>客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。</li><li>服务端处理命令，并将结果返回给客户端。</li></ol><p><strong>上述两步称为：Round Trip Time(简称RTT,数据包往返于两端的时间)</strong></p><p>如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好</p><h3 id="解决思路（使用管道）"><a href="#解决思路（使用管道）" class="headerlink" title="解决思路（使用管道）"></a>解决思路（使用管道）</h3><p>管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605205315616.png" alt="image-20230605205315616"></p><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><h4 id="Pipeline与原生批量命令对比"><a href="#Pipeline与原生批量命令对比" class="headerlink" title="Pipeline与原生批量命令对比"></a>Pipeline与原生批量命令对比</h4><ul><li>原生批量命令是原子性（例如：mset，mget），pipeline是非原子性</li><li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令</li><li>原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成</li></ul><h4 id="Pipeline与事务对比"><a href="#Pipeline与事务对比" class="headerlink" title="Pipeline与事务对比"></a>Pipeline与事务对比</h4><ul><li>事务具有原子性，管道不具有原子性</li><li>管道一次性将多条命令发送到服务器，事务是一条一条地发，事务只有在接收到exec命令之后才会执行，管道不会</li><li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会</li></ul><h4 id="使用Pipeline注意事项"><a href="#使用Pipeline注意事项" class="headerlink" title="使用Pipeline注意事项"></a>使用Pipeline注意事项</h4><ul><li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中发生异常，将会继续执行后续的指令</li><li>使用pipeline组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存</li></ul><h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种消息通信模式：发送者（PUBLISH）发送消息，订阅者（SUBSCRIBE）接受消息，可以实现进程间的消息传递</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>发布的消息在Redis系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃。</li><li>消息只管发送，对于发布者而言消息是即发即失的，不管接受，也没有ACK机制，无法保证消息的消费成功</li><li>以上缺点导致Redis的Pub&#x2F;Sub模式就像个小玩具，在生产环境中无用武之地，为此Redis5.0版本新增了Stream数据结构，不但支持多播，还支持数据持久化，相比Pub&#x2F;Sub更加的强大</li></ul><h2 id="Redis复制（replica）"><a href="#Redis复制（replica）" class="headerlink" title="Redis复制（replica）"></a>Redis复制（replica）</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p>就是主从复制，master以写为主，Slave以读为主。当master数据变化的时候，自动将新的数据异步同步到其他slave数据库</p><h3 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>读写分离</li><li>容灾恢复</li><li>数据备份</li><li>水平扩容支持高并发</li></ul><h3 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a>怎么玩</h3><p><strong>配从（库）不配主（库）</strong></p><p><strong>权限细节-重要</strong>：</p><p>master如果配置了requirepass参数，需要密码登录，那么slave就要配置masterauth来设置校验密码，否则的话master就会拒绝slave的访问请求</p><p><strong>基本操作命令</strong></p><ul><li><p>info replication:可以查看复制节点的主从关系和配置信息</p></li><li><p>replicaof 主库IP 主库端口（一般写入redis.conf配置文件内）</p></li><li><p>slaveof 主库IP 主库端口</p><ul><li>每次与master断开之后，都需要重写连接，除非你配置进redis.conf文件</li><li>在运行期间修改slave节点的信息，如果该数据库已经是某个朱主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，重新拜码头</li></ul></li><li><p>slaveof no one：使当前数据库停止与其他数据库的同步，转为主数据库，自立为王</p></li></ul><h3 id="复制原理和工作流程"><a href="#复制原理和工作流程" class="headerlink" title="复制原理和工作流程"></a>复制原理和工作流程</h3><ul><li><p>slave启动，同步初请</p><ul><li>slave启动成功连接到master后会发送一个sync命令</li><li>slave首次全新连接master，一次完全同步（全量复制）将自动执行，slave自身原有的数据会被master数据覆盖清除</li></ul></li><li><p>首次连接，全量复制</p><ul><li>master节点受到sync命令后开始在后台保存快照（即RDB持久化，主从复制时会触发RDB），同时收集所有接受到的用于修改数据集命令缓存起来，master节点执行RDB持久化完后，master将rdb快照文件和所有缓存的命令发送到所有slave，以完成一次完全同步</li><li>而slave服务在接受到数据库文件数据后，将其存盘并加载到内存中，从而完成复制初始化</li></ul></li><li><p>心跳持续，保持通信：repl-ping-replica-period 10（配置文件）</p></li><li><p>进入平稳，增量复制：master继续将新的所有收集到的修改命令自动依次传给slave，完成同步</p></li><li><p>从机下线，重连续传：master会检查backlog里面的offset，master和slave都会保存一个复制的offset还有一个masterId，offset是保存在backlog中的。master智慧把已经复制的offset后面的数据复制给slave，类似于断点续传</p></li></ul><h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><ul><li>复制延迟，信号衰减：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li><li>master挂了如何办?:默认情况下，不会再slave节点中自动重选一个master</li></ul><h2 id="Redis哨兵（sentinel）"><a href="#Redis哨兵（sentinel）" class="headerlink" title="Redis哨兵（sentinel）"></a>Redis哨兵（sentinel）</h2><h3 id="是什么-5"><a href="#是什么-5" class="headerlink" title="是什么"></a>是什么</h3><ul><li>吹哨人巡查监控后台master主机是否故障，如果故障了根据<strong>投票数</strong>自动将某一个从库转化为新主库，继续对外服务</li><li>哨兵的作用<ul><li>监控redis运行状态，包括master和slave</li><li>当master down机，能自动将slave切换成新master</li></ul></li></ul><h3 id="能干嘛-3"><a href="#能干嘛-3" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>主从监控：监控主从redis库是否正常</li><li>消息通知：哨兵可以将故障转移的结果发送给客户端</li><li>故障转移：如果master异常，则会进行主从切换，将其中一个slave作为新master</li><li>配置中心：客户端通过连接哨兵来获得当前Redis服务的主节点地址</li></ul><h3 id="怎么玩-2"><a href="#怎么玩-2" class="headerlink" title="怎么玩"></a>怎么玩</h3><ul><li>3个哨兵：自动监控和维护集群，不存放数据，只是吹哨人</li><li>1主2从：用于数据读取和存放</li></ul><h3 id="哨兵运行流程和选举流程"><a href="#哨兵运行流程和选举流程" class="headerlink" title="哨兵运行流程和选举流程"></a>哨兵运行流程和选举流程</h3><p>当一个主从配置中的master失效之后，sentinel可以选举出一个新的master用于自动接替原master的工作，主从配置中的其他Redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换</p><p><strong>运行流程，故障切换</strong></p><ul><li><p>三个哨兵监控一主二从，正常运行中</p></li><li><p>SDown主观下线（Subjectively Down）：所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。主观下线就是说如果服务器在[sentinel down-after-milliseconds]给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了</p></li><li><p>ODown客观下线（Objectively Down）：<img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606014519549.png" alt="image-20230606014519549"></p></li><li><p>选举出领导者哨兵（哨兵中选出兵王）：当主节点被判断客观下线以后，各个哨兵节点会进行协商，先选举出一个<strong>领导哨兵节点（兵王）</strong>并由该领导者节点，也即被选举出的兵王进行failover（故障迁移）</p><ul><li>哨兵领导者如何选出来的？Raft算法：监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路<strong>是先到先得</strong>：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者</li></ul></li><li><p>由兵王开始推动故障切换流程并选出一个新master</p><ul><li>新主登基</li><li>群臣俯首</li><li>旧主拜服</li></ul></li></ul><p>上述的failover流程操作均由sentinel自己独立完成，完全无需人工干预</p><h3 id="哨兵的使用建议"><a href="#哨兵的使用建议" class="headerlink" title="哨兵的使用建议"></a>哨兵的使用建议</h3><ul><li>哨兵节点的数量应为多个，哨兵本身应该为集群，保证高可用</li><li>哨兵节点的数量应该是奇数</li><li>各个哨兵节点的配置应一致</li><li>如果哨兵节点部署在Docker等容器里面，尤其要注意端口的正确映射</li><li>哨兵集群+主从复制，<strong>并不能保证数据零丢失</strong>（承上启下引出集群）</li></ul><h2 id="Redis集群（cluster）"><a href="#Redis集群（cluster）" class="headerlink" title="Redis集群（cluster）"></a>Redis集群（cluster）</h2><h3 id="是什么-6"><a href="#是什么-6" class="headerlink" title="是什么"></a>是什么</h3><ul><li><p><strong>由于数据量过大</strong>，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。</p></li><li><p>Redis集群是一个提供在多个Redis节点间共享数据的程序集</p></li><li><p>Redis集群可以支持多个master</p></li></ul><h3 id="能干嘛-4"><a href="#能干嘛-4" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li><p>Redis集群支持多个Master，每个Master又可以挂载多个Slave</p><ul><li>读写分离</li><li>支持数据的高可用</li><li>支持海量数据的读写存储操作</li></ul></li><li><p>由于Cluster自带Sentinel的故障迁移机制，内置了高可用的支持，无需再去使用哨兵功能</p></li><li><p>客户端与Redis的节点连接，不再需要连接集群中的所有的节点，只需要任意连接集群中的一个可用节点即可</p></li><li><p>槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</p></li></ul><h3 id="集群算法-分片-槽位slot"><a href="#集群算法-分片-槽位slot" class="headerlink" title="集群算法-分片-槽位slot"></a>集群算法-分片-槽位slot</h3><h4 id="redis集群的槽位slot"><a href="#redis集群的槽位slot" class="headerlink" title="redis集群的槽位slot"></a>redis集群的槽位slot</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191650387.png" alt="image-20230606191650387"></p><h4 id="redis集群的分类"><a href="#redis集群的分类" class="headerlink" title="redis集群的分类"></a>redis集群的分类</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191758578.png" alt="image-20230606191758578"></p><h4 id="它俩的优势"><a href="#它俩的优势" class="headerlink" title="它俩的优势"></a>它俩的优势</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191915673.png" alt="image-20230606191915673"></p><h4 id="slot槽位映射，一般业界有3种解决方案"><a href="#slot槽位映射，一般业界有3种解决方案" class="headerlink" title="slot槽位映射，一般业界有3种解决方案"></a>slot槽位映射，一般业界有3种解决方案</h4><h5 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h5><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606192717947.png" alt="image-20230606192717947"></p><h5 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h5><p><strong>三大步骤：</strong></p><ul><li><p>算法构建一致性哈希环</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193610219.png" alt="image-20230606193610219"></p></li><li><p>redis服务器IP节点映射</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193652277.png" alt="image-20230606193652277"></p></li><li><p>key落到服务器的落键规则</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193723898.png" alt="image-20230606193723898"></p></li></ul><p><strong>优点</strong></p><ul><li><p>一致性哈希算法的<strong>容错性</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194015649.png" alt="image-20230606194015649"></p></li><li><p>一致性哈希算法的<strong>扩展性</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194040349.png" alt="image-20230606194040349"></p></li></ul><p><strong>缺点</strong></p><p>一致性哈希算法的<strong>数据倾斜</strong>的问题</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194127978.png" alt="image-20230606194127978"></p><h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194409589.png" alt="image-20230606194409589"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194444099.png" alt="image-20230606194444099"></p><h4 id="经典面试题：为什么redis集群的最大槽数是16384个"><a href="#经典面试题：为什么redis集群的最大槽数是16384个" class="headerlink" title="经典面试题：为什么redis集群的最大槽数是16384个?"></a>经典面试题：为什么redis集群的最大槽数是16384个?</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606200937900.png" alt="image-20230606200937900"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213142693.png" alt="image-20230606213142693"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213156235.png" alt="image-20230606213156235"></p><h4 id="redis集群不保证强一致性"><a href="#redis集群不保证强一致性" class="headerlink" title="redis集群不保证强一致性"></a>redis集群不保证强一致性</h4><p>意味着在特定的条件下，redis集群可能会丢掉一些被系统收到的写入请求命令</p><h3 id="集群常用操作命令和CRC16算法分析"><a href="#集群常用操作命令和CRC16算法分析" class="headerlink" title="集群常用操作命令和CRC16算法分析"></a>集群常用操作命令和CRC16算法分析</h3><ul><li><p>不在同一slot槽位下的多键操作支持不好，通识占位符登场</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213612595.png" alt="image-20230606213612595"></p></li><li><p>Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽</p></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><p>cluster-require-full-coverage：集群是否完整才能对外提供服务</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213817703.png" alt="image-20230606213817703"></p></li><li><p>cluster countkeysinslot 槽位数字编号：1，该槽位被占用，0，该槽位没有被占用</p></li><li><p>cluster keyslot 键名称：该键应该存在哪个槽位上</p></li></ul><h2 id="SpringBoot集成Redis"><a href="#SpringBoot集成Redis" class="headerlink" title="SpringBoot集成Redis"></a>SpringBoot集成Redis</h2><h3 id="集成Jedis"><a href="#集成Jedis" class="headerlink" title="集成Jedis"></a>集成Jedis</h3><h3 id="集成lettuce"><a href="#集成lettuce" class="headerlink" title="集成lettuce"></a>集成lettuce</h3><h3 id="集成RedisTemplate-推荐使用"><a href="#集成RedisTemplate-推荐使用" class="headerlink" title="集成RedisTemplate-推荐使用"></a>集成RedisTemplate-推荐使用</h3><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>上面的都是自己通过学习Redis网课的时候整理的Redis的基本知识，后续也会更新Redis的高级部分。如有不足和错误的地方请联系小编来改正。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arrays.asList()避坑指南</title>
      <link href="/2023/07/20/Arrays-asList-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"/>
      <url>/2023/07/20/Arrays-asList-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近使⽤ <code>Arrays.asList()</code> 遇到了⼀些坑。所以，⾃⼰对于这块⼩知识点进⾏了简单的总结。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Arrays.asList()</code> 在平时开发中还是⽐较常⻅的，我们可以使⽤它将⼀个数组转换为⼀个 List 集 合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;；</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上⾯两个语句等价于下⾯⼀条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure><p>JDK 源码对于这个⽅法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*返回由指定数组⽀持的固定⼤⼩的列表。此⽅法作为基于数组和基于集合的API之间的桥梁，与 Collection.toArray()结合使⽤。返回的List是可序列化并实现RandomAccess接⼝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="《阿⾥巴巴-Java-开发⼿册》对其的描述"><a href="#《阿⾥巴巴-Java-开发⼿册》对其的描述" class="headerlink" title="《阿⾥巴巴 Java 开发⼿册》对其的描述"></a>《阿⾥巴巴 Java 开发⼿册》对其的描述</h2><p><code>Arrays.asList()</code> 将数组转换为集合后,底层其实还是数组，《阿⾥巴巴 Java 开发⼿册》对于这个 ⽅法有如下描述：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809144507650.png" alt="image-20230809144507650"></p><h2 id="使⽤时的注意事项总结"><a href="#使⽤时的注意事项总结" class="headerlink" title="使⽤时的注意事项总结"></a>使⽤时的注意事项总结</h2><p><strong>传递的数组必须是对象数组，⽽不是基本类型。</strong></p><p><strong>Arrays.asList() 是泛型⽅法，传⼊的对象必须是对象数组。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span> [] array=(<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当传⼊⼀个原⽣数据类型数组时， Arrays.asList() 的真正得到的参数就不是数组中的元素，⽽是 数组对象本身！此时 List 的唯⼀元素就是这个数组，这也就解释了上⾯的代码。</p><p>使⽤集合的修改⽅法: add() 、 remove() 、 clear() 会抛出异常:<code>UnsupportedOperationException</code></p><p>Arrays.asList() ⽅法返回的并不是 java.util.ArrayList ，⽽是 java.util.Arrays 的 ⼀个内部类,这个内部类并没有实现集合的修改⽅法或者说并没有重写这些⽅法。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次关于Arrays.asList的一些坑就讲到这里了，大部分是通过网上学习才知道的，如有错误和不足请联系小编改正。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的七种遍历方式与性能分析</title>
      <link href="/2023/07/09/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2023/07/09/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 JDK 1.8 Streams API 的发布，使得 HashMap 拥有了更多的遍历的方式。</p><h2 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h2><p>HashMap遍历从大的方向来说，可以分为四类：</p><blockquote><ul><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）；</li><li>Streams API 遍历（JDK 1.8+）；</li></ul></blockquote><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><blockquote><ul><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ul></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1-迭代器-EntrySet"><a href="#1-迭代器-EntrySet" class="headerlink" title="1.迭代器 EntrySet"></a>1.迭代器 EntrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-迭代器KeySet"><a href="#2-迭代器KeySet" class="headerlink" title="2.迭代器KeySet"></a>2.迭代器KeySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ForEach-EntrySet"><a href="#3-ForEach-EntrySet" class="headerlink" title="3.ForEach EntrySet"></a>3.ForEach EntrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-ForEach-KeySet"><a href="#4-ForEach-KeySet" class="headerlink" title="4.ForEach KeySet"></a>4.ForEach KeySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Lambda"><a href="#5-Lambda" class="headerlink" title="5.Lambda"></a>5.Lambda</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Streams-API-单线程"><a href="#6-Streams-API-单线程" class="headerlink" title="6.Streams API 单线程"></a>6.Streams API 单线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Streams-API-多线程"><a href="#7-Streams-API-多线程" class="headerlink" title="7.Streams API 多线程"></a>7.Streams API 多线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>接下来我们使用 Oracle 官方提供的性能测试工具 JMH（Java Microbenchmark Harness，JAVA 微基准测试套件）来测试一下这 7 种循环的性能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后编写测试代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.Throughput)</span> <span class="comment">// 测试类型：吞吐量</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 预热 2 轮，每次 1s</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 测试 5 轮，每次 3s</span></span><br><span class="line"><span class="meta">@Fork(1)</span> <span class="comment">// fork 1 个线程</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 每个测试线程一个实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapCycle</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>() &#123;&#123;</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            put(i, <span class="string">&quot;val:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="comment">// 启动基准测试</span></span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(HashMapCycle.class.getSimpleName()) <span class="comment">// 要导入的测试类</span></span><br><span class="line">                .output(<span class="string">&quot;/Users/admin/Desktop/jmh-map.log&quot;</span>) <span class="comment">// 输出测试结果的文件</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run(); <span class="comment">// 执行测试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 单线程遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 多线程遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有被添加了 <code>@Benchmark</code> 注解的方法都会被测试，测试结果如下：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/640.png" alt="640"></p><p>其中 Score 列表示平均执行时间， <code>±</code> 符号表示误差。从以上结果可以看出，<strong>如果加上后面的误差值的话，可以得出的结论是，除了并行循环的 <code>parallelStream</code> 性能比极高之外（多线程方式性能肯定比较高），其他方式的遍历方法在性能方面几乎没有任何差别。</strong></p><h2 id="性能原理分析"><a href="#性能原理分析" class="headerlink" title="性能原理分析"></a>性能原理分析</h2><p>要理解性能测试的结果，我们需要把所有遍历代码通过 <code>javac</code>，编译成字节码来看具体的原因，编译之后我们使用 Idea 打开字节码信息，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="number">0</span>; var1 &lt; <span class="number">2</span>; ++var1) &#123;</span><br><span class="line">                <span class="built_in">this</span>.put(var1, <span class="string">&quot;val:&quot;</span> + var1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMapTest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">        entrySet();</span><br><span class="line">        keySet();</span><br><span class="line">        forEachEntrySet();</span><br><span class="line">        forEachKeySet();</span><br><span class="line">        lambda();</span><br><span class="line">        streamApi();</span><br><span class="line">        parallelStreamApi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">        map.forEach((var0, var1) -&gt; &#123;</span><br><span class="line">            System.out.println(var0);</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">streamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        map.entrySet().stream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallelStreamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        map.entrySet().parallelStream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，除了 Lambda 和 Streams API 之外，通过迭代器循环和 <code>for</code> 循环的遍历的 <code>EntrySet</code> 最终生成的代码是一样的，他们都是在循环中创建了一个遍历对象 <code>Entry</code> ，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而通过迭代器和 <code>for</code> 循环遍历的 <code>KeySet</code> 代码也是一样的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>KeySet</code> 在循环中创建了一个 <code>Integer</code> 的局部变量，并且值是从 <code>map</code> 对象中直接获取的。</p><p><strong>所以通过字节码来看，使用 <code>EntrySet</code> 和 <code>KeySet</code> 代码差别不是很大，并不像网上说的那样 <code>KeySet</code> 的性能远不如 <code>EntrySet</code>，因此从性能的角度来说 <code>EntrySet</code> 和 <code>KeySet</code> 几乎是相近的，但从代码的优雅型和可读性来说，还是推荐使用 <code>EntrySet</code>。</strong></p><h2 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h2><h3 id="1-迭代器方式"><a href="#1-迭代器方式" class="headerlink" title="1.迭代器方式"></a>1.迭代器方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show:<span class="number">0</span></span><br><span class="line">del:<span class="number">1</span></span><br><span class="line">show:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>测试结果：<strong>迭代器中循环删除数据安全</strong>。</p><h3 id="2-For-循环方式"><a href="#2-For-循环方式" class="headerlink" title="2.For 循环方式"></a>2.For 循环方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/641.png" alt="641"></p><p>测试结果：<strong>For 循环中删除数据非安全</strong>。</p><h3 id="3-Lambda-方式"><a href="#3-Lambda-方式" class="headerlink" title="3.Lambda 方式"></a>3.Lambda 方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + key);</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/642.png" alt="642"></p><p>测试结果：<strong>Lambda 循环中删除数据非安全</strong>。</p><p><strong>Lambda 删除的正确方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 map 中的 key 去判断删除</span></span><br><span class="line">map.keySet().removeIf(key -&gt; key == <span class="number">1</span>);</span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，可以先使用 <code>Lambda</code> 的 <code>removeIf</code> 删除多余的数据，再进行循环是一种正确操作集合的方式。</p><h3 id="4-Stream-方式"><a href="#4-Stream-方式" class="headerlink" title="4.Stream 方式"></a>4.Stream 方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/643.png" alt="643"></p><p>测试结果：<strong>Stream 循环中删除数据非安全</strong>。</p><p><strong>Stream 循环的正确方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().filter(m -&gt; <span class="number">1</span> != m.getKey()).forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，可以使用 <code>Stream</code> 中的 <code>filter</code> 过滤掉无用的数据，再进行遍历也是一种安全的操作集合的方式。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们不能在遍历中使用集合 <code>map.remove()</code> 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <code>iterator.remove()</code> 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>阿⾥巴巴⼿册相关的规定：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809113202544.png" alt="image-20230809113202544"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>部分内容转载自<a href="https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow">Java中文社群</a>,如有侵权，请立刻联系我，进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之享元模式</title>
      <link href="/2023/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li><li>享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</li></ul><h2 id="享元模式原理类图"><a href="#享元模式原理类图" class="headerlink" title="享元模式原理类图"></a>享元模式原理类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230430120243213.png" alt="image-20230430120243213" style="zoom:67%;"><p>说明：</p><ul><li><code>FlyWeigh</code> 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态的接口或实现</li><li><code> ConcreteFlyWeight</code> 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li><li><code>UnSharedConcreteFlyWeight</code> 是不可共享的角色，一般不会出现在享元工厂。</li><li><code>FlyWeightFactory</code> 享元工厂类，用于构建一个池容器(集合)， 同时提供从池中获取对象方法</li></ul><p>上面提到了一个外部状态和内部状态，那么什么是外部状态和内部状态呢？</p><ul><li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态</li><li><strong>内部状态</strong>指对象共享出来的信息，<strong>存储在享元对象内部且不会随环境的改变而改变</strong></li><li><strong>外部状态指对象得以依赖的一个标记</strong>，是<strong>随环境改变而改变的、不可共享的状态</strong>。</li></ul><blockquote><p>举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p></blockquote><h2 id="享元模式的应用示例"><a href="#享元模式的应用示例" class="headerlink" title="享元模式的应用示例"></a>享元模式的应用示例</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230430120652648.png" alt="image-20230430120652648" style="zoom:67%;"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>抽象享元角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-30 12:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象的享元角色</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的享元角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-30 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 具体的享元角色</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title class_">WebSite</span>&#123;</span><br><span class="line">    <span class="comment">//共享的部分，内部状态</span></span><br><span class="line">    <span class="keyword">private</span> String type=<span class="string">&quot;&quot;</span>;<span class="comment">//网站的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteWebSite</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;网站的类型为:&quot;</span>+type+<span class="string">&quot;，使用者是：&quot;</span>+user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>享元工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-30 12:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 网站工厂类。根据需求返回一个网站</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteFactory</span> &#123;</span><br><span class="line">    <span class="comment">//相当于一个池</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,ConcreteWebSite&gt; pool=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> WebSite <span class="title function_">getWebSiteCategory</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pool.containsKey(type))&#123;</span><br><span class="line">            <span class="comment">//创建一个网站，放到池中</span></span><br><span class="line">            pool.put(type,<span class="keyword">new</span> <span class="title class_">ConcreteWebSite</span>(type));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWebSiteCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个工厂类</span></span><br><span class="line">        <span class="type">WebSiteFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSiteFactory</span>();</span><br><span class="line">        <span class="comment">// 客户要一个以新闻形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite1</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);</span><br><span class="line">        webSite1.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite2</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite2.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">        <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite3</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite3.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;smith&quot;</span>));</span><br><span class="line">        <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite4</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite4.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;king&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;网站的分类共=&quot;</span> + factory.getWebSiteCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式的注意事项和细节"><a href="#享元模式的注意事项和细节" class="headerlink" title="享元模式的注意事项和细节"></a>享元模式的注意事项和细节</h2><ul><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 <code>HashMap/HashTable</code> 存储</li><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li><li>享元模式提高了<strong>系统的复杂度</strong>。需要分离出<strong>内部状态和外部状态</strong>，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.</li><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。</li><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之组合模式</title>
      <link href="/2023/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="学校院系展示需求"><a href="#学校院系展示需求" class="headerlink" title="学校院系展示需求"></a>学校院系展示需求</h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230424112820067.png" alt="image-20230424112820067" style="zoom:67%;"><h2 id="传统方式解决"><a href="#传统方式解决" class="headerlink" title="传统方式解决"></a>传统方式解决</h2><p>系继承学院，学院继承学校</p><h2 id="传统方式的问题分析"><a href="#传统方式的问题分析" class="headerlink" title="传统方式的问题分析"></a>传统方式的问题分析</h2><blockquote><ul><li>将<strong>学院看做是学校的子类</strong>，<strong>系是学院的子类</strong>，这样实际上是站在组织大小来进行分层次的</li><li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，<strong>不能很好实现的管理的操作</strong>，比如对学院、系的<strong>添加，删除，遍历</strong>等</li><li>解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 &#x3D;&gt; <strong>组合</strong>模式</li></ul></blockquote><h2 id="组合方式基本介绍"><a href="#组合方式基本介绍" class="headerlink" title="组合方式基本介绍"></a>组合方式基本介绍</h2><blockquote><ul><li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示<strong>整体</strong>-<strong>部分</strong>的层次关系。</li><li>组合模式<strong>依据树形结构来组合对象</strong>，用来表示部分以及整体层次。</li><li>这种类型的设计模式属于结构型模式。</li><li>组合模式使得<strong>用户对单个对象和组合对象的访问具有一致性</strong>，即：组合能让客户以一致的方式处理个别对象以及组合对象</li></ul></blockquote><h2 id="组合模式类图分析"><a href="#组合模式类图分析" class="headerlink" title="组合模式类图分析"></a>组合模式类图分析</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/1.webp" alt="1"></p><ul><li><p><strong>Component</strong> :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口</p></li><li><p><strong>Leaf :</strong> 在组合中表示叶子节点，叶子节点没有子节点</p></li><li><p><strong>Composite</strong> :非叶子节点， 用于存储子部件， 在 Component  接口中实现 子部件的相关操作，比如增加(add),删除</p></li></ul><h2 id="组合模式解决学校院系展示"><a href="#组合模式解决学校院系展示" class="headerlink" title="组合模式解决学校院系展示"></a>组合模式解决学校院系展示</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230424111954059.png" alt="image-20230424111954059" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Component</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrganizationComponent</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">University</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span>&#123;</span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">University</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写add</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写remove</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: College 就是 Composite , 可以管理Department</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">College</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List 中 存放的Department</span></span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">College</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写add</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写remove</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 叶子节点</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">university</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">University</span>(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot; 中国顶级大学 &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 学院</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">computerCollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot; 计算机学院 &quot;</span>);</span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">infoEngineercollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;信息工程学院&quot;</span>, <span class="string">&quot; 信息工程学院 &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot; 软件工程不错 &quot;</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;网络工程&quot;</span>, <span class="string">&quot; 网络工程不错 &quot;</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;计算机科学与技术&quot;</span>, <span class="string">&quot; 计算机科学与技术是老牌的专业 &quot;</span>));</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;通信工程&quot;</span>, <span class="string">&quot; 通信工程不好学 &quot;</span>));</span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;信息工程&quot;</span>, <span class="string">&quot; 信息工程好学 &quot;</span>));</span><br><span class="line">        <span class="comment">//将学院加入到 学校</span></span><br><span class="line">        university.add(computerCollege);</span><br><span class="line">        university.add(infoEngineercollege);</span><br><span class="line">        university.print();</span><br><span class="line"><span class="comment">/*        infoEngineercollege.print();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式的注意事项和细节"><a href="#组合模式的注意事项和细节" class="headerlink" title="组合模式的注意事项和细节"></a>组合模式的注意事项和细节</h2><ul><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构</li><li>需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.</li><li>要求较高的抽象性，如果<strong>节点和叶子有很多差异性的话</strong>，比如很多方法和属性都不一样<strong>，不适合使用组合模</strong>式</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之组合模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计者模式之装饰者模式</title>
      <link href="/2023/05/11/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/11/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="星巴克咖啡订单项目"><a href="#星巴克咖啡订单项目" class="headerlink" title="星巴克咖啡订单项目"></a>星巴克咖啡订单项目</h2><blockquote><ul><li>咖啡种类&#x2F;单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</li><li>调料：Milk、Soy(豆浆)、Chocolate</li><li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li><li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li></ul></blockquote><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423232927807.png" alt="image-20230423232927807" style="zoom:67%;"><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><ul><li>Drink 是一个抽象类，表示饮料</li><li>des 就是对咖啡的描述, 比如咖啡的名字</li><li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li><li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost</li><li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li><li>问题：<strong>这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸</strong></li></ul></blockquote><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)：</p><h3 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233054151.png" alt="image-20230423233054151" style="zoom:67%;"><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><ul><li>方案 2 可以控制类的数量，不至于造成很多的类</li><li>在增加或者删除调料种类时，代码的维护量很大</li><li>考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int</li><li>考虑使用 <strong>装饰者</strong> 模式</li></ul></blockquote><h2 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h2><ul><li>装饰者模式：<strong>动态的将新功能附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，<strong>装饰者模式也体现了开闭原则(ocp)</strong></li><li>这里提到的动态的将新功能附加到对象和 ocp 原则</li></ul><h2 id="装饰者模式原理"><a href="#装饰者模式原理" class="headerlink" title="装饰者模式原理"></a>装饰者模式原理</h2><ul><li><p>装饰者模式就像打包一个快递</p><ul><li>主体：比如：陶瓷、衣服 (Component) &#x2F;&#x2F; 被装饰者</li><li>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)</li></ul></li><li><p>Component 主体：比如类似前面的 Drink</p></li><li><p>ConcreteComponent 和 Decorator ConcreteComponent：具体的主体， 比如前面的各个单品咖啡</p></li><li><p>Decorator: 装饰者，比如各调料.</p></li></ul><p>在如图的 Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233503512.png" alt="image-20230423233503512" style="zoom:67%;"><h2 id="装饰者模式解决星巴克咖啡订单"><a href="#装饰者模式解决星巴克咖啡订单" class="headerlink" title="装饰者模式解决星巴克咖啡订单"></a>装饰者模式解决星巴克咖啡订单</h2><h3 id="类图分析-2"><a href="#类图分析-2" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233557793.png" alt="image-20230423233557793" style="zoom:67%;"><h3 id="装饰者模式下的订单：2-份巧克力-一份牛奶的-LongBlack"><a href="#装饰者模式下的订单：2-份巧克力-一份牛奶的-LongBlack" class="headerlink" title="装饰者模式下的订单：2 份巧克力+一份牛奶的 LongBlack"></a>装饰者模式下的订单：2 份巧克力+一份牛奶的 LongBlack</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233642302.png" alt="image-20230423233642302" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String des; <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算费用的抽象方法</span></span><br><span class="line">    <span class="comment">//子类来实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Espresso</span><span class="params">()</span>&#123;</span><br><span class="line">        setDes(<span class="string">&quot;意大利咖啡&quot;</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Drink obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// getPrice 自己价格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line">        <span class="keyword">return</span> des + <span class="string">&quot; &quot;</span> + getPrice() + <span class="string">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Drink obj)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(obj);</span><br><span class="line">        setDes(<span class="string">&quot; 牛奶 &quot;</span>);</span><br><span class="line">        setPrice(<span class="number">2.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Drink</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;费用1=&quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;描述=&quot;</span> + order.getDes());</span><br><span class="line">        <span class="comment">// 2. order 加入一份牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> <span class="title class_">Milk</span>(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之装饰者模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之适配器模式</title>
      <link href="/2023/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="生活中的适配器的例子"><a href="#生活中的适配器的例子" class="headerlink" title="生活中的适配器的例子"></a>生活中的适配器的例子</h2><p>充电器适配器</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423112011229.png" alt="image-20230423112011229"></p><h2 id="适配器模式的基本介绍"><a href="#适配器模式的基本介绍" class="headerlink" title="适配器模式的基本介绍"></a>适配器模式的基本介绍</h2><blockquote><ul><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，<strong>主的目的是兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于结构型模式</li><li>主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模式</strong></li></ul></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><blockquote><ul><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li></ul></blockquote><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423112201602.png" alt="image-20230423112201602" style="zoom: 67%;"><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><figcaption><span>类，通过继承 ```src(source)``` 类，实现 ```dst(destination,Target)``` 类接口，完成 src->dst 的适配。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> ### 应用实例</span><br><span class="line"></span><br><span class="line">以生活中充电器的例子，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电</span><br><span class="line"></span><br><span class="line">#### 类图分析</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423112524411.png&quot; alt=&quot;image-20230423112524411&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">#### 代码演示</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * @Author: abb</span><br><span class="line"> * @DateTime: 2023-04-23 11:27</span><br><span class="line"> * @Description: 被适配器的类</span><br><span class="line"> **/</span><br><span class="line">public class Voltage220V &#123;</span><br><span class="line">    //输出220V的电压</span><br><span class="line">    public int output220V() &#123;</span><br><span class="line">        int src = 220;</span><br><span class="line">        System.out.println(&quot;电压=&quot; + src + &quot;伏&quot;);</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 适配接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 适配器类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title class_">Voltage220V</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取到220V电压</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> output220V();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dstV</span> <span class="operator">=</span> srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 手机</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类适配器模式注意事项和细节"><a href="#类适配器模式注意事项和细节" class="headerlink" title="类适配器模式注意事项和细节"></a>类适配器模式注意事项和细节</h3><blockquote><ul><li>Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</li><li>src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。</li><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。</li></ul></blockquote><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote><ul><li>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</li><li>根据“<strong>合成复用原则</strong>”，在系统中尽量使用<strong>关联关系（聚合）来替代继承</strong>关系。</li><li>对象适配器模式是适配器模式常用的一种</li></ul></blockquote><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423113513517.png" alt="image-20230423113513517" style="zoom:67%;"><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 适配器类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.voltage220V = voltage220v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != voltage220V) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">            System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">            dst = src / <span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>(<span class="keyword">new</span> <span class="title class_">Voltage220V</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器模式的注意事项和细节"><a href="#对象适配器模式的注意事项和细节" class="headerlink" title="对象适配器模式的注意事项和细节"></a>对象适配器模式的注意事项和细节</h3><blockquote><ul><li><p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。</p></li><li><p>根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst必须是接口。</p></li><li><p>使用成本更低，更灵活。</p></li></ul></blockquote><h2 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote><ul><li>一些书籍称为：适配器模式(Default Adapter Pattern)或<strong>缺省适配器模式</strong>。</li><li>核心思路：当<strong>不需要全部实现接口提供的方法</strong>时，可先<strong>设计一个抽象类</strong>实现<strong>接口</strong>，并为该接口中每个方法提供一个<strong>默认实现（空方法）</strong>，那么该<strong>抽象类的子类可有选择地覆盖父类的某些方法</strong>来实现需求</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ul></blockquote><h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423122531343.png" alt="image-20230423122531343" style="zoom:67%;"><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 12:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 12:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 将Interface的所有方法默认实现</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsAdapter</span> <span class="keyword">implements</span> <span class="title class_">Interface4</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 12:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbsAdapter</span> <span class="variable">absAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbsAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;只实现了m1方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        absAdapter.m1();</span><br><span class="line">        absAdapter.m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式的注意事项和细节"><a href="#适配器模式的注意事项和细节" class="headerlink" title="适配器模式的注意事项和细节"></a>适配器模式的注意事项和细节</h2><blockquote><ul><li>三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。</li><li>类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承</li><li>对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现</li><li>Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。</li><li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li></ul></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之适配器模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之桥接模式</title>
      <link href="/2023/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="手机操作问题引入"><a href="#手机操作问题引入" class="headerlink" title="手机操作问题引入"></a>手机操作问题引入</h2><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423192633013.png" alt="image-20230423192633013" style="zoom:67%;"><h2 id="传统方式解决手机操作问题"><a href="#传统方式解决手机操作问题" class="headerlink" title="传统方式解决手机操作问题"></a>传统方式解决手机操作问题</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423192723970.png" alt="image-20230423192723970" style="zoom:67%;"><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><ul><li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li><li>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</li><li>解决方案-使用<strong>桥接模</strong>式</li></ul></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>桥接模式(Bridge 模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li><li>是一种结构型设计模式</li><li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li></ul><h3 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423192939779.png" alt="image-20230423192939779" style="zoom:67%;"><p>说明：</p><ul><li>Client 类：桥接模式的调用者</li><li>抽象类(Abstraction) :维护了 Implementor &#x2F; 即它的实现类 ConcreteImplementorA.., 二者是聚合关系, Abstraction充当桥接类</li><li>RefinedAbstraction : 是 Abstraction 抽象类的子类</li><li>mplementor : 行为实现类的接口</li><li>ConcreteImplementorA &#x2F;B ：行为的具体实现类</li><li>从 UML 图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li></ul><h2 id="桥接模式解决手机操作问题"><a href="#桥接模式解决手机操作问题" class="headerlink" title="桥接模式解决手机操作问题"></a>桥接模式解决手机操作问题</h2><h3 id="类图分析-2"><a href="#类图分析-2" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423193104591.png" alt="image-20230423193104591" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 品牌接口类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Vivo品牌手机</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vivo</span> <span class="keyword">implements</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; Vivo手机开机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; Vivo手机关机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; Vivo手机打电话 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 手机</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//将品牌加入到手机</span></span><br><span class="line">    <span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        brand.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        brand.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: //折叠式手机类，继承 抽象类 Phone</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoldedPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FoldedPhone</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">        System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.call();</span><br><span class="line">        System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FoldedPhone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">Vivo</span>());</span><br><span class="line">        phone.open();</span><br><span class="line">        phone.call();</span><br><span class="line">        phone.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式的注意事项和细节"><a href="#桥接模式的注意事项和细节" class="headerlink" title="桥接模式的注意事项和细节"></a>桥接模式的注意事项和细节</h2><ul><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li><li><strong>桥接模式替代多层继承方案</strong>，可以减少<strong>子类的个数</strong>，降低系统的管理和维护成本。</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.</li></ul><h2 id="常见的应用场景"><a href="#常见的应用场景" class="headerlink" title="常见的应用场景"></a>常见的应用场景</h2><ol><li><p>JDBC 驱动程序</p></li><li><p>银行转账系统</p><ul><li><p>转账分类: 网上转账，柜台转账，AMT 转账</p></li><li><p>转账用户类型：普通用户，银卡用户，金卡用户…</p></li></ul></li><li><p>消息管理</p><ul><li><p>消息类型：即时消息，延时消息</p></li><li><p>消息分类：手机短信，邮件消息，QQ 消息…</p></li></ul></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之桥接模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之建造者模式</title>
      <link href="/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="盖房项目需求"><a href="#盖房项目需求" class="headerlink" title="盖房项目需求"></a>盖房项目需求</h2><blockquote><ul><li>需要建房子：这一过程为打桩、砌墙、封顶</li><li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li></ul></blockquote><h2 id="传统方式解决盖房需求"><a href="#传统方式解决盖房需求" class="headerlink" title="传统方式解决盖房需求"></a>传统方式解决盖房需求</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423092004768.png" alt="image-20230423092004768" style="zoom: 80%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHouse</span> &#123;</span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWalls();</span><br><span class="line">        roofed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">AbstractHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子打地基 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子砌墙 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子封顶 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CommonHouse</span> <span class="variable">commonHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonHouse</span>();</span><br><span class="line">        commonHouse.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传统方式分析"><a href="#传统方式分析" class="headerlink" title="传统方式分析"></a>传统方式分析</h2><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。</li><li>解决方案：将产品和产品建造过程解耦 &#x3D;&gt;  <strong>建造者模式</strong>.</li></ul></blockquote><h2 id="建造者模式基本介绍"><a href="#建造者模式基本介绍" class="headerlink" title="建造者模式基本介绍"></a>建造者模式基本介绍</h2><blockquote><ul><li>建造者模式（<strong>Builder Pattern</strong>） 又叫<strong>生成器模式</strong>，是一种对象<strong>构建模式</strong>。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</li><li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。</li></ul></blockquote><h2 id="建造者模式的四个角色"><a href="#建造者模式的四个角色" class="headerlink" title="建造者模式的四个角色"></a>建造者模式的四个角色</h2><blockquote><ul><li><strong>Product（产品角色）</strong>： 一个具体的产品对象。</li><li><strong>Builder（抽象建造者）</strong>： 创建一个 Product 对象的各个部件指定的 <strong>接口&#x2F;抽象类</strong>。</li><li><strong>ConcreteBuilder（具体建造者）</strong>： 实现接口，构建和装配各个部件。</li><li><strong>Director（指挥者）</strong>： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ul></blockquote><h2 id="建造者模式原理类图"><a href="#建造者模式原理类图" class="headerlink" title="建造者模式原理类图"></a>建造者模式原理类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423092452561.png" alt="image-20230423092452561" style="zoom:67%;"><h2 id="建造者模式解决盖房需求应用实例"><a href="#建造者模式解决盖房需求应用实例" class="headerlink" title="建造者模式解决盖房需求应用实例"></a>建造者模式解决盖房需求应用实例</h2><h3 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423092532697.png" alt="image-20230423092532697" style="zoom:67%;"><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><p>product</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 产品-&gt;product</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBaise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBaise</span><span class="params">(String baise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWall</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWall</span><span class="params">(String wall)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoofed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roofed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoofed</span><span class="params">(String roofed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roofed = roofed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象的构造者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象的构造者</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将建造的流程写好, 抽象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子好， 将产品(房子) 返回</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通房子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通房子</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setBaise(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子打地基5米 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子砌墙10cm &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子屋顶 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指挥者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 指挥者，这里去指定制作流程，返回产品</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseDirector</span> &#123;</span><br><span class="line">    <span class="type">HouseBuilder</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器传入 houseBuilder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过setter 传入 houseBuilder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何处理建造房子的流程，交给指挥者</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">constructHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//盖普通房子</span></span><br><span class="line">        <span class="type">CommonHouse</span> <span class="variable">commonHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonHouse</span>();</span><br><span class="line">        <span class="comment">//准备创建房子的指挥者</span></span><br><span class="line">        <span class="type">HouseDirector</span> <span class="variable">houseDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>(commonHouse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成盖房子，返回产品(普通房子)</span></span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> houseDirector.constructHouse();</span><br><span class="line">        System.out.println(house.getBaise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式的注意事项和细节"><a href="#建造者模式的注意事项和细节" class="headerlink" title="建造者模式的注意事项和细节"></a>建造者模式的注意事项和细节</h2><ul><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li><li>抽象工厂模式 VS 建造者模式<ul><li>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</li></ul></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之建造者模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之原型模式</title>
      <link href="/2023/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="克隆羊问题"><a href="#克隆羊问题" class="headerlink" title="克隆羊问题"></a>克隆羊问题</h2><p>现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10只羊。</p><h2 id="传统方式解决克隆羊问题"><a href="#传统方式解决克隆羊问题" class="headerlink" title="传统方式解决克隆羊问题"></a>传统方式解决克隆羊问题</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230422234743493.png" alt="image-20230422234743493" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="comment">//传统的方法</span></span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor()); </span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">    </span><br><span class="line">    System.out.println(sheep); </span><br><span class="line">    System.out.println(sheep2); </span><br><span class="line">    System.out.println(sheep3); </span><br><span class="line">    System.out.println(sheep4);</span><br><span class="line">    System.out.println(sheep5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传统方式的优缺点"><a href="#传统方式的优缺点" class="headerlink" title="传统方式的优缺点"></a>传统方式的优缺点</h2><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li></ul></blockquote><h2 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h2><p><strong>思路</strong>：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的Java 类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 &#x3D;&gt;<strong>原型模式</strong></p><h2 id="原型模式基本介绍"><a href="#原型模式基本介绍" class="headerlink" title="原型模式基本介绍"></a>原型模式基本介绍</h2><blockquote><ul><li>原型模式(Prototype 模式)是指：用<strong>原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的</strong>对象</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 <strong>对象.clone()</strong></li><li>形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li></ul></blockquote><h2 id="原型模式原理结构图-uml-类图"><a href="#原型模式原理结构图-uml-类图" class="headerlink" title="原型模式原理结构图-uml 类图"></a>原型模式原理结构图-uml 类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230422235313399.png" alt="image-20230422235313399" style="zoom:67%;"><h3 id="原型结构图说明"><a href="#原型结构图说明" class="headerlink" title="原型结构图说明"></a>原型结构图说明</h3><blockquote><ul><li>Prototype : 原型类，声明一个克隆自己的接口</li><li>ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作</li><li>Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样）</li></ul></blockquote><h2 id="原型模式解决克隆羊问题的应用实例"><a href="#原型模式解决克隆羊问题的应用实例" class="headerlink" title="原型模式解决克隆羊问题的应用实例"></a>原型模式解决克隆羊问题的应用实例</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        Sheep sheep=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sheep=(Sheep) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 0:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;zjh&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Sheep sheep1=(Sheep)sheep.clone();</span><br><span class="line">        Sheep sheep2=(Sheep)sheep.clone();</span><br><span class="line">        Sheep sheep3=(Sheep)sheep.clone();</span><br><span class="line">        Sheep sheep4=(Sheep)sheep.clone();</span><br><span class="line">        System.out.println(sheep);</span><br><span class="line">        System.out.println(sheep1);</span><br><span class="line">        System.out.println(sheep2);</span><br><span class="line">        System.out.println(sheep3);</span><br><span class="line">        System.out.println(sheep4);</span><br><span class="line">        System.out.println(sheep1==sheep2);</span><br><span class="line">        System.out.println(sheep==sheep2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝的介绍"><a href="#浅拷贝的介绍" class="headerlink" title="浅拷贝的介绍"></a>浅拷贝的介绍</h2><blockquote><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li><li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>前面我们克隆羊就是浅拷贝</li><li>浅拷贝是使用默认的 clone()方法来实现sheep &#x3D; (Sheep) super.clone();</li></ul></blockquote><h2 id="深拷贝的介绍"><a href="#深拷贝的介绍" class="headerlink" title="深拷贝的介绍"></a>深拷贝的介绍</h2><blockquote><ul><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，<strong>对象进行深拷贝要对整个对象</strong><strong>(包括对象的引用类型)进行拷</strong>贝**</li><li><strong>深拷贝实现方式 1：重写 clone</strong> 方法来实现深拷贝</li><li><strong>深拷贝实现方式 2</strong>：通过<strong>对象序列化</strong>实现深拷贝(推荐)</li></ul></blockquote><h2 id="深拷贝的应用案例"><a href="#深拷贝的应用案例" class="headerlink" title="深拷贝的应用案例"></a>深拷贝的应用案例</h2><h3 id="代码演示（两种方法）"><a href="#代码演示（两种方法）" class="headerlink" title="代码演示（两种方法）"></a>代码演示（两种方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 0:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="built_in">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 0:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 两种方式</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepProtoType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>,Cloneable &#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepProtoType</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝--方式一--使用clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        Object deep=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这里完成对基本数据类型(属性)和String的克隆</span></span><br><span class="line">        deep=<span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//对于引用类型进行单独处理</span></span><br><span class="line">        DeepProtoType deepProtoType=(DeepProtoType)deep;</span><br><span class="line">        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deepProtoType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝--方式二--通过对象的序列化</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deepClone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos=<span class="literal">null</span>;</span><br><span class="line">        ObjectOutputStream oos=<span class="literal">null</span>;</span><br><span class="line">        ByteArrayInputStream bis=<span class="literal">null</span>;</span><br><span class="line">        ObjectInputStream ois=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);<span class="comment">//将当前对象以对象流的方式输出</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis=<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="type">DeepProtoType</span> <span class="variable">copyObj</span> <span class="operator">=</span> (DeepProtoType) ois.readObject();</span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">DeepProtoType</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepProtoType</span>();</span><br><span class="line">p.name = <span class="string">&quot;abb&quot;</span>;</span><br><span class="line">p.deepCloneableTarget = <span class="keyword">new</span> <span class="title class_">DeepCloneableTarget</span>(<span class="string">&quot;zjh&quot;</span>, <span class="string">&quot;zjhhhh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1 完成深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="type">DeepProtoType</span> <span class="variable">p2</span> <span class="operator">=</span> (DeepProtoType) p.clone();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2 完成深拷贝</span></span><br><span class="line"><span class="comment">//DeepProtoType p2 = (DeepProtoType) p.deepClone();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;p.name=&quot; + p.name + &quot;p.deepCloneableTarget=&quot; + p.deepCloneableTarget.hashCode());</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;p2.name=&quot; + p.name + &quot;p2.deepCloneableTarget=&quot; + p2.deepCloneableTarget.hashCode());</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式的注意事项和细节"><a href="#原型模式的注意事项和细节" class="headerlink" title="原型模式的注意事项和细节"></a>原型模式的注意事项和细节</h2><blockquote><ul><li>创建新的对象比较复杂时，可以利用原型模式简化<strong>对象的创建过程，同时也能够提高</strong>效率</li><li>不用重新初始化对象，而是<strong>动态地获得对象运行时</strong>的状态</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li><strong>缺点</strong>：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则，这点请同学们注意.</li></ul></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之原型模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h3><blockquote><p>看一个披萨的项目：要便于披萨种类的扩展，要便于维护</p><ul><li>披萨的种类很多(比如 GreekPizz、CheesePizz 等)</li><li>披萨的制作有 prepare，bake, cut, box</li><li>完成披萨店订购功能。</li></ul></blockquote><h3 id="传统方式来解决"><a href="#传统方式来解决" class="headerlink" title="传统方式来解决"></a>传统方式来解决</h3><h4 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E7%89%871.jpg" alt="图片1"></p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出pizza 制作过程</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传统方式的优缺点"><a href="#传统方式的优缺点" class="headerlink" title="传统方式的优缺点"></a>传统方式的优缺点</h4><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的 <strong>ocp</strong> <strong>原则</strong>，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个<strong>Pizza</strong> 的种类(Pepper披萨)，我们需要做如下修改. 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改.</li></ul></blockquote><h4 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h4><p>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza</p><p>的代码，往往有多处。</p><p>思路：<strong>把创建</strong> <strong>Pizza</strong> <strong>对象封装到一个类中，这样我们有新的</strong> <strong>Pizza</strong> <strong>种类时，只需要修改该类就可</strong>，其它有创建到 Pizza</p><p>对象的代码就不需要修改了.-&gt; <strong>简单工厂</strong>模式</p><h3 id="简单工厂模式基本介绍"><a href="#简单工厂模式基本介绍" class="headerlink" title="简单工厂模式基本介绍"></a>简单工厂模式基本介绍</h3><blockquote><ul><li>简单工厂模式是属于<strong>创建型模式</strong>，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是<strong>工厂模式家族中最简单实用的</strong>模式</li><li>简单工厂模式：定义了一个创建对象的类，由这个类来<strong>封装实例化对象的行为</strong>(代码)</li><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</li></ul></blockquote><h3 id="简单工厂模式的使用"><a href="#简单工厂模式的使用" class="headerlink" title="简单工厂模式的使用"></a>简单工厂模式的使用</h3><h4 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E7%89%872.jpg" alt="图片2"></p><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更加orderType 返回对应的Pizza 对象</span></span><br><span class="line"><span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;使用简单工厂模式&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单工厂模式 也叫 静态工厂模式 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title function_">createPizza2</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;使用简单工厂模式2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">SimpleFactory simpleFactory;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line">setFactory(simpleFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入的</span></span><br><span class="line"><span class="built_in">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType(); </span><br><span class="line">pizza = <span class="built_in">this</span>.simpleFactory(orderType);</span><br><span class="line"><span class="comment">//输出pizza</span></span><br><span class="line"><span class="keyword">if</span>(pizza != <span class="literal">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="新的需求"><a href="#新的需求" class="headerlink" title="新的需求"></a>新的需求</h3><p>披萨项目新的需求：客户在点披萨时，可以点<strong>不同口味的披萨</strong>，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用<strong>简单工厂模式</strong>，创建<strong>不同的简单工厂类</strong>，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>使用工厂方法模式</p><h3 id="工厂方法模式介绍"><a href="#工厂方法模式介绍" class="headerlink" title="工厂方法模式介绍"></a>工厂方法模式介绍</h3><blockquote><ul><li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</li><li>工厂方法模式：<strong>定义了一个创建对象的抽象方法</strong>，由子<strong>类决定要实例化的类</strong>。工厂方法模式将<strong>对象的实例化推迟到子类</strong>。</li></ul></blockquote><h3 id="工厂方法模式应用案例"><a href="#工厂方法模式应用案例" class="headerlink" title="工厂方法模式应用案例"></a>工厂方法模式应用案例</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza</p><h4 id="类图分析-2"><a href="#类图分析-2" class="headerlink" title="类图分析"></a>类图分析</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E7%89%873.jpg" alt="图片3"></p><h4 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"><span class="comment">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span></span><br><span class="line"><span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line">pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line"><span class="comment">//输出pizza 制作过程</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>北京子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="抽象工厂模式介绍"><a href="#抽象工厂模式介绍" class="headerlink" title="抽象工厂模式介绍"></a>抽象工厂模式介绍</h3><blockquote><ul><li>抽象工厂模式：定义了一个 <strong>interface</strong> <strong>用于创建相关或有依赖关系的对象簇</strong>，而无需指明具体的类</li><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li><li>将工厂抽象成<strong>两层</strong>，<strong>AbsFactory(抽象工厂)</strong> 和 <strong>具体实现的工厂子类</strong>。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li></ul></blockquote><h3 id="抽象工厂模式应用实例"><a href="#抽象工厂模式应用实例" class="headerlink" title="抽象工厂模式应用实例"></a>抽象工厂模式应用实例</h3><h4 id="类图分析-3"><a href="#类图分析-3" class="headerlink" title="类图分析"></a>类图分析</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230422231431718.png" alt="image-20230422231431718" style="zoom:67%;"><h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line">    <span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        Pizza pizza=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza=<span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;</span><br><span class="line">            pizza=<span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    AbsFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        setFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 用户输入</span></span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            <span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">            pizza = factory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="literal">null</span>) &#123; <span class="comment">// 订购ok</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式小结"><a href="#工厂模式小结" class="headerlink" title="工厂模式小结"></a>工厂模式小结</h2><ul><li><p>工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p></li><li><p>三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)</p></li><li><p>设计模式的依赖抽象原则</p><ul><li>创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</li><li>不要覆盖基类中已经实现的方法。</li></ul></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之工厂模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2023/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a>单例设计模式介绍</h2><p>所谓类的单例设计模式，就是<strong>采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</strong>， 并且该类只提供一个取得其对象实例的方法(静态方法)。</p><p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p><h2 id="单例设计模式的八种方式"><a href="#单例设计模式的八种方式" class="headerlink" title="单例设计模式的八种方式"></a>单例设计模式的八种方式</h2><blockquote><ul><li><strong>饿汉式(静态常量)</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式(线程不安全)</li><li>懒汉式(线程安全，同步方法)</li><li>懒汉式(线程安全，同步代码块)</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ul></blockquote><h2 id="饿汉式（静态变量）"><a href="#饿汉式（静态变量）" class="headerlink" title="饿汉式（静态变量）"></a>饿汉式（静态变量）</h2><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>步骤如下：</p><blockquote><ul><li>构造器私有化 (防止 new )</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。getInstance</li><li>代码实现</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 8:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 饿汉式（静态变量）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//3、提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</li><li>这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</li><li>结论：这种单例模式可用，可能造成内存浪费</li></ul></blockquote><h2 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h2><h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><p>这种方式和上面的方式其实类似，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 8:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 饿汉式（静态代码块）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//在静态代码块中，创建单例对象</span></span><br><span class="line">        instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>结论：这种单例模式可用，但是可能造成内存浪费</li></ul></blockquote><h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 懒汉式（线程不安全）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、提供一个公有的静态方法，只有使用到该方法时，才去创建instance，即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了 if (singleton &#x3D;&#x3D; null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会<strong>产生多个实例</strong>。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，<strong>不要使用</strong>这种方式.</li></ul></blockquote><h2 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h2><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 懒汉式（线程安全、同步方法）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、提供一个公有的静态方法，只有使用到该方法时，才去创建instance，即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>解决了<strong>线程安全</strong>问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。<strong>方法进行同步效率太</strong>低</li><li>结论：在实际开发中，<strong>不推荐</strong>使用这种方式</li></ul></blockquote><h2 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h2><h3 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 懒汉式（线程安全、同步代码块）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、提供一个公有的静态方法，只有使用到该方法时，才去创建instance，即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><ul><li>上述代码其实没有实现单例，假如有两个线程a,b同时进入了if判断，a在进行了对象的创建时，虽然b在外面等待，但是当a创建完毕之后，b线程会进入代码块执行对象的创建，这样就创建了两个对象，不符合单例设计模式。</li><li>不使用</li></ul><h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h2><h3 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 双重检查</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//volatile是Java提供的一种轻量级的同步机制。</span></span><br><span class="line">    <span class="comment">//当一个线程修改共享变量后他会立即被更新到主内存中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">    <span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton &#x3D;&#x3D; null)检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton &#x3D;&#x3D; null)，直接 return 实例化对象，也避免的反复进行方法同步.</li><li>线程安全；延迟加载；效率较高</li><li>结论：在实际开发中，<strong>推荐使用这种单例设计模</strong>式</li></ul></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h3 id="代码演示-4"><a href="#代码演示-4" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 静态内部类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写一个静态内部类，该类有一个静态属性INSTANCE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个公有的静态方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li><li>结论：<strong>推荐</strong>使用.</li></ul></blockquote><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="代码演示-5"><a href="#代码演示-5" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 11:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 枚举</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">        System.out.println(instance.hashCode()); </span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line">        instance.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li><li>这种方式是 <strong>Effective Java</strong> <strong>作者</strong> <strong>Josh Bloch</strong> <strong>提倡</strong>的方</li><li>结论：<strong>推荐</strong>使用</li></ul></blockquote><h2 id="单例设计模式注意事项和细节"><a href="#单例设计模式注意事项和细节" class="headerlink" title="单例设计模式注意事项和细节"></a>单例设计模式注意事项和细节</h2><blockquote><ul><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li><li>单例模式<strong>使用的场景</strong>：需要<strong>频繁的进行创建和销毁的对象</strong>、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、<strong>工具类对象</strong>、频繁访问数据库或文件的对象(比如<strong>数据源、session 工厂</strong>等)</li></ul></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之单例模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/2023/04/26/UML%E7%B1%BB%E5%9B%BE/"/>
      <url>/2023/04/26/UML%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>UML图有很多种，但是并非必须掌握所有的UML图，才能完整系统分析和设计工作。一般说来，在UML图中，只要掌握类图、用例图、时序图的使用，就能完成大部分的工作。对于程序员来说，最频繁使用的莫过于类图。因此，这里我只讲解UML类图。</p><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图中最基本的元素是类、接口。软件设计师设计出类图后，程序员就可以用代码实现类图中包含的内容。</p><h3 id="1-1-UML图"><a href="#1-1-UML图" class="headerlink" title="1.1.UML图"></a>1.1.UML图</h3><ul><li>用例图(use case)</li><li>静态结构图： 类图、对象图、包图、组件图、部署图</li><li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li><li><strong>类图是描述类与类之间的关系的，是UML图中最核心的</strong></li></ul><h3 id="1-2-UML类图"><a href="#1-2-UML类图" class="headerlink" title="1.2.UML类图"></a>1.2.UML类图</h3><ul><li>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。</li><li>类之间的关系： <strong><code>依赖、泛化（继承）、实现、关联、聚合与组合</code></strong></li></ul><h3 id="1-3-类图关系"><a href="#1-3-类图关系" class="headerlink" title="1.3.类图关系"></a>1.3.类图关系</h3><blockquote><ul><li>设计一个类中的信息和行为要 <code>高内聚</code></li><li>设计多个类, 类之间要 <code>低耦合</code></li></ul></blockquote><p>面向对象是符合人们对现实世界的思维模式，利用面向对象设计，特别是采用各种设计模式来解决问题时，会设计多个类，然后创建多个对象，一个设计良好的类，应该是兼顾信息和行为并且高内聚。而不同的类之间，应该做到松耦合。</p><p>当面对应用系统或者需要解决的问题经常是复杂的、高度抽象的，我们 创建的多个对象往往是有联系的，通常对象之间的关系可以分为以下几类：</p><ul><li>泛化关系</li><li>实现关系</li><li>依赖关系</li><li>关联关系</li><li>聚合关系</li><li>组合关系</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224123104360.png" alt="img" style="zoom:67%;"><h2 id="2-依赖关系（Dependence）"><a href="#2-依赖关系（Dependence）" class="headerlink" title="2.依赖关系（Dependence）"></a>2.依赖关系（Dependence）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224105438325.png" alt="img"></p><ul><li>只要是在<strong>类中用到了对方，那么他们之间就存在依赖关系</strong>。如果没有对方，连编绎都通过不了</li><li>依赖（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。</li></ul><h2 id="3-泛化关系（generalization）"><a href="#3-泛化关系（generalization）" class="headerlink" title="3.泛化关系（generalization）"></a>3.泛化关系（generalization）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224104304237.png" alt="img"></p><ul><li>泛化关系其实就是<code>继承关系</code>：指的是一个类（称为子类、子接口）继承(<code>extends</code>)另外的一个类（称为父类、父接口）的功能，并可以增加自己额外的一些功能，<strong>继承是类与类或者接口与接口之间最常见的关系；</strong></li><li>Java代码中，对象之间的泛化关系可以直接翻译为关键字 <code>extends</code>。</li><li>他是<strong>依赖关系</strong>的<strong>特例</strong></li></ul><h2 id="4-实现关系（realization）"><a href="#4-实现关系（realization）" class="headerlink" title="4.实现关系（realization）"></a>4.实现关系（realization）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224104937159.png" alt="img"></p><ul><li>实现关系实际上就<strong>是</strong> <strong>A</strong> <strong>类实现</strong> <strong>B</strong> <strong>接口</strong>，他是<strong>依赖关系的特</strong>例</li><li>在Java代码中，实现关系可以直接翻译为关键字 <code>implements</code>。</li></ul><h2 id="5-关联关系（association）"><a href="#5-关联关系（association）" class="headerlink" title="5.关联关系（association）"></a>5.关联关系（association）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/2020022411311616.png" alt="img"></p><ul><li>关联关系（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在Java中，关联关系的代码表现形式为一个对象含有另一个对象的引用。也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。</li><li>关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。</li></ul><h3 id="5-1-按多重性分类"><a href="#5-1-按多重性分类" class="headerlink" title="5.1.按多重性分类"></a>5.1.按多重性分类</h3><ul><li>一对一：一个A对象属于一个B对象，一个B对象属于一个A对象。</li><li>一对多：一个A对象包含多个B对象。</li><li>多对一：多个A对象属于一个B对象，并且多个A对象中的每个A对象只能属于一个B对象。</li><li>多对多：一个A对象属于多个B对象，一个B对象属于多个A对象。</li></ul><h3 id="5-2-按导航性分类"><a href="#5-2-按导航性分类" class="headerlink" title="5.2.按导航性分类"></a>5.2.按导航性分类</h3><ul><li>单向：只能从A通过属性导航到B，B不能导航到A。</li><li>双向：A可以通过属性导航到B，B也可以通过属性导航到A。</li></ul><h2 id="6-聚合关系（aggregtion）"><a href="#6-聚合关系（aggregtion）" class="headerlink" title="6.聚合关系（aggregtion）"></a>6.聚合关系（aggregtion）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/2020022412311785.png" alt="img"></p><ul><li>聚合（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。</li><li>与关联关系一样，**<code>聚合关系</code>** 也是通过<code>实例变量</code>实现的。**<code>但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。</code>**</li><li>聚合关系表示整体和个体的关系，整体和个体可以相互独立存在，一定是有两个模块分别管理整体和个体。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Mouse mouse; <span class="comment">//鼠标可以和computer分离</span></span><br><span class="line"><span class="keyword">private</span> Moniter moniter;<span class="comment">//显示器可以和Computer分离</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoniter</span><span class="params">(Moniter moniter)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.moniter = moniter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的类图：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230419205622690.png" alt="image-20230419205622690"></p><h2 id="7-组合关系（composition）"><a href="#7-组合关系（composition）" class="headerlink" title="7.组合关系（composition）"></a>7.组合关系（composition）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224123131234.png" alt="img"></p><ul><li><p>组合（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 “contains a” 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。如果<code>A</code>组合<code>B</code>，则<code>A</code>需要知道<code>B</code>的生存周期，即可能<code>A</code>负责生成或者释放<code>B</code>，或者<code>A</code>通过某种途径知道<code>B</code>的生成和释放。</p></li><li><p>例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。</p></li><li><p>但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那么 IDCard 和 Person 就是组合了.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Head</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Head</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应的类图：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230419210202946.png" alt="image-20230419210202946"></p><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>这次的设计模式之UML类图的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之七大原则</title>
      <link href="/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h2><h3 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1.基本介绍"></a>1.1.基本介绍</h3><p>对类来说的，<strong>即一个类应该只负责一项职责</strong>。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p><h3 id="1-2-应用实例"><a href="#1-2-应用实例" class="headerlink" title="1.2.应用实例"></a>1.2.应用实例</h3><h4 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>在方式1 的run方法中，违反了单一职责原则</li><li>解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</li></ol></blockquote><h4 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RoadVehicle</span> <span class="variable">roadVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoadVehicle</span>();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        <span class="type">AirVehicle</span> <span class="variable">airVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirVehicle</span>();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoadVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>遵守单一职责原则</li><li>但是这样做的改动很大，即将类分解，同时修改客户端</li><li>改进：直接修改Vehicle 类，改动的代码会比较少&#x3D;&gt;方案3</li></ol></blockquote><h4 id="1-2-3-方式三"><a href="#1-2-3-方式三" class="headerlink" title="1.2.3.方式三"></a>1.2.3.方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle2</span> <span class="variable">vehicle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle2</span>();</span><br><span class="line">        vehicle2.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAir</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runWater</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>这种修改方法没有对原来的类做大的修改，只是增加方法</li><li>这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</li></ol></blockquote><h3 id="1-3-单一职责原则细节"><a href="#1-3-单一职责原则细节" class="headerlink" title="1.3.单一职责原则细节"></a>1.3.单一职责原则细节</h3><blockquote><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol></blockquote><h2 id="2-接口隔离原则"><a href="#2-接口隔离原则" class="headerlink" title="2.接口隔离原则"></a>2.接口隔离原则</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1.基本介绍"></a>2.1.基本介绍</h3><ul><li><p>客户端不应该依赖它不需要的接口，即<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p></li><li><p>看图：</p></li><li><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230418232111042.png" alt="image-20230418232111042" style="zoom:67%;"></li><li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p></li><li><p>按隔离原则应当这样处理：</p><p><strong>将接口</strong> <strong>Interface1</strong> 拆分为**独立的几个接口(这里我们拆分成3个接口)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则:</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230418232808656.png" alt="image-20230418232808656" style="zoom:67%;"></li></ul><h3 id="2-2-应用实例"><a href="#2-2-应用实例" class="headerlink" title="2.2.应用实例"></a>2.2.应用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Segregation1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> <span class="title class_">B</span>()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"></span><br><span class="line">        c.depend1(<span class="keyword">new</span> <span class="title class_">D</span>()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">        c.depend4(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface3 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h2><h3 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1.基本介绍"></a>3.1.基本介绍</h3><ul><li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象</p></li><li><p>抽象不应该依赖细节，细节应该依赖抽象</p></li></ul><ul><li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用<strong>接口或抽象类</strong>的目的是制定好<strong>规范</strong>，而不涉及任何具体的操作，把<strong>展现细节的任务交给他们的实现类</strong>去完成</li></ul><h3 id="3-2-应用实例"><a href="#3-2-应用实例" class="headerlink" title="3.2.应用实例"></a>3.2.应用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependecyInversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户端无需改变</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.receive(<span class="keyword">new</span> <span class="title class_">Email</span>());</span><br><span class="line">        person.receive(<span class="keyword">new</span> <span class="title class_">WeiXin</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeiXin</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(IReceiver receiver )</span> &#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-依赖关系传递的三种方式"><a href="#3-3-依赖关系传递的三种方式" class="headerlink" title="3.3.依赖关系传递的三种方式"></a>3.3.依赖关系传递的三种方式</h3><ol><li>接口传递</li><li>构造方法传递</li><li>setter方法传递</li></ol><h3 id="3-4-依赖倒转原则的细节"><a href="#3-4-依赖倒转原则的细节" class="headerlink" title="3.4.依赖倒转原则的细节"></a>3.4.依赖倒转原则的细节</h3><blockquote><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的<strong>声明类型尽量是抽象类或接口</strong>, 这样我们的变量引用和实际对象间，就存在<strong>一个缓冲层</strong>，利于程序扩展和优化</li><li>继承时遵循<strong>里氏替换</strong>原则</li></ul></blockquote><h2 id="4-里氏替换原则"><a href="#4-里氏替换原则" class="headerlink" title="4.里氏替换原则"></a>4.里氏替换原则</h2><h3 id="4-1-OO中的继承性的思考和说明"><a href="#4-1-OO中的继承性的思考和说明" class="headerlink" title="4.1.OO中的继承性的思考和说明"></a>4.1.OO中的继承性的思考和说明</h3><blockquote><ul><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来<strong>侵入性</strong>，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：<strong>在编程中，如何正确的使用继承</strong>? &#x3D;&gt; <strong>里氏替换</strong>原则</li></ul></blockquote><h3 id="4-2-基本介绍"><a href="#4-2-基本介绍" class="headerlink" title="4.2.基本介绍"></a>4.2.基本介绍</h3><blockquote><ul><li>里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。</li><li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型T2 是类型 T1 的子类型。<strong>换句话说，所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li><li>在使用继承时，遵循里氏替换原则，在<strong>子类中尽量不要重写父类的方法</strong></li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合，组合，依赖 **  来解决问题。.</li></ul></blockquote><h3 id="4-3-问题的引出"><a href="#4-3-问题的引出" class="headerlink" title="4.3.问题的引出"></a>4.3.问题的引出</h3><p>请发现下面代码的问题;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-解决问题"><a href="#4-4-解决问题" class="headerlink" title="4.4.解决问题"></a>4.4.解决问题</h3><blockquote><ul><li>我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</li><li>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类</strong>，原有的继承关系去掉，采用<strong>依赖，聚合，组合</strong>等关系代替.</li></ul></blockquote><p>改进UML类图：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230419092158189.png" alt="image-20230419092158189"></p><p>解决代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">        <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h2><h3 id="5-1-开闭原则"><a href="#5-1-开闭原则" class="headerlink" title="5.1.开闭原则"></a>5.1.开闭原则</h3><blockquote><ul><li>开闭原则（Open Closed Principle）是编程中<strong>最基础、最重要</strong>的设计原则</li><li>一个软件实体如类，模块和函数应该**对扩展开放(对提供方)**，对修改关闭(对使用方)<strong>。用抽象构建框架，用实现扩展细节。</strong></li><li>当软件需要变化时，尽量<strong>通过扩展软件</strong>实体的行为来实现变化，而不是<strong>通过修改</strong>已有的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ul></blockquote><h3 id="5-2-发现问题"><a href="#5-2-发现问题" class="headerlink" title="5.2.发现问题"></a>5.2.发现问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Opc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">            drawRectangle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">            drawCircle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">            drawTriangle(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTriangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的优缺点：</p><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个图形种类 三角形，修改的地方较多</li></ul></blockquote><h3 id="5-3-解决问题"><a href="#5-3-解决问题" class="headerlink" title="5.3.解决问题"></a>5.3.解决问题</h3><p>思路：把创建 <strong>Shape</strong> <strong>类做成抽象类</strong>，并提供一个<strong>抽象的</strong> <strong>draw</strong> 方法，让<strong>子类去实现即可</strong>，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，<strong>使用方的代码就不需要修</strong> -&gt; 满足了开闭原则</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">OtherGraphic</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherGraphic</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    OtherGraphic() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则"></a>6.迪米特法则</h2><h3 id="6-1-基本介绍"><a href="#6-1-基本介绍" class="headerlink" title="6.1.基本介绍"></a>6.1.基本介绍</h3><blockquote><ul><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即一个类<strong>对自己依赖的类知道的越少越好</strong>。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li><li><strong>直接的朋友</strong>：每个对象都会与其他对象有<strong>耦合关系</strong>，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量</strong>，<strong>方法参数</strong>，<strong>方法返回值</strong>中的类为直接的朋友，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li></ul></blockquote><h3 id="6-2-应用实例"><a href="#6-2-应用实例" class="headerlink" title="6.2.应用实例"></a>6.2.应用实例</h3><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demeter1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        <span class="type">SchoolManager</span> <span class="variable">schoolManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolManager</span>();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManager</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">        <span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">        <span class="comment">//3. 违反了 迪米特法则</span></span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以上代码的问题：</p><blockquote><ul><li>这里的 CollegeEmployee 不是  SchoolManager的直接朋友</li><li>CollegeEmployee 是以局部变量方式出现在 SchoolManager</li><li>违反了 迪米特法则</li><li>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</li></ul></blockquote><p>改进之后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demeter2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        <span class="type">SchoolManager</span> <span class="variable">schoolManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolManager</span>();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManager</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出学院员工的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">        sub.printEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-迪米特法则的细节"><a href="#6-3-迪米特法则的细节" class="headerlink" title="6.3.迪米特法则的细节"></a>6.3.迪米特法则的细节</h3><blockquote><ul><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li></ul></blockquote><h2 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7.合成复用原则"></a>7.合成复用原则</h2><h3 id="7-1-基本介绍"><a href="#7-1-基本介绍" class="headerlink" title="7.1.基本介绍"></a>7.1.基本介绍</h3><p>原则是尽量使用合成聚合的方式，而不是使用继承</p><h3 id="7-2-设计原则核心思想"><a href="#7-2-设计原则核心思想" class="headerlink" title="7.2.设计原则核心思想"></a>7.2.设计原则核心思想</h3><blockquote><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的<strong>松耦合设计而努</strong>力</li></ul></blockquote><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>这次的设计模式之七大原则的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之代理模式</title>
      <link href="/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>最近要进行软件工程设计模式的小组讨论了，正好借着这个机会来复习一下设计模式，这次为大家带来我在学习代理模式的一些笔记和心得。</p><h2 id="2-代理模式的基本介绍"><a href="#2-代理模式的基本介绍" class="headerlink" title="2.代理模式的基本介绍"></a>2.代理模式的基本介绍</h2><blockquote><ul><li>代理模式：为一个对象<strong>提供一个替身</strong>，以控制对这个对象的访问，则通过代理对象访问目标对象。这样做的好处是：可以对目标对象实现的基础上，增强额外的功能。</li><li>被代理的对象可以是远程对象、创建开销大的对象或者是需要安全控制的对象。</li><li>代理模式主要有三种<strong>静态代理</strong>、<strong>动态代理（JDK代理、接口代理）</strong>、<strong>Cglib代理（可以在内存中动态的创建对象，而不需要实现接口。属于动态代理的范畴）</strong></li></ul></blockquote><h2 id="3-静态代理"><a href="#3-静态代理" class="headerlink" title="3.静态代理"></a>3.静态代理</h2><h3 id="3-1-静态代理模式的基本介绍"><a href="#3-1-静态代理模式的基本介绍" class="headerlink" title="3.1.静态代理模式的基本介绍"></a>3.1.静态代理模式的基本介绍</h3><p>静态代理在使用时，需要定义接口或者父类，被代理对象（目标对象）与代理对象一起实现相同的接口或者是继承相同的父类</p><h3 id="3-2-应用实例"><a href="#3-2-应用实例" class="headerlink" title="3.2.应用实例"></a>3.2.应用实例</h3><h4 id="3-2-1-具体要求"><a href="#3-2-1-具体要求" class="headerlink" title="3.2.1.具体要求"></a>3.2.1.具体要求</h4><blockquote><ol><li>定义一个接口：<code>ITeacherDAO</code></li><li>目标对象<code>TeacherDAO</code>实现接口<code>ITeacherDAO</code></li><li>使用静态代理的方式，就需要代理对象<code>TeacherDAOProxy</code>也实现<code>ITeacherDAO</code></li><li>调用的时候通过调用代理对象的方法来调用目标对象</li><li><strong>特别注意</strong>：代理对象要与目标对象实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。</li></ol></blockquote><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml.png" alt="staticProxy" style="zoom:67%;"><h4 id="3-2-2-代码演示"><a href="#3-2-2-代码演示" class="headerlink" title="3.2.2.代码演示"></a>3.2.2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//讲课的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 目标对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理对象，静态代理</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAOProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITeacherDAO target;<span class="comment">//目标对象，通过接口来聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherDAOProxy</span><span class="params">(ITeacherDAO target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增强功能...&quot;</span>);</span><br><span class="line">        target.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;增强功能...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象（被代理对象）</span></span><br><span class="line">        TeacherDAO teacherDAO=<span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line">        <span class="comment">//创建代理对象，同时将被代理对象传给代理对象</span></span><br><span class="line">        <span class="type">TeacherDAOProxy</span> <span class="variable">teacherDAOProxy</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TeacherDAOProxy</span>(teacherDAO);</span><br><span class="line">        <span class="comment">//通过代理对象调用到被代理对象的方法</span></span><br><span class="line">        teacherDAOProxy.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-静态代理的优缺点"><a href="#3-3-静态代理的优缺点" class="headerlink" title="3.3.静态代理的优缺点"></a>3.3.静态代理的优缺点</h3><h4 id="3-3-1-优点"><a href="#3-3-1-优点" class="headerlink" title="3.3.1.优点"></a>3.3.1.优点</h4><p>在不修改目标对象功能的前提下，能通过代理对象对目标功能进行扩展</p><h4 id="3-3-2-缺点"><a href="#3-3-2-缺点" class="headerlink" title="3.3.2.缺点"></a>3.3.2.缺点</h4><ul><li>因为代理对象需要与目标对象实现一样的接口，所以会有很多的代理类</li><li>一旦接口增加方法，目标对象与代理对象都要维护</li></ul><h2 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h2><h3 id="4-1-动态代理的基本介绍"><a href="#4-1-动态代理的基本介绍" class="headerlink" title="4.1.动态代理的基本介绍"></a>4.1.动态代理的基本介绍</h3><blockquote><ul><li>代理对象不需要实现接口，但是目标对象需要实现接口，否则不能使用动态代理</li><li>代理对象的生成，是利用JDK中的API，动态的在内存中构建代理对象</li><li>动态代理要叫：JDK代理、接口代理</li></ul></blockquote><h3 id="4-2-JDK中生成代理对象的API"><a href="#4-2-JDK中生成代理对象的API" class="headerlink" title="4.2.JDK中生成代理对象的API"></a>4.2.JDK中生成代理对象的API</h3><blockquote><ul><li>代理类所在的包：<code>java.lang.reflect.Proxy</code></li><li>JDK的代理实现只需要使用<code>newProxyInstance</code>方法,完整写法<code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></li></ul></blockquote><h3 id="4-3-应用实例"><a href="#4-3-应用实例" class="headerlink" title="4.3.应用实例"></a>4.3.应用实例</h3><h4 id="4-3-1-具体要求"><a href="#4-3-1-具体要求" class="headerlink" title="4.3.1.具体要求"></a>4.3.1.具体要求</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml2.png" alt="dynamicProxy" style="zoom:67%;"><h4 id="4-3-2-代码实现"><a href="#4-3-2-代码实现" class="headerlink" title="4.3.2.代码实现"></a>4.3.2.代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//讲课的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 目标对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 14:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理工厂类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象，Object</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给目标对象生成一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">         *                                           Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">         *                                           InvocationHandler h)</span></span><br><span class="line"><span class="comment">         * ClassLoader loader:指定目标对象使用的类加载器，获取类加载器的方法固定</span></span><br><span class="line"><span class="comment">         * Class&lt;?&gt;[] interfaces:目标对象实现鹅接口类型，使用泛型的方法确定类型</span></span><br><span class="line"><span class="comment">         * InvocationHandler h:事件处理，执行目标对象方法时，会促发事件处理器的方法，</span></span><br><span class="line"><span class="comment">         * 会把当前执行的目标对象方法作为一个参数传入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;JDK代理开始...&quot;</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理提交...&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 14:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        ITeacherDAO target=<span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给目标对象，创建代理对象，转化为ITeacherDAO</span></span><br><span class="line">        <span class="type">ITeacherDAO</span> <span class="variable">proxyInstance</span> <span class="operator">=</span>(ITeacherDAO) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//class com.sun.proxy.$Proxy0内存中动态生成了代理对象</span></span><br><span class="line">        System.out.println(proxyInstance.getClass());</span><br><span class="line">        <span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">        proxyInstance.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Cglib代理"><a href="#5-Cglib代理" class="headerlink" title="5.Cglib代理"></a>5.Cglib代理</h2><h3 id="5-1-Cglib代理模式的基本介绍"><a href="#5-1-Cglib代理模式的基本介绍" class="headerlink" title="5.1.Cglib代理模式的基本介绍"></a>5.1.Cglib代理模式的基本介绍</h3><blockquote><ul><li>静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可以使用目标对象的子类来实现代理，这就是Cglib代理</li><li>Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展，有时候也将<strong>Cglib代理归属到动态代理</strong></li><li>Cglib是一个强大的高性能的代码生成包，它可以在运行期间扩展java类与实现java接口。它广泛的被许多AOP框架使用，比如Spring AOP，实现方法拦截。</li><li>在AOP编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理</li></ul></li><li>Cglib包的底层是通过使用字节码处理框架ASM来转化字节码并生成新的</li></ul></blockquote><h3 id="5-2-应用实例"><a href="#5-2-应用实例" class="headerlink" title="5.2.应用实例"></a>5.2.应用实例</h3><h4 id="5-2-1-Cglib代理模式的实现步骤"><a href="#5-2-1-Cglib代理模式的实现步骤" class="headerlink" title="5.2.1.Cglib代理模式的实现步骤"></a>5.2.1.Cglib代理模式的实现步骤</h4><blockquote><ol><li>需要引入Cglib的jar文件<ul><li>asm.jar</li><li>asm-commons.jar</li><li>asm-tree.jar</li><li>cglib-2.2.jar</li></ul></li><li>在内存中动态构建子类，注意代理的内不能为**<code>final</code>**,否则会报<code>java.lang.IllegalArgumentException</code></li><li>目标对象的方法如果为<code>final/static</code>，那么就不会被拦截，即不会执行目标对象额外的业务方法</li></ol></blockquote><h4 id="5-2-2-具体要求"><a href="#5-2-2-具体要求" class="headerlink" title="5.2.2.具体要求"></a>5.2.2.具体要求</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml3.png" alt="Cglib代理" style="zoom:67%;"><h4 id="5-2-3-代码实现"><a href="#5-2-3-代码实现" class="headerlink" title="5.2.3.代码实现"></a>5.2.3.代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 15:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...,我是Cglib代理，不需要实现接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 15:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理工厂</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象：是target对象的代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、创建一个工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2、设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3、设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4、创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写intercept方法，会调用目标对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理模式开始...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理提交...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 16:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">TeacherDAO</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line">        <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        <span class="type">TeacherDAO</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (TeacherDAO) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//执行代理对象的方法,触发intercept方法，从而实现对目标对象的调用</span></span><br><span class="line">        proxyInstance.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-代理模式的变体"><a href="#6-代理模式的变体" class="headerlink" title="6.代理模式的变体"></a>6.代理模式的变体</h2><h3 id="6-1-几种常见的代理模式介绍"><a href="#6-1-几种常见的代理模式介绍" class="headerlink" title="6.1.几种常见的代理模式介绍"></a>6.1.几种常见的代理模式介绍</h3><h4 id="6-1-1-防火墙代理"><a href="#6-1-1-防火墙代理" class="headerlink" title="6.1.1.防火墙代理"></a>6.1.1.防火墙代理</h4><p>内网通过代理穿透防火墙，实现对公网的访问</p><h4 id="6-1-2-缓存代理"><a href="#6-1-2-缓存代理" class="headerlink" title="6.1.2.缓存代理"></a>6.1.2.缓存代理</h4><p>比如：当请求图片文件等资源时，先缓存代理取，如果取到资源则ok，如果去报道资源，再到公网或者数据库取，然后缓存。</p><h4 id="6-1-3-远程代理"><a href="#6-1-3-远程代理" class="headerlink" title="6.1.3.远程代理"></a>6.1.3.远程代理</h4><p><strong>远程对象的本地代表</strong>，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p><h4 id="6-1-4-同步代理"><a href="#6-1-4-同步代理" class="headerlink" title="6.1.4.同步代理"></a>6.1.4.同步代理</h4><p>主要运用在多线程编程中，完成多线程间同步工作。</p><h2 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7.结束语"></a>7.结束语</h2><p>这次的设计模式之代理模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo+github从0到1搭建个人博客</title>
      <link href="/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><h3 id="1-1-想说的话"><a href="#1-1-想说的话" class="headerlink" title="1.1.想说的话"></a>1.1.想说的话</h3><p>最近在学习 markdown 语法的时候，想着何不搭建一个个人的博客网站来进行分享一下自己的学习经验和心得了，于是马上开干，很快啊，一个简单的 blog 网站就诞生了，下面就来和大家分享一下使用 hexo+GitHub 从 0 到 1 搭建个人博客。</p><h3 id="1-2-准备工作"><a href="#1-2-准备工作" class="headerlink" title="1.2.准备工作"></a>1.2.准备工作</h3><p>在进行搭建博客之前，你需要:</p><blockquote><ul><li>拥有一个 GitHub 账号，没有的话去注册一个</li><li>安装了 node.js、npm，并且了解相关的知识</li><li>安装了 git</li></ul></blockquote><p>小编使用的环境：</p><blockquote><ul><li>Windows10</li><li><a href="mailto:&#110;&#111;&#100;&#x65;&#46;&#x6a;&#115;&#64;&#49;&#x38;&#x2e;&#x31;&#x35;&#46;&#x30;">&#110;&#111;&#100;&#x65;&#46;&#x6a;&#115;&#64;&#49;&#x38;&#x2e;&#x31;&#x35;&#46;&#x30;</a></li><li><a href="mailto:&#x67;&#105;&#116;&#64;&#50;&#x2e;&#51;&#x39;&#x2e;&#50;">&#x67;&#105;&#116;&#64;&#50;&#x2e;&#51;&#x39;&#x2e;&#50;</a></li><li><a href="mailto:&#104;&#x65;&#x78;&#111;&#x40;&#54;&#x2e;&#x33;&#46;&#48;">&#104;&#x65;&#x78;&#111;&#x40;&#54;&#x2e;&#x33;&#46;&#48;</a></li></ul></blockquote><h2 id="2-搭建-GitHub-博客"><a href="#2-搭建-GitHub-博客" class="headerlink" title="2.搭建 GitHub 博客"></a>2.搭建 GitHub 博客</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1.创建仓库"></a>2.1.创建仓库</h3><p>新建一个名为<code>你的github用户名.github.io</code>的仓库，比如说，如果你的 github 用户名是 zengjiahao1222，那么你就新建<code>zengjiahao1222.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就 s 是<a href="http://zengjiahao1222.github.io](http://test.github.io/)">http://zengjiahao1222.github.io](http://test.github.io/)</a> 了！</p><p>注意事项：</p><blockquote><ol><li>注册的邮箱一定要验证，否则不会成功</li><li>仓库名字必须是<code>username.github.io</code>,其中 username 是你的 GitHub 的用户名</li><li>仓库创建成功不会立即生效，需要过一段时间，大概 10-30 分钟。这个我踩坑了！！！</li></ol></blockquote><h3 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2.绑定域名"></a>2.2.绑定域名</h3><p>这个不绑定也是可以的，就用默认的<code>xxx.github.io</code>也是可以进行访问的，但是如果你想更加个性化，并且想拥有一个自己的域名，那就去买一个域名吧。</p><p>这里推荐去阿里云注册域名，大公司，有保障！！！</p><h2 id="3-配置-SSH-key"><a href="#3-配置-SSH-key" class="headerlink" title="3.配置 SSH key"></a>3.配置 SSH key</h2><h3 id="3-1-Github-配置-SSH-Key"><a href="#3-1-Github-配置-SSH-Key" class="headerlink" title="3.1.Github 配置 SSH Key"></a>3.1.Github 配置 SSH Key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用 git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure><p>然后连续 3 次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的 github 主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key——&gt;将刚复制的内容粘贴到 key 那里，title 随便填，保存:</p><p><img src="/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh.png" alt="配置"></p><h3 id="3-2-测试配置是否成功"><a href="#3-2-测试配置是否成功" class="headerlink" title="3.2.测试配置是否成功"></a>3.2.测试配置是否成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com <span class="comment"># 注意邮箱地址不用改</span></span><br></pre></td></tr></table></figure><p>如果提示<code>Hi zengjiahao1222! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>，那么恭喜你 SSH 已经配置成功</p><p>此时你还需要配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;liuxianan&quot;</span>// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><h2 id="4-使用-hexo-框架写博客"><a href="#4-使用-hexo-框架写博客" class="headerlink" title="4.使用 hexo 框架写博客"></a>4.使用 hexo 框架写博客</h2><h3 id="4-1-hexo-简介"><a href="#4-1-hexo-简介" class="headerlink" title="4.1.hexo 简介"></a>4.1.hexo 简介</h3><p>Hexo 是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持 Markdown 格式，有众多优秀插件和主题。</p><p>官网：<a href="http://hexo.io/">http://hexo.io</a></p><p>github：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h3 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2.原理"></a>4.2.原理</h3><p>由于 github pages 存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以 hexo 所做的就是将这些 md 文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到 github。</p><h3 id="4-3-安装"><a href="#4-3-安装" class="headerlink" title="4.3.安装"></a>4.3.安装</h3><p>建议使用 git bash 来执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>hexo 有 2 种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</p><h3 id="4-4-初始化"><a href="#4-4-初始化" class="headerlink" title="4.4.初始化"></a>4.4.初始化</h3><p>在电脑的某个地方新建一个名为 hexo 的文件夹（名字可以随便取），比如我的是<code>D:\hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /d/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo 会自动下载一些文件到这个目录，包括 node_modules</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo 就会在 public 文件夹生成相关 html 文件，这些文件将来都是要提交到 github 去的：</p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容</p><p>第一次初始化的时候 hexo 已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：</p><h3 id="4-5-修改主题"><a href="#4-5-修改主题" class="headerlink" title="4.5.修改主题"></a>4.5.修改主题</h3><p>个人觉得官方主题有点不好看，所有就继续了主题的更换，我在进行了一圈主题对比后，个人比较喜欢<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></p><p>首先我们来下载这个主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /d/hexo/</span><br><span class="line">$ npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ol><li>还可以用<code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code>来代替，但是我用这个在后续的修改主题样式的过程中经常出现样式不生效的情况，换成这个<code>npm install hexo-theme-butterfly</code>安装方式后基本解决了这个问题。</li><li>值得一提的是，通过 npm 安装并不会在 themes 里生成主题文件夹，而是在 node_modules 里生成</li><li>butterfly 主题美化教程<a href="https://butterfly.js.org/">butterfly</a></li></ol></blockquote><p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。每次修改了配置文件都要记得先进行<code>hexo clean</code>来清理一下<code>public</code>的内容，然后<code>hexo g</code></p><h3 id="4-5-上传到-Github"><a href="#4-5-上传到-Github" class="headerlink" title="4.5.上传到 Github"></a>4.5.上传到 Github</h3><p>我们先来安装一个插件，要不然后续的<code>hexo d</code>操作会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关 deploy 的部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:zengjiahao1222/zengjiahao1222.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><blockquote><p>在这里，branch 要写 main，因为 2020 年 10 月 1 日 GitHub 官方将默认分支 master 改为了 main</p></blockquote><h3 id="4-6-常用-hexo-命令"><a href="#4-6-常用-hexo-命令" class="headerlink" title="4.6.常用 hexo 命令"></a>4.6.常用 hexo 命令</h3><p>常见命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure><h3 id="4-7-写博客"><a href="#4-7-写博客" class="headerlink" title="4.7.写博客"></a>4.7.写博客</h3><p>定位到我们的 hexo 根目录，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br></pre></td></tr></table></figure><p>hexo 会帮我们在<code>_posts</code>下生成相关 md 文件,我们只需要打开这个文件就可以开始写博客了。当然你也可以直接自己新建 md 文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1, tag2, tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line"><span class="section">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><h4 id="4-7-1-写博客的工具"><a href="#4-7-1-写博客的工具" class="headerlink" title="4.7.1.写博客的工具"></a>4.7.1.写博客的工具</h4><p>这里推荐 Typora</p><h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5.结束语"></a>5.结束语</h2><p>这次的用 hexo+github 搭建个人博客网站的教程到此就结束了，不知道大家是否已经搭建完成了呢，如有知识点和内容上面的错误，请及时联系我来改正</p><p>部分内容转载自<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">小茗同学的博客园</a>,如有侵权，请立刻联系我，进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
