<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL的四种隔离级别</title>
      <link href="/2023/09/17/MySQL%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2023/09/17/MySQL%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文说的MySQL事务都是指在InnoDB引擎下，MyISAM引擎不支持事务</p><p><strong>数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败</strong></p><p>事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）四个特性，简称 ACID，缺一不可。今天要说的就是<strong>隔离性</strong>。</p><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>下面几个问题是事务隔离级别解决的问题</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（update）</strong>操作。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 称为幻读 如果事务A 按一定条件搜索， 期间事务B 删除了符合条件的某一条数据，导致事务A 再次读取时数据少了一条。</p><blockquote><ul><li>幻读：说的是存不存在的问题：原来不存在的,现在存在了,则是幻读</li><li>不可重复读：说的是变没变化的问题：原来是A,现在却变为了B,则为不可重复读</li></ul></blockquote><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL标准定义了四种隔离级别，MYSQL全部支持：</p><ul><li>读未提交（READ UNCOMMITTED）</li><li>读提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ul><p><strong>可重复读是 MySQL 的默认级别</strong></p><p>事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230917002027928.png" alt="image-20230917002027928" style="zoom:67%;"><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但是它连脏读的问题都没有解决</p><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>可重复读是指，事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之职责链模式</title>
      <link href="/2023/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>职责链模式（Chain of Responsibility Pattern）, 又叫 责任链模式，为请求创建了一个接收者对象的链(简单示意图)。这种模式对请求的发送者和接收者进行解耦。</li><li>职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</li><li>这种类型的设计模式属于行为型模式</li></ul><h2 id="职责链模式的原理类图"><a href="#职责链模式的原理类图" class="headerlink" title="职责链模式的原理类图"></a>职责链模式的原理类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230503102453759.png" alt="image-20230503102453759" style="zoom:80%;"><p>说明：</p><ul><li><code>Handler</code> : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外 <code>Handler</code></li><li><code>ConcreteHandlerA , B</code> 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处理者), 如果可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链</li><li><code>Request</code> ， 含义很多属性，表示一个请求</li></ul><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>编写程序完成学校 OA 系统的采购审批项目：需求采购员采购教学器材</p><p>如果金额 小于等于 5000, 由教学主任审批如果金额 </p><p>小于等于 10000, 由院长审批</p><p>如果金额 小于等于 30000, 由副校长审批</p><p>如果金额 超过 30000 以上，有校长审批</p><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230503102615538.png" alt="image-20230503102615538" style="zoom:80%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 10:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 请求</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//请求类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="comment">//请求金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PurchaseRequest</span><span class="params">(<span class="type">int</span> type, <span class="type">float</span> price, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 10:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象审批类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    Approver approver;  <span class="comment">//下一个处理者</span></span><br><span class="line">    String name; <span class="comment">// 名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Approver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个处理者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApprover</span><span class="params">(Approver approver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.approver = approver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 10:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 教学主任</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepartmentApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            approver.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 10:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 院长</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollegeApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CollegeApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(purchaseRequest.getPrice() &lt; <span class="number">5000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            approver.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 副校长</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViceSchoolMasterApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViceSchoolMasterApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(purchaseRequest.getPrice() &lt; <span class="number">10000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">30000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            approver.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 校长</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchoolMasterApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SchoolMasterApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(purchaseRequest.getPrice() &gt; <span class="number">30000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            approver.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个请求</span></span><br><span class="line">        <span class="type">PurchaseRequest</span> <span class="variable">purchaseRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PurchaseRequest</span>(<span class="number">1</span>, <span class="number">31000</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关的审批人</span></span><br><span class="line">        <span class="type">DepartmentApprover</span> <span class="variable">departmentApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentApprover</span>(<span class="string">&quot;张主任&quot;</span>);</span><br><span class="line">        <span class="type">CollegeApprover</span> <span class="variable">collegeApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeApprover</span>(<span class="string">&quot;李院长&quot;</span>);</span><br><span class="line">        <span class="type">ViceSchoolMasterApprover</span> <span class="variable">viceSchoolMasterApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViceSchoolMasterApprover</span>(<span class="string">&quot;王副校&quot;</span>);</span><br><span class="line">        <span class="type">SchoolMasterApprover</span> <span class="variable">schoolMasterApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolMasterApprover</span>(<span class="string">&quot;佟校长&quot;</span>);</span><br><span class="line">        <span class="comment">//需要将各个审批级别的下一个设置好 (处理人构成环形: )</span></span><br><span class="line">        departmentApprover.setApprover(collegeApprover);</span><br><span class="line">        collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">        viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line">        schoolMasterApprover.setApprover(departmentApprover);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        departmentApprover.processRequest(purchaseRequest);</span><br><span class="line">        viceSchoolMasterApprover.processRequest(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="职责链模式的注意事项和细节"><a href="#职责链模式的注意事项和细节" class="headerlink" title="职责链模式的注意事项和细节"></a>职责链模式的注意事项和细节</h2><ul><li>将请求和处理分开，实现解耦，提高系统的灵活性</li><li>简化了对象，使对象不需要知道链的结构</li><li>性能会受到影响，特别是在<strong>链比较长的时候</strong>，因此需控制链中最大节点数量，一般通过在 Handler 中设置一个最大节点数量，在 setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li><li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li><li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假&#x2F;加薪等审批流程、<code>Java Web</code> 中 <code>Tomcat</code>对 <code>Encoding</code> 的处理、拦截器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="/2023/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>策略模式（Strategy Pattern）中，定义<strong>算法族（策略组）</strong>，分别封装起来，让他们之间可以互相替换，此模式让<strong>算法的变化</strong>独立于<strong>使用算法的客</strong>户</li><li>这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合&#x2F;聚合，少用继承（客户通过组合方式使用策略）</li></ul><h2 id="策略模式原理类图"><a href="#策略模式原理类图" class="headerlink" title="策略模式原理类图"></a>策略模式原理类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230503093506650.png" alt="image-20230503093506650" style="zoom:80%;"><p>说明：</p><p>从上图可以看到，客户 context 有成员变量 strategy 或者其他的策略接口,至于需要使用到哪个策略，我们可以在构造器中指定</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等)</p><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230503093622913.png" alt="image-20230503093622913" style="zoom:80%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 飞行策略接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 子类具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 飞翔技术高</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodFlyBehavior</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 飞翔技术高超 ~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 飞的一般</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BadFlyBehavior</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 飞翔技术一般 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 不会飞</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoFlyBehavior</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 不会飞翔  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象鸭子</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="comment">//属性, 策略接口</span></span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;<span class="comment">//显示鸭子信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子嘎嘎叫~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子会游泳~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flyBehavior != <span class="literal">null</span>) &#123;</span><br><span class="line">            flyBehavior.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 野鸭</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">    <span class="comment">//构造器，传入FlyBehavior 的对象</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">WildDuck</span><span class="params">()</span> &#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> <span class="title class_">GoodFlyBehavior</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 这是野鸭 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 北京鸭</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PekingDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">    <span class="comment">//假如北京鸭可以飞翔，但是飞翔技术一般</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PekingDuck</span><span class="params">()</span> &#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> <span class="title class_">BadFlyBehavior</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~北京鸭~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 玩具鸭</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToyDuck</span><span class="params">()</span> &#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> <span class="title class_">NoFlyBehavior</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩具鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-05-03 9:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WildDuck</span> <span class="variable">wildDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildDuck</span>();</span><br><span class="line">        wildDuck.fly();<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ToyDuck</span> <span class="variable">toyDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToyDuck</span>();</span><br><span class="line">        toyDuck.fly();</span><br><span class="line"></span><br><span class="line">        <span class="type">PekingDuck</span> <span class="variable">pekingDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PekingDuck</span>();</span><br><span class="line">        pekingDuck.fly();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态改变某个对象的行为, 北京鸭 不能飞</span></span><br><span class="line">        pekingDuck.setFlyBehavior(<span class="keyword">new</span> <span class="title class_">NoFlyBehavior</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;北京鸭的实际飞翔能力&quot;</span>);</span><br><span class="line">        pekingDuck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式的注意事项和细节"><a href="#策略模式的注意事项和细节" class="headerlink" title="策略模式的注意事项和细节"></a>策略模式的注意事项和细节</h2><ul><li>策略模式的关键是：分析项目中变化部分与不变部分</li><li>策略模式的核心思想是：多用组合&#x2F;聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性</li><li>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else）</li><li>提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy 类中使得你可以独立于其Context 改变它，使它易于切换、易于理解、易于扩展</li><li><strong>需要注意的是</strong>：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM面试篇</title>
      <link href="/2023/08/22/JVM%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/22/JVM%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h1><h2 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h2><p><strong>Java Virtual Machine</strong>  Java程序的运行环境（Java二进制字节码的运行环境）</p><p>好处：</p><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821202523454.png" alt="image-20230821202523454"></p><h2 id="什么是程序计算器"><a href="#什么是程序计算器" class="headerlink" title="什么是程序计算器"></a>什么是程序计算器</h2><p>程序计算器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>线程共享的区域：主要用来保存对象实例、数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821203607302.png" alt="image-20230821203607302"></p><ul><li>年轻代被划分为三部分，Eden区和两个严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，仍然存活于Survivor的对象将被移动到老年代区间</li><li>老年代：主要保存生命周期长的对象，一般是一些老的对象</li><li>元空间：保存类信息、静态变量、常量、编译后的代码</li><li>1.7中有一个永久代，存储的和元空间的一样，移到本地内存的元空间中，防止内存溢出</li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java Virtual machine Stacks（Java虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821212320978.png" alt="image-20230821212320978" style="zoom:67%;"><h3 id="垃圾回收机制释放涉及栈内存？"><a href="#垃圾回收机制释放涉及栈内存？" class="headerlink" title="垃圾回收机制释放涉及栈内存？"></a>垃圾回收机制释放涉及栈内存？</h3><p>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放</p><h3 id="栈内存分配越大越好吗？"><a href="#栈内存分配越大越好吗？" class="headerlink" title="栈内存分配越大越好吗？"></a>栈内存分配越大越好吗？</h3><p>不一定，默认的栈内存通常为1024k</p><p>栈帧过大会导致线程数变少，例如，机器总内存为512M，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p><h3 id="方法内的局部变量是否线程安全？"><a href="#方法内的局部变量是否线程安全？" class="headerlink" title="方法内的局部变量是否线程安全？"></a>方法内的局部变量是否线程安全？</h3><ul><li>如果方法内部变量没有逃离方法的作用范围，它是线程安全的</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821213058556.png" alt="image-20230821213058556" style="zoom: 67%;"><h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><ul><li>栈帧过多导致栈内存溢出，典型问题：递归调用</li><li>栈帧过大导致内存溢出</li></ul><h3 id="堆栈的区别是什么？"><a href="#堆栈的区别是什么？" class="headerlink" title="堆栈的区别是什么？"></a>堆栈的区别是什么？</h3><ul><li>栈内存一般会用来存储局部变量和方法调用，当堆内存是用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会</li><li>栈内存是线程私有的，而堆内存是线程共有的</li><li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常<ul><li>栈空间不足：java.lang.StackOverFlowError</li><li>堆空间不足：java.lang.OutOfMemoryError</li></ul></li></ul><h2 id="解释一下方法区"><a href="#解释一下方法区" class="headerlink" title="解释一下方法区"></a>解释一下方法区</h2><ul><li>方法区（Method Area）是各个线程<strong>共享的内存区域</strong></li><li>主要存储类的信息、运行时常量池</li><li>虚拟机启动的时候创建，关闭虚拟机时释放</li><li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemroyError：Metaspace</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821214621900.png" alt="image-20230821214621900"></p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p><p><code>javap -v XXXXX.class</code> 查看字节码结构（类的基本信息、常量池、方法定义）</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>常量池是<code>*.class</code>文件中的，当该类被加载，它的常量池信息就会放入到运行时常量池，并把里面的符号地址变为真实地址</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821215852056.png" alt="image-20230821215852056"></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写性能高</p><h3 id="常规IO的数据拷贝流程"><a href="#常规IO的数据拷贝流程" class="headerlink" title="常规IO的数据拷贝流程"></a>常规IO的数据拷贝流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821220530317.png" alt="image-20230821220530317"></p><h3 id="NIO数据拷贝流程"><a href="#NIO数据拷贝流程" class="headerlink" title="NIO数据拷贝流程"></a>NIO数据拷贝流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821220554047.png" alt="image-20230821220554047"></p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些"></a>什么是类加载器，类加载器有哪些</h2><p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM</strong>中，从而让Java程序能够启动起来</p><p>类加载器有哪些：</p><ul><li>启动类加载器（BootStrap ClassLoader）：加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的库</li><li>扩展类加载器（ExtClassLoader）：主要加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录下的类</li><li>应用类加载器（AppClassLoader）：主要加载classPath下的类</li><li>自定义类加载器（CustomizeClassLoader）：自定义类继承ClassLoader，实现自定义类加载规则</li></ul><h2 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h2><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类</p><h3 id="JVM为什么采用双亲委派机制"><a href="#JVM为什么采用双亲委派机制" class="headerlink" title="JVM为什么采用双亲委派机制"></a>JVM为什么采用双亲委派机制</h3><ul><li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性</li><li>为了安全，保证类库API不会被修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行main函数，会出现异常，在类java.lang.String中找不到main方法</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822095626358.png" alt="image-20230822095626358"></p><p>这是由于双亲委派的机制，java.lang.String在启动类加载器得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库</p><h2 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h2><p>类从加载到虚拟机开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中验证、准备、解析这三个部分称为连接（linking）</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822100900726.png" alt="image-20230822100900726"></p><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822100944674.png" alt="image-20230822100944674"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822101007090.png" alt="image-20230822101007090"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822101025617.png" alt="image-20230822101025617"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822101048760.png" alt="image-20230822101048760"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822101110733.png" alt="image-20230822101110733"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822101125161.png" alt="image-20230822101125161"></p><ol><li>加载：查找和导入calss文件</li><li>验证：保证加载类的准确性</li><li>准备：为类变量分配内存并设置类变量初始值</li><li>解析：把类中的符号引用转化为直接引用</li><li>初始化：对类的静态变量，静态代码块执行初始化操作</li><li>使用：JVM开始从入口方法开始执行用户的程序代码</li><li>卸载：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象</li></ol><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="对象什么时候可以被垃圾器回收"><a href="#对象什么时候可以被垃圾器回收" class="headerlink" title="对象什么时候可以被垃圾器回收"></a>对象什么时候可以被垃圾器回收</h2><p>如果一个或多个对象没有任何引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则可能会被垃圾回收期回收</p><p>如果要定位什么是垃圾，有两种方式，第一个是<strong>引用计数法</strong>，第二个是<strong>可达性分析算法</strong></p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p><p><strong>当对象间出现了循环引用，引用计数法就会失效</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822103444492.png" alt="image-20230822103444492"></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822103809848.png" alt="image-20230822103809848" style="zoom:67%;"><p><strong>X，Y这两个节点是可回收的</strong></p><ul><li>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</li></ul><blockquote><p>哪些对象可以作为GC Root？</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></blockquote><h2 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h2><ul><li>标记清除算法</li><li>复制算法</li><li>标记整理算法</li></ul><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除</p><ol><li>根据可达性算法得出垃圾进行标记</li><li>对这些标记为可回收的内容进行垃圾回收</li></ol><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822110348929.png" alt="image-20230822110348929"></p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822110434226.png" alt="image-20230822110434226"></p><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有一定的影响</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822110648388.png" alt="image-20230822110648388"></p><p>优点：</p><ul><li>在垃圾对象多的情况下，效率较高</li><li>清理后，内存无碎片</li></ul><p>缺点：</p><p>分配的2块内存空间，在同一时刻，只能使用一半，内存使用率较低</p><h2 id="JVM中的分代回收"><a href="#JVM中的分代回收" class="headerlink" title="JVM中的分代回收"></a>JVM中的分代回收</h2><p>在java8时，堆被分为两份：<strong>新生代和老年代【1：2】</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822151246047.png" alt="image-20230822151246047"></p><p>对于新生代，内部又被划分为三个区域</p><ul><li>伊甸园区Eden，新生的对象都被分配到这里</li><li>幸存者区survivor（分为from和to）</li><li>Eden区，from区，to区【8：1：1】</li></ul><h3 id="分代收集算法的工作机制"><a href="#分代收集算法的工作机制" class="headerlink" title="分代收集算法的工作机制"></a>分代收集算法的工作机制</h3><ul><li>新建的对象，都会被分配到Eden区</li><li>当Eden内存不足，标记Eden和from（现阶段没有）的存活对象</li><li>将存活对象采用复制算法复制到to中，复制完毕后，Eden和from内存都会被释放</li><li>经过一段时间后Eden的内存又出现不足，标记Eden区域和to区域的存活对象，将存活对象复制到from区</li><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ul><h3 id="MinorGC、MixedGC、FullGC的区别是什么"><a href="#MinorGC、MixedGC、FullGC的区别是什么" class="headerlink" title="MinorGC、MixedGC、FullGC的区别是什么"></a>MinorGC、MixedGC、FullGC的区别是什么</h3><ul><li>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</li><li>Mixed GC 新生代+老年代部分区域的垃圾回收，G1收集器特有</li><li>FullGC：新生代+老年代完整垃圾回收，暂停时间长（STW），应尽量避免</li></ul><blockquote><p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成</p></blockquote><h2 id="JVM有哪些垃圾回收器"><a href="#JVM有哪些垃圾回收器" class="headerlink" title="JVM有哪些垃圾回收器"></a>JVM有哪些垃圾回收器</h2><p>在JVM中，实现了多种垃圾收集器，包括：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS（并发）垃圾收集器</li><li>G1垃圾收集器</li></ul><h3 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h3><p>Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p><ul><li>Serial 作用于新生代，采用复制算法</li><li>Serial Old作用于老年代，采用标记整理算法</li></ul><p>垃圾回收时，只有一个线程在工作，并且Java应用中的所有线程都要暂停（STW），等待垃圾回收的完成</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822155626011.png" alt="image-20230822155626011"></p><h3 id="并行垃圾收集器"><a href="#并行垃圾收集器" class="headerlink" title="并行垃圾收集器"></a>并行垃圾收集器</h3><p>Parallel New和Parallel Old是一个并行垃圾回收器，JDK8默认使用此垃圾回收器</p><ul><li>Parallel New作用于新生代，采用复制算法</li><li>Parallel Old作用于老年代，采用标记整理算法</li></ul><p>垃圾回收时，多个线程在工作，并且Java应用中的所有线程都有暂停（STW），等待垃圾回收完成</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822155900644.png" alt="image-20230822155900644"></p><p>CMS（并发）垃圾收集器</p><p>CMS全称Concurrent Mark Sweep，是一款<strong>并发</strong>的、使用<strong>标记清除算法</strong>的垃圾回收器，该回收器是<strong>针对老年代垃圾回收</strong>的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验好。其最大特点是在进行垃圾回收时，应用仍然能正常运行</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822160431039.png" alt="image-20230822160431039"></p><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><ul><li>应用于新生代和老年代，在<strong>JDK9之后默认使用G1</strong></li><li>划分成多个区域，每个区域都可以充当Eden、survivor、old、humongous，其中humongous专为大对象准备</li><li>采用复制算法</li><li>响应时间与吞吐量兼顾</li><li>分为三个阶段：新生代回收，并发标记，混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发Full GC</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822162208215.png" alt="image-20230822162208215" style="zoom: 67%;"><h3 id="Young-Collection（年轻代垃圾回收）"><a href="#Young-Collection（年轻代垃圾回收）" class="headerlink" title="Young Collection（年轻代垃圾回收）"></a>Young Collection（年轻代垃圾回收）</h3><ul><li>初始化时，所有区域都处于空闲状态</li><li>创建了一些对象，跳出一些空闲区域作为Eden区存储这些对象</li><li>当Eden区需要垃圾回收时，挑出一个空闲区作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li><li>随着时间流逝，Eden的内存又有不足</li><li>将Eden以及之前幸存区中存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822163325213.png" alt="image-20230822163325213" style="zoom:50%;"><h3 id="Young-Collection-Concurrent-Mark（年轻代垃圾回收-并发标记）"><a href="#Young-Collection-Concurrent-Mark（年轻代垃圾回收-并发标记）" class="headerlink" title="Young Collection + Concurrent Mark（年轻代垃圾回收+并发标记）"></a>Young Collection + Concurrent Mark（年轻代垃圾回收+并发标记）</h3><p>当老年代占用内存超过阈值（默认是45%）后，触发并发标记，这时无需暂停用户线程</p><ul><li>并发标记之后，会重新标记阶段解决漏标问题，此时需要暂停用户线程</li><li>这些都完成后就最大了老年代有哪些存活对象，随后进入<strong>混合收集阶段</strong>。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这就是Gabage First名称的由来）</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822164208464.png" alt="image-20230822164208464" style="zoom:50%;"><h3 id="Mixed-Collection（混合垃圾回收）"><a href="#Mixed-Collection（混合垃圾回收）" class="headerlink" title="Mixed Collection（混合垃圾回收）"></a>Mixed Collection（混合垃圾回收）</h3><p>混合收集阶段，参与复制的有Eden、survivor、old</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822164307410.png" alt="image-20230822164307410" style="zoom:50%;"><h2 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822170508159.png" alt="image-20230822170508159"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822170533328.png" alt="image-20230822170533328"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822170559049.png" alt="image-20230822170559049"></p><ul><li>强引用：只要所有GC Roots能找到，就不会被回收</li><li>软引用：需要配合SoftReference使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象</li><li>弱引用：需要配合WeakReference使用，只要进行了垃圾回收，就会把弱引用对象回收</li><li>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存</li></ul><h1 id="JVM实践"><a href="#JVM实践" class="headerlink" title="JVM实践"></a>JVM实践</h1><h2 id="JVM调优的参数可以在哪里设置参数值"><a href="#JVM调优的参数可以在哪里设置参数值" class="headerlink" title="JVM调优的参数可以在哪里设置参数值"></a>JVM调优的参数可以在哪里设置参数值</h2><ul><li><p>war包部署在tomcat中设置</p><p>修改<code>TOMCAT_HOME/bin/catalina.sh</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;-Xms512m -Xmx1024m&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>jar包部署在启动参数设置</p><p>通常在linux系统下直接加参数启动springboot项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms512m -Xmx1024m -jar xxxxx.jar  --spring.profiles.active=prod &amp;</span><br></pre></td></tr></table></figure><p>nohup：用于在系统后台不挂断地运行命令，退出终端不会影响程序地运行</p><p>参数 **&amp;**：让命令在后台执行，终端退出后命令依旧执行</p></li></ul><h2 id="JVM调优的参数"><a href="#JVM调优的参数" class="headerlink" title="JVM调优的参数"></a>JVM调优的参数</h2><p>对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型</p><p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">调优参数官网</a></p><ul><li>设置堆空间大小</li><li>虚拟机栈的设置</li><li>年轻代中Eden区和两个Survivor区的大小比例</li><li>年轻代晋升老年代阈值</li><li>设置垃圾回收收集器</li></ul><h3 id="设置堆空间大小"><a href="#设置堆空间大小" class="headerlink" title="设置堆空间大小"></a>设置堆空间大小</h3><p>设置堆的初始值大小和最大大小，为了防止垃圾收集器在初始大小、最大大小直之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小</span><br><span class="line">-Xmx：设置堆的最大大小</span><br><span class="line"></span><br><span class="line">-Xms：1024</span><br><span class="line">-XMs：1024k</span><br><span class="line">-Xms：1024m</span><br><span class="line">-Xms：1g</span><br><span class="line">不指定单位默认为字节</span><br><span class="line">指定单位，按照指定的单位设置</span><br></pre></td></tr></table></figure><p>堆空间设置多少合适？</p><ul><li>最大大小的默认值是物理内存的1&#x2F;4，初始大小是物理内存的1&#x2F;64</li><li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生STW，暂停用户线程</li><li>对内存大肯定是好的，但存在风险，假如发生了fullGC，它会扫描整个堆空间，暂停用户线程的时间长</li><li>设置参考推荐：尽量大，也要考察一下当前计算机其他程序的内存使用情况</li></ul><h3 id="虚拟机栈的设置"><a href="#虚拟机栈的设置" class="headerlink" title="虚拟机栈的设置"></a>虚拟机栈的设置</h3><p>虚拟机栈的设置：<strong>每个线程默认会开启1M的内存</strong>，用于存放栈帧、调用参数、局部变量等，但一般256k就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 对每个线程stack大小的调整，-Xss 128k</span><br></pre></td></tr></table></figure><h3 id="年轻代中Eden区和两个Survivor区的大小比例"><a href="#年轻代中Eden区和两个Survivor区的大小比例" class="headerlink" title="年轻代中Eden区和两个Survivor区的大小比例"></a>年轻代中Eden区和两个Survivor区的大小比例</h3><p>设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8：1：1.通过增大Eden区的大小，来减少YGC（新生代GC）发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况区调优</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XXSurvivorRatio=8，表示年轻代中的分配比率：survivor：Eden=2:8</span><br></pre></td></tr></table></figure><h3 id="年轻代晋升老年代阈值"><a href="#年轻代晋升老年代阈值" class="headerlink" title="年轻代晋升老年代阈值"></a>年轻代晋升老年代阈值</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold=threshold</span><br></pre></td></tr></table></figure><ul><li>默认为15</li><li>取值范围0-15</li></ul><h3 id="设置垃圾回收收集器"><a href="#设置垃圾回收收集器" class="headerlink" title="设置垃圾回收收集器"></a>设置垃圾回收收集器</h3><p>通过增大吞吐量提供系统性能，可以通过设置并行垃圾回收收集器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><h2 id="JVM调优的工具"><a href="#JVM调优的工具" class="headerlink" title="JVM调优的工具"></a>JVM调优的工具</h2><ul><li><p>jsp</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822202158774.png" alt="image-20230822202158774" style="zoom: 50%;"></li><li><p>jstack</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822202226779.png" alt="image-20230822202226779" style="zoom:50%;"></li><li><p>jmap</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822202254603.png" alt="image-20230822202254603" style="zoom:50%;"></li><li><p>jstat</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822202634522.png" alt="image-20230822202634522"></p></li><li><p>jconsole</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822202711692.png" alt="image-20230822202711692"></p></li><li><p>VisualVM</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822202749462.png" alt="image-20230822202749462"></p></li></ul><h2 id="Java内存泄漏的排查思路"><a href="#Java内存泄漏的排查思路" class="headerlink" title="Java内存泄漏的排查思路"></a>Java内存泄漏的排查思路</h2><p>内存泄漏通常指堆内存，通常是指一些大对象不被回收的情况</p><ol><li><p>通过jmap指定打印他的内存快照dump（dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中）</p><ul><li><p>使用jmap命令获取运行中程序的dump文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heap.hprof pid</span><br></pre></td></tr></table></figure></li><li><p>使用vm参数获取dump文件</p><p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印运行中的程序，所有建议通过参数的方式生成dump文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/xxx/xxx/</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822204814447.png" alt="image-20230822204814447" style="zoom:50%;"></li><li><p>通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822204903222.png" alt="image-20230822204903222" style="zoom:50%;"></li><li><p>找到对应的代码，通过阅读上下文的情况，进行修复即可</p></li></ol><h2 id="CPU飙高排查方案与思路"><a href="#CPU飙高排查方案与思路" class="headerlink" title="CPU飙高排查方案与思路"></a>CPU飙高排查方案与思路</h2><ol><li><p>使用top命令查看占用cpu情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822210221644.png" alt="image-20230822210221644"></p></li><li><p>通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图为40940进程</p></li><li><p>查看进程中的线程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 40940</span><br></pre></td></tr></table></figure><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822210411894.png" alt="image-20230822210411894" style="zoom:67%;"><p>通过以上分析，在进程40940中的线程40950占cpu较高</p></li><li><p>可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 40940 此处是进程id</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230822210619142.png" alt="image-20230822210619142"></p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本次关于JVM常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程面试篇</title>
      <link href="/2023/08/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。</p><p><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820085342610.png" alt="image-20230820085342610"></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个线程就是一个指令流， 将指令流中的一条条指令以一定的顺序交给CPU执行</p><p>一个进程之内可以分为一到多个线程</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820085505955.png" alt="image-20230820085505955"></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）</li></ul><h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><h3 id="单核CPU"><a href="#单核CPU" class="headerlink" title="单核CPU"></a>单核CPU</h3><ul><li>单核CPU下线程实际还是串行执行的</li><li>操作系统中有一个组件叫做任务调度器，将CPU的时间片（windows下时间片最小约为15毫秒）分给不同的程序使用，只有由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。</li><li>总结：<strong>微观串行，宏观并行</strong></li><li><strong>一般会将这种线程轮流使用CPU的做法称呼为并发（concurrent）</strong></li></ul><h3 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h3><p>每个核（core）都可以调度运行线程，这个时候线程可以是并行的</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ul><li>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</li><li>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li>继承Thread类</li><li>实现runnable接口</li><li>实现Callable接口</li><li>线程池创建线程</li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.printin(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建MyThread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.printin(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">       <span class="comment">//建MyRunnable对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="comment">//创建Thread对象</span></span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        <span class="comment">//调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.printin(Thread.currentThread().getName())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> ExecutionException,InterruptedException&#123;</span><br><span class="line">        <span class="comment">//创建MyCallable对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">//创建FutureTask</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(mc);</span><br><span class="line">        <span class="comment">//创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        <span class="comment">//调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//调用t的get方法获取执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池创建线程（项目使用）"><a href="#线程池创建线程（项目使用）" class="headerlink" title="线程池创建线程（项目使用）"></a>线程池创建线程（项目使用）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecutors</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.printIn(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池对象</span></span><br><span class="line">        ExecutorService threadPool Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyExecutors</span>());</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runable和callable有什么区别"><a href="#runable和callable有什么区别" class="headerlink" title="runable和callable有什么区别"></a>runable和callable有什么区别</h3><ul><li>Runnable接口run方法没有返回值</li><li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li></ul><h3 id="线程的run-和start-有什么区别"><a href="#线程的run-和start-有什么区别" class="headerlink" title="线程的run()和start()有什么区别"></a>线程的run()和start()有什么区别</h3><p>start()：用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start()方法只能被调用一次</p><p>run()：封装了被线程执行的代码，调用就跟调用普通方法一样，可以被多次调用</p><h2 id="线程包括哪些状态，状态之间是如何变化的"><a href="#线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的"></a>线程包括哪些状态，状态之间是如何变化的</h2><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程的状态可以参考JDK中的Thread类中的枚举State</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span>&#123;</span><br><span class="line">    <span class="comment">//尚未启动的线程的线程状态</span></span><br><span class="line">    NEW,</span><br><span class="line">   <span class="comment">//可运行线程的线程状态。</span></span><br><span class="line">    RUNNABLE.</span><br><span class="line">    <span class="comment">//线程阻塞等待监视器锁的线程状态。</span></span><br><span class="line">    BLOCKED.</span><br><span class="line">    <span class="comment">//等待线程的线程状态</span></span><br><span class="line">    WAITING.</span><br><span class="line">    <span class="comment">//具有指定等待时间的等待线程的线程状态</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">//已终止线程的线程状态。线程已完成执行</span></span><br><span class="line">    TERMINATED:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态之间如何切换"><a href="#状态之间如何切换" class="headerlink" title="状态之间如何切换"></a>状态之间如何切换</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820100122932.png" alt="image-20230820100122932"></p><ul><li>创建线程对象是<strong>新建状态</strong></li><li>调用了start()方法转变为<strong>可执行状态</strong></li><li>线程获得了CPU的执行权，执行结束是<strong>终止状态</strong></li><li>在可执行状态中，如果没有获取到CPU的执行权，可能会切换其他状态<ul><li>如果没有获取锁（synchronized或lock）进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li><li>如果线程调用了wait()方法进入<strong>等待状态</strong>，其他线程调用notify()唤醒后可切换为可执行状态</li><li>如果线程调用了sleep(50)方法，进入<strong>计时等待状态</strong>，到时间后可切换为可执行状态</li></ul></li></ul><h2 id="新建三个线程，如何保证它们顺序执行"><a href="#新建三个线程，如何保证它们顺序执行" class="headerlink" title="新建三个线程，如何保证它们顺序执行"></a>新建三个线程，如何保证它们顺序执行</h2><p>可以使用线程中的<code>join</code>方法解决</p><p>join()：等待线程运行结束</p><p>t.join()：阻塞调用此方法的线程进入<strong>timed_waiting</strong>直到线程<code>t</code>执行完成后，此线程再继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    t1.join(); <span class="comment">//加入线t1，只有t1线程执行完毕以后，再次执行该线程</span></span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    t2.join(); <span class="comment">//加入线t2，只有t2线程执行完毕以后，再次执行该线程</span></span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure><h2 id="notify-和notifyAll-有什么区别"><a href="#notify-和notifyAll-有什么区别" class="headerlink" title="notify()和notifyAll()有什么区别"></a>notify()和notifyAll()有什么区别</h2><p>notifyAll：唤醒所有wait线程</p><p>notify：只随机唤醒一个wait线程</p><h2 id="在java中wait和sleep方法的不同"><a href="#在java中wait和sleep方法的不同" class="headerlink" title="在java中wait和sleep方法的不同"></a>在java中wait和sleep方法的不同</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p><code>wait()、wait(long)、sleep(long)</code>的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>方法归属不同<ul><li>sleep(long)是Thread的静态方法</li><li>而wait()、wait(long)都是Object的成员方法，每个对象都有</li></ul></li><li>醒来时时机不同<ul><li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li><li>wait(long)和wait()还可以被notify唤醒，wait()如果吧唤醒就一直等待下去</li><li>它们都可以被打断唤醒</li></ul></li><li>锁特性不同（重点）<ul><li>wait方法的调用必须先获取wait对象的锁（与synchorized配合使用），而sleep则无此限制</li><li>wait方法执行后会释放对象锁，允许其他线程获得该对象锁（我放弃cpu，但你们还可以用）</li><li>而sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu，你们也用不了）</li></ul></li></ol><h2 id="如何停止一个正在运行的线程"><a href="#如何停止一个正在运行的线程" class="headerlink" title="如何停止一个正在运行的线程"></a>如何停止一个正在运行的线程</h2><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li><li>使用stop方法强行终止（不推荐，方法已作废）</li><li>使用interrupt方法中断线程<ul><li>打断阻塞的线程（sleep、wait、join）的线程，线程会抛出InterruptedException异常</li><li>打断正常异常，可以根据打断状态来标记是否退出线程</li></ul></li></ul><h2 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>synchronized（对象锁）采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程再想获取这个对象锁时就会被阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketDemo</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object lock <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> ticketNum <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到一张票，剩余：&quot;</span>+ticketNum);</span><br><span class="line">            ∥非原子性操作</span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        TicketDemo ticketDemo <span class="keyword">new</span> <span class="title class_">TicketDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        ticketDemo.getTicket()</span><br><span class="line">        &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Monitor重量级锁"><a href="#Monitor重量级锁" class="headerlink" title="Monitor重量级锁"></a>Monitor重量级锁</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820144743712.png" alt="image-20230820144743712"></p><p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象的Mark Word中就被设置指向Monitor对象的指针</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820145135300.png" alt="image-20230820145135300"></p><ul><li>Owner：存储当前获取锁的线程，只能有一个线程可以获取</li><li>EntryList：关联没有强到锁的线程，处于Blocked状态的线程</li><li>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</li></ul><p>Monitor实现的锁属于重量级锁，什么是锁升级？</p><ul><li>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换、成本较高、性能较低</li><li>在JDK1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来堵塞性能开销问题</li></ul><h4 id="对象的内存结构"><a href="#对象的内存结构" class="headerlink" title="对象的内存结构"></a>对象的内存结构</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（header）、实例数据（Instance Data）和对齐填充</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820152149871.png" alt="image-20230820152149871"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820152337070.png" alt="image-20230820152337070"></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">       <span class="comment">//同步块A</span></span><br><span class="line">       method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820153609143.png" alt="image-20230820153609143"></p><p><strong>加锁流程</strong></p><ol><li>在线程栈中创建一个Lock Record，将其obj字段指向锁对象</li><li>通过CAS指令将Lock Record的地址存储在对象头mark word中，如果处于无锁状态则修改成功，代表该线程获得了轻量级锁</li><li>如果是当前线程已经持有了该锁，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用</li><li>如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁</li></ol><p><strong>解锁过程</strong></p><ol><li>遍历线程栈，找到所有obj字段等于等于当前锁对象的Lock Record</li><li>如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue</li><li>如果Lock Record的Mark Word不为null，则利用CAS指令将对象头的mark word恢复成无锁状态。如果失败则膨胀为重量级锁</li></ol><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入依然需要执行CAS操作</p><p>Java 6中引入了偏向锁来进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头中，之后发现这个线程ID加锁自己的表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有.</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820155322783.png" alt="image-20230820155322783"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只能被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820155800324.png" alt="image-20230820155800324"></p><p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p><h2 id="JMM（Java内存模型）"><a href="#JMM（Java内存模型）" class="headerlink" title="JMM（Java内存模型）"></a>JMM（Java内存模型）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820171121826.png" alt="image-20230820171121826"></p><ul><li>JMM（Java Memory Model）Java内存模型，定义了共享内存中多线程读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li><li>JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</li><li>线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS的全称是：Compare And Swap（比较再交换），它体现了一种乐观锁的思想，在无锁的情况下保证线程操作共享数据的原子性</p><p>在JUC（java.util.concurrent）包下实现的很多类都用到了CAS操作</p><ul><li>AbstractQueuedSynchronized（AQS框架）</li><li>AtomicXXX类</li></ul><h3 id="CAS数据交换流程"><a href="#CAS数据交换流程" class="headerlink" title="CAS数据交换流程"></a>CAS数据交换流程</h3><p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值相同时，将内存值修改为B并返回True，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次重试，直到成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自旋锁</span></span><br><span class="line"><span class="comment">//需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">int</span> 旧值A = 共享变量V;</span><br><span class="line">    <span class="type">int</span> 结果B = 旧值 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(compareAndSwap(旧值，结果，共享变量V))&#123;</span><br><span class="line">        <span class="comment">//成功，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为没有加锁，所有线程不会陷入阻塞，效率较高</li><li>如果竞争激烈，重试频繁发生，效率会受影响</li></ul><h3 id="CAS底层实现"><a href="#CAS底层实现" class="headerlink" title="CAS底层实现"></a>CAS底层实现</h3><p>CAS底层依赖于一个Unsafe类来直接调用操作系统底层的CAS指令</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没有关系，我吃点亏再重试呗</li><li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上锁了你们都别想改，我改完了解锁，你们才有机会</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>一旦一个共享变量（类的成员变量、类得静态成员变量）被volatile修饰后，那么就具备了两层语义：</p><ul><li>保证线程间得可见性</li><li>禁止进行指令重排序</li></ul><h3 id="保证线程间得可见性"><a href="#保证线程间得可见性" class="headerlink" title="保证线程间得可见性"></a>保证线程间得可见性</h3><p>用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另外一个线程可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> stop <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String]args)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:modify stop to true...&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+stop);</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stop)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.printin(<span class="string">&quot;stopped...c:&quot;</span>+i);</span><br><span class="line">    &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>上面的的代码会出现一些问题：虽然第二个线程中输出stop&#x3D;true，但是while循环不会终止</p><p>问题分析：主要是因为在JVM虚拟机中有一个JIT（即时编译器）给代码做了优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变成</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案一：在程序运行的时候加入vm参数**<code>-Xint</code><strong>表示禁用即时编译器，</strong>不推荐**，得不偿失（其他程序还要使用）</p><p>解决方案二：在修饰stop变量的时候加上<strong>volatile</strong>，当前告诉JIT，不要对volatile修饰的变量做优化</p><h3 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h3><p>用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820203041124.png" alt="image-20230820203041124"></p><p><strong>在变量上添加volatile，禁止指令重排序，则可以解决问题</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820203719443.png" alt="image-20230820203719443"></p><p>volatile使用技巧：</p><ul><li>写变量让volatile修饰的变量在写代码的最后位置</li><li>读变量让volatile修饰的变量在写代码最开始位置</li></ul><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS全称是AbstractQueuedSynchronizer，即抽象队列同步器。它是构造锁或者其他同步组件的基础框架</p><p>AQS与Synchronized的区别：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820211036658.png" alt="image-20230820211036658"></p><p>AQS常见的实现类：</p><ul><li>ReentrantLock    阻塞式锁</li><li>Semaphore         信号量</li><li>CountDownLatch 倒计时锁</li></ul><h3 id="AQS-基本工作机制"><a href="#AQS-基本工作机制" class="headerlink" title="AQS-基本工作机制"></a>AQS-基本工作机制</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820211448002.png" alt="image-20230820211448002"></p><p>线程抢到了资源会将state设置为1 表示有锁，其他线程进来发现有锁就只能进入FIFO队列进行等待</p><p>那么问题来了<strong>多个线程共同去抢这个资源如何保证原子性</strong>？</p><p><strong>CAS设置state状态，保证操作的原子性</strong></p><h3 id="AQS是公平锁还是非公平锁"><a href="#AQS是公平锁还是非公平锁" class="headerlink" title="AQS是公平锁还是非公平锁"></a>AQS是公平锁还是非公平锁</h3><p>他的实现类可以是公平锁也可以是非公平锁</p><ul><li>新的线程与队列中的线程共同来抢资源，是非公平锁</li><li>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock翻译过来是可重入锁，相当于synchronized它具备以下特点：</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置公平锁</li><li>支持多个条件变量</li><li>与synchronized一样，都支持重入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁对象</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820213430538.png" alt="image-20230820213430538"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820213449542.png" alt="image-20230820213449542"></p><ul><li>线程来枪锁后使用CAS的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</li><li>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</li><li>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</li><li>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</li></ul><h2 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h2><ul><li><strong>语法层面</strong><ul><li>synchronized是关键字，源码在jvm中，用c++语言实现</li><li>Lock是接口，源码由JDK提供，用Java语言实现</li><li>使用synchronized时，退出同步代码块锁会字段释放，而使用Lock时，需要手动调用unlock方法释放锁</li></ul></li><li><strong>功能层面</strong><ul><li>二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能</li><li>Lock提供了许多synchronized不具备的功能，例如公平锁、可打断、可超时、多条件变量</li><li>Lock有适合不同场景的实现，如ReentrantLock，ReentrantReadWriteLock（读写锁）</li></ul></li><li><strong>性能层面</strong><ul><li>在没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁、性能不赖</li><li>在竞争激烈时，Lock的实现通常会提供更好的性能</li></ul></li></ul><h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><p>死锁：一个线程需要同时获取多把锁，这时就容易发生死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Object A <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">Object B <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;操作..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;操作..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>此时程序并没有结束，这种现象的就是死锁现象…线程t1持有A的锁等待获取B锁，线程t2持有B的锁等待获取A的锁。</p><h3 id="进行死锁诊断"><a href="#进行死锁诊断" class="headerlink" title="进行死锁诊断"></a>进行死锁诊断</h3><p>当程序出现了死锁现象，可以可以使用JDK自带的工具：jps和jstack</p><ul><li>jps：输出JVM中运行的进程状态信息</li><li>jstack：查看java进程内线程的堆栈信息</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820220852400.png" alt="image-20230820220852400"></p><p>其他解决工具，可视化工具</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820221309153.png" alt="image-20230820221309153"></p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap是一种线程安全的高效Map集合</p><p>底层数据结构：</p><ul><li>JDK1.7底层采用分段的数组+链表实现</li><li>JDK1.8采用的数据结构跟HashMap1.8结构一样，数组+链表&#x2F;红黑二叉树</li></ul><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820221704919.png" alt="image-20230820221704919"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820221713035.png" alt="image-20230820221713035"></p><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230820221917470.png" alt="image-20230820221917470"></p><p><strong>加锁的方式区别：</strong></p><ul><li>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock</li><li>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑树的首节点，相对Segment分段锁细粒度更细，性能更好</li></ul><h2 id="导致并发程序出现问题的根本原因"><a href="#导致并发程序出现问题的根本原因" class="headerlink" title="导致并发程序出现问题的根本原因"></a>导致并发程序出现问题的根本原因</h2><ul><li>原子性     synchronized、lock</li><li>内存可见性  volatile、synchronized、lock</li><li>有序性  volatile</li></ul><h2 id="线程池的核心参数和执行原理"><a href="#线程池的核心参数和执行原理" class="headerlink" title="线程池的核心参数和执行原理"></a>线程池的核心参数和执行原理</h2><h3 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                    TimeUnit unit,</span></span><br><span class="line"><span class="params">                    BlockingQueue&lt;Runnable&gt;workQueue,</span></span><br><span class="line"><span class="params">                    ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                    RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li>corePoolSize核心线程数目</li><li>maximumPoolSize     最大线程数目&#x3D;（核心线程+紧急线程的最大数目）</li><li>keepAliveTime      生存时间-救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit     时间单位-救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue     当没有空闲核心线程时，新来的任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory     线程工厂-可以制定线程对象的创建，例如设置线程名字，是否守护线程等</li><li>handler  拒绝策略-当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</li></ul><h3 id="线程池的执行原理"><a href="#线程池的执行原理" class="headerlink" title="线程池的执行原理"></a>线程池的执行原理</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821085657246.png" alt="image-20230821085657246"></p><h2 id="线程池中有哪些常见的阻塞队列"><a href="#线程池中有哪些常见的阻塞队列" class="headerlink" title="线程池中有哪些常见的阻塞队列"></a>线程池中有哪些常见的阻塞队列</h2><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p><ul><li><strong>ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO</strong></li><li><strong>LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO</strong></li><li>DelayedWorkQueue：是一个优先级队列，它可以保证每次出对的任务都是当前队列中执行时间最靠前的</li><li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移除操作</li></ul><h3 id="ArrayBlockingQueue和LinkedBlockingQueue的区别"><a href="#ArrayBlockingQueue和LinkedBlockingQueue的区别" class="headerlink" title="ArrayBlockingQueue和LinkedBlockingQueue的区别"></a>ArrayBlockingQueue和LinkedBlockingQueue的区别</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821090709942.png" alt="image-20230821090709942"></p><h2 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="headerlink" title="如何确定核心线程数"></a>如何确定核心线程数</h2><ul><li><p>IO密集型任务</p><p>一般来说：文件读写、DB读写、网络请求等   <strong>（核心线程数大小设置为2N+1）</strong></p></li><li><p>CPU密集型任务</p><p>一般来说：计算型代码、Bitmap转换、Gson转换等   <strong>（核心线程数大小设置为N+1）</strong></p></li></ul><p>查看机器的CPU核数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessorc()</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>高并发、任务执行时间短  ——&gt; <strong>（CPU核数+1）</strong>，减少线程上下文切换</li><li>并发不高、任务执行时间长<ul><li>IO密集型任务 ——&gt; <strong>（CPU核数*2 + 1）</strong></li><li>计算密集型任务 ——&gt;  <strong>（CPU核数 + 1）</strong></li></ul></li><li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据能否做缓存是第一步，增加服务器是第二步，至于线程池的设置，参考第2点</li></ul><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><p> 在java.util.conturrent.Executor类中提供了大量创建连接池的静态方法，常见就有四种：</p><ol><li><p>创建使用固定线程数的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数与最大线程数一样，没有救急线程</li><li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.Max_VALUE</li></ul></li></ol><p>​<strong>适用于任务量已知，相对耗时的任务</strong></p><ol start="2"><li><p>单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO）执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数和最大线程数都是1</li><li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.Max_VALUE</li></ul></li></ol><p>​<strong>适用于按照顺序执行的任务</strong></p><ol start="3"><li><p>可缓存线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数为0</li><li>最大线程数是Integer.Max_VALUE</li><li>阻塞队列为SynchronizedQueue：不存储元素的阻塞队列，每个插入都必须等待一个移除操作</li></ul></li></ol><p>​<strong>适合任务数比较密集，但每个任务执行时间较短的情况</strong></p><ol start="4"><li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                                   RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="为什么不建议用Executors创建线程池"><a href="#为什么不建议用Executors创建线程池" class="headerlink" title="为什么不建议用Executors创建线程池"></a>为什么不建议用Executors创建线程池</h2><p>参考阿里开发手册《Java开发手册-嵩山版》</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821144533569.png" alt="image-20230821144533569"></p><h2 id="线程池的常见使用场景"><a href="#线程池的常见使用场景" class="headerlink" title="线程池的常见使用场景"></a>线程池的常见使用场景</h2><h3 id="批量导入-CountDownLatch"><a href="#批量导入-CountDownLatch" class="headerlink" title="批量导入-CountDownLatch"></a>批量导入-CountDownLatch</h3><p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有的线程完成倒计时（一个或多个线程，等待其他多个线程完成某件事情之后才能执行）</p><ul><li>其中构造参数用来初始化等待计数值</li><li>await（）用来等待计数归零</li><li>countDown（）用来让计数减一</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821151233795.png" alt="image-20230821151233795"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821151257373.png" alt="image-20230821151257373"></p><h3 id="数据汇总"><a href="#数据汇总" class="headerlink" title="数据汇总"></a>数据汇总</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821152451273.png" alt="image-20230821152451273"></p><ul><li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）没有依赖关系，就可以使用线程池+future来提升性能</li><li>报表汇总</li></ul><h3 id="异步调用（线程池）"><a href="#异步调用（线程池）" class="headerlink" title="异步调用（线程池）"></a>异步调用（线程池）</h3><p>为了避免下一级方法影响上一级方法（性能考虑），可以使用异步线程调用下一个方法（不需要下一级方法返回值），可以提升方法响应时间</p><h3 id="如何控制某个方法允许并发访问线程的数量"><a href="#如何控制某个方法允许并发访问线程的数量" class="headerlink" title="如何控制某个方法允许并发访问线程的数量"></a>如何控制某个方法允许并发访问线程的数量</h3><p>Semaphore信号量，是JUC包下的一个&#x3D;工具类，底层是AQS，我们可以通过其限制执行的线程数量</p><p>使用场景：</p><p>通常用于那些资源有明确访问数量限制的场景，常用于限流</p><p>Semaphore使用步骤：</p><ul><li>创建Semaphore对象，可以给一个容量</li><li>semaphore.acquire()：请求一个信号量，这个时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到线程释放了信号量）</li><li>semaphore.release()：释放一个信号量，此时信号量个数+1</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是多线程对于解决线程安全的一个操作类，它会<strong>为每个线程都分配一个独立的线程副本</strong>从而解决了变量并发访问冲突的问题。ThreadLocal同时实现了线程内的资源共享</p><p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的Connection上进行数据库的操作，避免A线程关闭了B线程的连接</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>set(value)：设置值</li><li>get()：获取值</li><li>remove()：清除值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;String&gt;threadLocal <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        String name Thread.currentThread().getName();</span><br><span class="line">        threadLocal.set(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        print(name);</span><br><span class="line">        System.out.println(name +<span class="string">&quot;-after remove:&quot;</span>threadLocal.get());</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    String name Thread.currentThread().getName();</span><br><span class="line">    threadLocal.set(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">    print(name);</span><br><span class="line">    System.out.printin(name +<span class="string">&quot;-after remove &quot;</span>threadLocal.get());</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start():</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">   <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">    System.out.println(str +<span class="string">&quot;:&quot;</span>threadLocal.get());</span><br><span class="line">  <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程值操作自己内部的值，从而实现线程数据隔离</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821160210279.png" alt="image-20230821160210279"></p><p><strong>set方法</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821160512073.png" alt="image-20230821160512073"></p><p><strong>get方法&#x2F;remove方法</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821160602969.png" alt="image-20230821160602969"></p><h3 id="ThreadLocal-内存泄漏"><a href="#ThreadLocal-内存泄漏" class="headerlink" title="ThreadLocal-内存泄漏"></a>ThreadLocal-内存泄漏</h3><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p><ul><li><p>强引用：最为普通的引用方式，表示一个对象处于<strong>有用且必须</strong>的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure></li><li><p>弱引用：表示一个对象处于<strong>可能有用非必须</strong>的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现就被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">weakReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(user);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230821161520253.png" alt="image-20230821161520253"></p><ul><li>ThreadLocal可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免竞争引发的线程安全问题</li><li>ThreadLocal同时实现了线程内的资源共享</li><li>每个线程内有一个ThreadLocalMap类型的成员变量，用来存储资源对象<ul><li>调用set方法，就是以ThreadLocal自己作为Key，资源对象作为value，放入当前线程的ThreadLocalMap集合中</li><li>调用get方法，，就是以ThreadLocal自己作为Key，到当前线程中查找关联的资源值</li><li>调用remove方法，，就是以ThreadLocal自己作为Key，移除当前线程关联的资源值</li></ul></li><li>ThreadLocal内存泄漏：ThreadLocalMap中的key是弱引用，值为强引用；key会被GC释放内存，关联value的内存并不会释放。建议主动remove释放key、value</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次关于Java并发编程的一些常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合面试篇</title>
      <link href="/2023/08/19/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/19/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Java集合框架体系"><a href="#Java集合框架体系" class="headerlink" title="Java集合框架体系"></a>Java集合框架体系</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818124813091.png" alt="image-20230818124813091"></p><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818130429776.png" alt="image-20230818130429776"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818130443623.png" alt="image-20230818130443623"></p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818130601158.png" alt="image-20230818130601158"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（Array）是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型数据</strong>的<strong>线性</strong>数据结构</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818190658331.png" alt="image-20230818190658331"></p><h3 id="查找的时间复杂度"><a href="#查找的时间复杂度" class="headerlink" title="查找的时间复杂度"></a>查找的时间复杂度</h3><ul><li>随机（通过下标）查询的时间复杂度是O（1）</li><li>查找元素（未知下标）的时间复杂度是O（n）</li><li>查找元素（未知下标蛋排序）通过二分查找的时间复杂度是O（logn）</li></ul><h3 id="插入和删除时间复杂度"><a href="#插入和删除时间复杂度" class="headerlink" title="插入和删除时间复杂度"></a>插入和删除时间复杂度</h3><p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均时间复杂度为O（n）</p><h2 id="ArrayList的底层的实现原理是什么"><a href="#ArrayList的底层的实现原理是什么" class="headerlink" title="ArrayList的底层的实现原理是什么"></a>ArrayList的底层的实现原理是什么</h2><ul><li>ArrayList底层是用动态数组实现的</li><li>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li><li>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</li><li>ArrayList在添加数据的时候<ul><li>确保数组以使用长度（size）加一之后足够存下下一个数据</li><li>计算数组的容量，如果当前数组已使用长度+1后大于当前数组长度，则调用grow方法扩容（原来的1.5倍）</li><li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</li><li>返回添加成功布尔值</li></ul></li></ul><h2 id="数组和List之间的转换"><a href="#数组和List之间的转换" class="headerlink" title="数组和List之间的转换"></a>数组和List之间的转换</h2><ul><li>数组转List，使用JDK中Java.util。Arrays工具类中的asList方法</li><li>List转数组，使用List的toArray方法。无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该数组对象</li></ul><p><strong>用Arrays.asList转List后，如果修改了数组内容，list受影响吗？</strong></p><p>Arrays.asLIst转换List之后，如果修改了数组的内容，list会受影响，因为它底层使用的Arrays类中的一个内部类ArrayList来构造集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p><blockquote><p>详细见作者之前的<a href="https://zengjiahao0531.com/2023/07/20/Arrays-asList-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/">Arrays-asList避坑指南</a></p></blockquote><p><strong>List用toArray转数组后，如果修改了List内容，数组会受影响吗？</strong></p><p>list调用toArray转数组后，如果修改了list内容，数组不会受影响，当调用了toArray以后，在底层它是进行了数组的拷贝，跟原来的元素就没有什么关系了，使用即使list修改了以后，数组不受影响</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表和双向链表的区别是什么"><a href="#单向链表和双向链表的区别是什么" class="headerlink" title="单向链表和双向链表的区别是什么"></a>单向链表和双向链表的区别是什么</h3><ul><li>单向链表只有一个方向，结点只有一个后继指针next</li><li>双向链表它支持两个方向，每个节点不止有一个后继指针next指向后面的节点，还有一个前驱指针prev指向前面的节点</li></ul><h3 id="链表操作数据的时间复杂度"><a href="#链表操作数据的时间复杂度" class="headerlink" title="链表操作数据的时间复杂度"></a>链表操作数据的时间复杂度</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818200008633.png" alt="image-20230818200008633"></p><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><ul><li>ArrayList是动态数组的数据结构实现</li><li>LinkedList是双向链表的数据结构实现</li></ul><h3 id="操作数据效率"><a href="#操作数据效率" class="headerlink" title="操作数据效率"></a>操作数据效率</h3><ul><li>ArrayList按照下标查询的时间复杂度O（1）【内存是连续的，根据寻址公式】，LinkedList不支持下标查询</li><li>查找（未知索引）：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O（n）</li><li>新增和删除<ul><li>ArrayList尾部插入和删除，时间复杂度是O（1）；其他部分增删需要挪动数组，时间复杂度是O（n）</li><li>LinkedList头尾节点增删时间复杂度是O（1），其他需要遍历链表，时间复杂度是O（n）</li></ul></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<strong>左子节点和右子节点</strong>。不过二叉树并不要求每个节点都有两个子节点。二叉树每个节点的左子树和右子树也分别满足二叉树的定义</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul><li>二叉搜素树（Binary Search Tree，BST）又名二叉查找树，有序二叉树或排序二叉树，是二叉树中比较常用的一种类型</li><li>二叉搜素树要求，在树中的任意一个节点，其左子树的每个节点的额值，都要小于这个节点的值，而右子树的值都有大于这个节点的值、</li><li>没有键值相等的节点</li><li>通常情况下二叉树的搜素时间复杂度是O（logn）</li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树（Red Black Tree）：也是一种自平衡的二叉搜素树（BST），之前叫做平衡二叉B树（Symmetric Binary B-Tree）</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818210051788.png" alt="image-20230818210051788" style="zoom:67%;"><p><strong>性质：</strong></p><ul><li>节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>叶子节点都是黑色的空节点</li><li>红黑树中红色节点的子节点都是黑色</li><li>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</li></ul><p><strong>在添加或删除节点的时候，如果不符合这些性质会发送旋转，以达到所有的性质</strong></p><h4 id="红黑树的复杂度"><a href="#红黑树的复杂度" class="headerlink" title="红黑树的复杂度"></a>红黑树的复杂度</h4><ul><li><p>查找：</p><p>红黑树也是BST树，查找的时间复杂度为：<strong>O（log n）</strong></p></li><li><p>添加：</p><p>添加先要从根节点开始找到元素添加的位置，时间复杂度O（log n）</p><p>添加完成后涉及到O（1）的旋转调整操作</p><p>顾整体的复杂度为：<strong>O（log n）</strong></p></li><li><p>删除：</p><p>首先先要从根节点开始找到元素删除的位置，时间复杂度O（log n）</p><p>删除完成后涉及到O（1）的旋转调整操作</p><p>顾整体的复杂度为：<strong>O（log n）</strong></p></li></ul><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p><p>散列表（Hash Table）又名<strong>哈希表</strong>&#x2F;Hash表，是根据<strong>键（key）直接访问在内存存储位置值（Value）</strong>的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818212235229.png" alt="image-20230818212235229"></p><p><strong>将键（key）映射为数组下标的函数叫做散列函数。</strong>可以表示为：hashValue&#x3D;hash(key)</p><p>散列函数的基本要求：</p><ul><li>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标</li><li>如果key1&#x3D;&#x3D;key2，那么经过hash后得到的哈希值也必相同：hash（key1）&#x3D;&#x3D; hash（key2）</li><li><strong>如果key1！&#x3D; key2，那么经过hash后得到的哈希值也必不相同：hash（key1）！&#x3D; hash（key2）</strong></li></ul><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>实际情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎不可能的，即使著名的MD5、SHA等哈希算法也无法避免这个情况，这就是散列冲突（哈希冲突、哈希碰撞，就是指多个key映射到同一个数组下标位置）</p><h3 id="拉链法（链表法）"><a href="#拉链法（链表法）" class="headerlink" title="拉链法（链表法）"></a>拉链法（链表法）</h3><p>在散列表中，数组的每个下标位置我们可以称为<strong>桶（bucket）</strong>或<strong>槽（slot）</strong>，每个桶（槽）会对应一条链表，所有散列值相同的元素我们都会放到相同槽位对应的链表中</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是O（1）</li><li>当查找、删除一个元素时，我们同样可以通过散列函数计算出对应的槽，然后遍历链表查找或删除<ul><li>平均情况下基于链表法解决冲突时查询的时间复杂度是O（1）</li><li>散列表可能会退化为链表，查询的时间复杂度就从O（1）退化成O（n）</li><li>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是O（log n）</li></ul></li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818213512056.png" alt="image-20230818213512056"></p><p>将链表法中的链表改造成红黑树还有一个非常重要的原因，可以<strong>防止DDos攻击</strong></p><blockquote><p>DDos攻击：分布式拒绝服务攻击（Distributed Denial of Service，简称DDos）指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分别在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个</p></blockquote><h2 id="hashMap实现原理"><a href="#hashMap实现原理" class="headerlink" title="hashMap实现原理"></a>hashMap实现原理</h2><p>HashMap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树</p><ol><li>当我们在HashMap中put元素时，利用key的hashCode重新计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash指相同的key，此时有两种情况<ul><li>如果key相同，则覆盖原始值</li><li>如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中</li></ul></li><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值</li></ol><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818220454150.png" alt="image-20230818220454150"></p><h3 id="HashMap的jdk1-7和jdk1-8有什么区别"><a href="#HashMap的jdk1-7和jdk1-8有什么区别" class="headerlink" title="HashMap的jdk1.7和jdk1.8有什么区别"></a>HashMap的jdk1.7和jdk1.8有什么区别</h3><ul><li>JDK1.8之前采用的是拉链法。拉链法：将链表和数组结合。也就是是创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可</li><li>JDK1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时并且数组长度达到64时，将链表转化为红黑树，以减少搜素时间。扩容resize()时，红黑树拆分成的树的节点树小于等于临界值6，则退化成链表</li></ul><h2 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果未初始化，调用resize方法 进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//该数组下标有数据的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是红黑树的话，进行红黑树的操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//新数据和当前数组既不相同，也不是红黑树节点，证明是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//因为新插入了一条数据，所以判断链表长度是不是大于等于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为修改操作</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出老值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//当前数组中的数据数量如果大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//添加操作时 返回空值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818222644775.png" alt="image-20230818222644775"></p><ol><li>判断键值对数组table是否为空或为null，是则执行resize()进行扩容（初始化）</li><li>根据键值key计算hash值得到数组索引</li><li>判断table[i]&#x3D;&#x3D;null，条件成立，直接新节点添加</li><li>如果table[i]&#x3D;&#x3D;bull，不成立<ol><li>判断table[i]得首个元素是否和key一样，如果相同直接覆盖value</li><li>判断table[i]是否为treeNode，即table[i]是否为红黑树，如果是红黑树，则直接在树中插入键值对</li><li>遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转化为红黑树，在红黑树执行插入操作，遍历过程中若发现key邮件存在直接覆盖value</li></ol></li><li>插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold（数组长度*0.75），如果超过，进行扩容</li></ol><h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818233922706.png" alt="image-20230818233922706"></p><ul><li>在添加元素或者初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次扩容都是达到了扩容阈值（数组长度*0.75）</li><li>每次扩容的时候，都是扩容之前容量的2倍</li><li>扩容之后，会新创建一个数组，需要把老数组中的数据挪动新的数组中<ul><li>没有hash冲突的节点，则直接使用e.hash &amp; (newCap - 1)计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e,hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul></li></ul><h2 id="HashMap的寻址算法"><a href="#HashMap的寻址算法" class="headerlink" title="HashMap的寻址算法"></a>HashMap的寻址算法</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230818235911406.png" alt="image-20230818235911406"></p><h3 id="为何HashMap的数组长度一定是2的次幂"><a href="#为何HashMap的数组长度一定是2的次幂" class="headerlink" title="为何HashMap的数组长度一定是2的次幂"></a>为何HashMap的数组长度一定是2的次幂</h3><ul><li>计算索引时效率更高：如果是2的n次幂可以使用位与运算代替取模运算</li><li>扩容时重新计算索引效率更高：hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置，否则新位置 &#x3D; 旧位置 + oldCap</li></ul><h2 id="HashMap在1-7情况下的多线程死循环问题"><a href="#HashMap在1-7情况下的多线程死循环问题" class="headerlink" title="HashMap在1.7情况下的多线程死循环问题"></a>HashMap在1.7情况下的多线程死循环问题</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230819000317017.png" alt="image-20230819000317017"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230819000605176.png" alt="image-20230819000605176"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230819000644879.png" alt="image-20230819000644879"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次关于Java常见集合的一些常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件面试篇</title>
      <link href="/2023/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Rabbit"><a href="#Rabbit" class="headerlink" title="Rabbit"></a>Rabbit</h1><h2 id="RabbitMQ-如何保证消息不丢失"><a href="#RabbitMQ-如何保证消息不丢失" class="headerlink" title="RabbitMQ-如何保证消息不丢失"></a>RabbitMQ-如何保证消息不丢失</h2><p>什么时候需要MQ？</p><ul><li>异步发送（验证码、短信、邮件…）</li><li>MySQL和Redis，ES之间的数据同步</li><li>分布式事务</li><li>削峰填谷</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816144937886.png" alt="image-20230816144937886"></p><h3 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h3><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送带MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816145321885.png" alt="image-20230816145321885"></p><p>消息失败之后如何处理？</p><ul><li>回调方法即时重发</li><li>记录日志</li><li>保存到数据库中然后定时重发，成功发送后即刻删除表中的数据</li></ul><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p><ol><li><p>交换机持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>队列持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息持久化，SpringAMQP中的消息默认是持久的，可以通过MessageProperties中的DeliveryMode来指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(message.getBytes(StandardCharsets.UTFF-<span class="number">8</span>))<span class="comment">//消息体</span></span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.PERSISTENT)<span class="comment">//持久化</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li></ol><h3 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h3><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ受到ack回执后才会删除该消息</p><p>SpringAMQP则允许设置三种确认模式</p><ul><li>manual：手动ack，需要在业务代码结束后，调用api发送ack</li><li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li><li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li></ul><p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交给人工处理</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816151046812.png" alt="image-20230816151046812"></p><h2 id="RabbitMQ-消息的重复消费"><a href="#RabbitMQ-消息的重复消费" class="headerlink" title="RabbitMQ-消息的重复消费"></a>RabbitMQ-消息的重复消费</h2><p>为什么出现消息的重复消费</p><ul><li>网络抖动</li><li>消费者挂了</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816154842131.png" alt="image-20230816154842131"></p><p>解决方法：</p><ul><li>每条消息设置一个唯一的标识id</li><li>幂等方案：分布式锁、数据库锁（悲观锁、乐观锁）</li></ul><h2 id="RabbitMQ-延迟队列"><a href="#RabbitMQ-延迟队列" class="headerlink" title="RabbitMQ-延迟队列"></a>RabbitMQ-延迟队列</h2><p>延迟队列：进入队列的消息会被延迟消费的队列</p><p>场景：超时订单、限时优惠、定时发布</p><p><strong>延迟队列&#x3D;死信交换机+TTL（生存时间）</strong></p><h3 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h3><p>当有一个队列中的消息满足下列情况之一时，可以成为<strong>死信（dead letter）：</strong></p><ul><li>消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul><p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信会投递到这个交换机中，而这个交换机称为死信交换机（DLX）</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816161647458.png" alt="image-20230816161647458"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>)<span class="comment">//指定队列名称，并持久化</span></span><br><span class="line">        .ttl(<span class="number">10000</span>)<span class="comment">//设置队列超时时间10s</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>)<span class="comment">//指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变成死信，ttl超时分为两种情况：</p><ul><li>消息所在队列设置了存活时间</li><li>消息本身设置了存活时间</li></ul><p><strong>以最短的TTL为准</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816162125492.png" alt="image-20230816162125492"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建消息</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">.withBody(<span class="string">&quot;hello,ttl message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">.setExpiration(<span class="string">&quot;5000&quot;</span>)<span class="comment">//设置ttl</span></span><br><span class="line">.build();</span><br><span class="line"><span class="comment">//消息ID,需要封装到CorrelationData中</span></span><br><span class="line">CorrelationData correlationData <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().tostring());</span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>,<span class="string">&quot;ttl&quot;</span>,message,correlationData);</span><br></pre></td></tr></table></figure><h3 id="延迟队列插件"><a href="#延迟队列插件" class="headerlink" title="延迟队列插件"></a>延迟队列插件</h3><p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为True即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings=@QueueBinding(</span></span><br><span class="line"><span class="meta">value=@Queue(name = &quot;delay.queue&quot;,durable=&quot;true&quot;),</span></span><br><span class="line"><span class="meta">exchange= @Exchange(name &quot;delay.direct&quot;,delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">key=&quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayedQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;接收到delay,queue的延迟消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息时只需要多加一个**<code>.setHeader(&quot;x-delay&quot;,10000)</code>**</p><ol><li>声明一个交换机吗，添加delayed属性为true</li><li>发送消息时，添加x-delay头，值为超时时间</li></ol><h2 id="消息堆积怎么解决"><a href="#消息堆积怎么解决" class="headerlink" title="消息堆积怎么解决"></a>消息堆积怎么解决</h2><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p><p><strong>解决消息堆积：</strong></p><ul><li>增加更多消费者，提高消费速度</li><li>在消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提高堆积上限</li></ul><h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>惰性队列特点：</p><ul><li>接受到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .druable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">        .lazy()<span class="comment">//开启x-queue-mode为lazy</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare=@Queue(</span></span><br><span class="line"><span class="meta">name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">    durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    arguments = @Argument(name = &quot;x-queue-mode&quot;,value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ的高可用机制"><a href="#RabbitMQ的高可用机制" class="headerlink" title="RabbitMQ的高可用机制"></a>RabbitMQ的高可用机制</h2><h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><p>普通集群，或者叫标准集群（classic cluster），特点如下：</p><ul><li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息</li><li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li><li>队伍所在节点宕机，队列中的消息就会丢失</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816192947343.png" alt="image-20230816192947343" style="zoom:50%;"><h3 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h3><p>集群镜像：本质是主从模式，具备下面的特征：</p><ul><li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</li><li>创建队列的节点被称为该队列的<strong>主节点</strong>，备份到其他节点的叫做该队列的<strong>镜像节点</strong></li><li>一个队列的主节点可能是另一个队列的镜像节点</li><li>所有操作都是主节点完成，然后同步给镜像节点</li><li>主机宕机后，镜像节点会替代成新的主节点</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816194254034.png" alt="image-20230816194254034" style="zoom:50%;"><h3 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h3><p>仲裁队列是3.8版本以后才有的新功能，用来代替镜像队列，特点如下：</p><ul><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂配置</li><li>主从同步基于Raft协议，强一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueuBuilder</span><br><span class="line">       .durablr(<span class="string">&quot;quorum.queue&quot;</span>)</span><br><span class="line">        .quorum()<span class="comment">//仲裁队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="Kafka-如何保证消息不丢失"></a>Kafka-如何保证消息不丢失</h2><p>使用Kafka在消息的收发过程都会出现消息丢失，Kafka分别给出了解决方法</p><ul><li>生产者发送消息到Brocker丢失</li><li>消息在Brocker中存储丢失</li><li>消费者从Brocker接受消息丢失</li></ul><h3 id="生产者发送消息到Brocker丢失"><a href="#生产者发送消息到Brocker丢失" class="headerlink" title="生产者发送消息到Brocker丢失"></a>生产者发送消息到Brocker丢失</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816204328758.png" alt="image-20230816204328758"></p><h3 id="消息在Brocker中存储丢失"><a href="#消息在Brocker中存储丢失" class="headerlink" title="消息在Brocker中存储丢失"></a>消息在Brocker中存储丢失</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816204428413.png" alt="image-20230816204428413"></p><h3 id="消费者从Brocker接受消息丢失"><a href="#消费者从Brocker接受消息丢失" class="headerlink" title="消费者从Brocker接受消息丢失"></a>消费者从Brocker接受消息丢失</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816204522664.png" alt="image-20230816204522664"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816204554660.png" alt="image-20230816204554660"></p><h2 id="Kafka-如何保证消费的顺序性"><a href="#Kafka-如何保证消费的顺序性" class="headerlink" title="Kafka-如何保证消费的顺序性"></a>Kafka-如何保证消费的顺序性</h2><p>应用场景：</p><ul><li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序和接收方的顺序一致</li><li>充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816210154781.png" alt="image-20230816210154781"></p><h2 id="Kafka高可用"><a href="#Kafka高可用" class="headerlink" title="Kafka高可用"></a>Kafka高可用</h2><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816210357622.png" alt="image-20230816210357622"></p><ul><li>Kafka的服务器端由被称为Broker的服务进程构成，即一个Kafka集群由多个Broker组成</li><li>这样如果集群中某一台机器宕机，其他机器上的Broker也依然能够对外提供服务。这其实就是Kafka提供高可用的手段之一</li></ul><h3 id="分区备份机制"><a href="#分区备份机制" class="headerlink" title="分区备份机制"></a>分区备份机制</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816211001488.png" alt="image-20230816211001488"></p><ul><li>一个topic有多个分区，每个分区有多个副本，其中有一个leader，其余的是follower，副本存储在不同的Broker中</li><li>所有的分区副本的内容都是相同的，如果leader发生故障，会自动将其中一个follower提升为leader</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816211155864.png" alt="image-20230816211155864"></p><p><strong>ISR（in-sync replica）需要同步复制保存的follower</strong></p><p>如果leader失效后，需要选出新的leader，选举的原则如下：</p><p>第一：选举是优先从ISR中选定，因为这个列表中follower的数据是与leader同步的</p><p>第二：如果ISR列表的follower都不行了，就只能从其他follower中选取</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">//一个topic默认分区的replication个数，不能大于集群中broker的个数。默认为1</span></span><br><span class="line"><span class="attr">default.replication.factor</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">//最小的ISR副本个数</span></span><br><span class="line"><span class="attr">min.insync.replicas</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><h2 id="Kafka数据清理机制"><a href="#Kafka数据清理机制" class="headerlink" title="Kafka数据清理机制"></a>Kafka数据清理机制</h2><h3 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816222252905.png" alt="image-20230816222252905"></p><h3 id="数据清理机制"><a href="#数据清理机制" class="headerlink" title="数据清理机制"></a>数据清理机制</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816222440349.png" alt="image-20230816222440349"></p><h2 id="Kafka如何实现高性能"><a href="#Kafka如何实现高性能" class="headerlink" title="Kafka如何实现高性能"></a>Kafka如何实现高性能</h2><ul><li><strong>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</strong></li><li><strong>顺序读写：磁盘顺序读写，提高读写效率</strong></li><li><strong>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</strong></li><li><strong>零拷贝：减少上下文切换及数据拷贝</strong></li><li>消息压缩：减少磁盘IO和网络IO</li><li>分批发送：将消息打包批量发送，减少网络开销</li></ul><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816223537367.png" alt="image-20230816223537367"></p><p>变成：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230816223549701.png" alt="image-20230816223549701"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本次关于消息中间件的一些常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务面试篇</title>
      <link href="/2023/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringCloud5大组件有哪些"><a href="#SpringCloud5大组件有哪些" class="headerlink" title="SpringCloud5大组件有哪些"></a>SpringCloud5大组件有哪些</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815145535466.png" alt="image-20230815145535466"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815145554710.png" alt="image-20230815145554710"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815145625097.png" alt="image-20230815145625097"></p><h2 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h2><ul><li>微服务中必须要使用到的组件</li><li>注册中心的核心作用是：服务注册和发现</li><li>常见的注册中心：eureka、Zookeeper、consul、nacos</li></ul><h3 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a>Eureka的作用</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815152905965.png" alt="image-20230815152905965"></p><ul><li>服务注册：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等</li><li>服务发现：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</li><li>服务监控：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没有接受到心跳，从eureka中剔除</li></ul><h3 id="Nacos的工作流程"><a href="#Nacos的工作流程" class="headerlink" title="Nacos的工作流程"></a>Nacos的工作流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815153718348.png" alt="image-20230815153718348"></p><h3 id="nacos与eureka的区别"><a href="#nacos与eureka的区别" class="headerlink" title="nacos与eureka的区别"></a>nacos与eureka的区别</h3><ul><li>nacos与eureka的共同点（注册中心）<ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li>nacos与eureka的区别（注册中心）<ul><li>nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>nacos集群默认采用AP方式，当集群中存在非临时实例，采用CP模式；eureka采用AP方式</li></ul></li><li>nacos还支持配置中心和服务总线，eureka则只有注册中心，也是选择使用nacos的一个重要原因</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="Ribbon负载均衡流程"><a href="#Ribbon负载均衡流程" class="headerlink" title="Ribbon负载均衡流程"></a>Ribbon负载均衡流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815161454878.png" alt="image-20230815161454878"></p><h3 id="Ribbon负载均衡策略有哪些"><a href="#Ribbon负载均衡策略有哪些" class="headerlink" title="Ribbon负载均衡策略有哪些"></a>Ribbon负载均衡策略有哪些</h3><ul><li><strong>RoundRobinRule：简单轮询服务列表来选择服务器</strong></li><li><strong>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</strong></li><li><strong>RandomRule：随机选择一个可用的服务器</strong></li><li>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li><li>RetryRule：重试机制的选择逻辑</li><li>AvailablilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li><li><strong>ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询（默认）</strong></li></ul><h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><p> 可以自己创建类实现IRule接口，然后再通过配置类或者配置文件配置即可，通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li><p>全局生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>局部生效：</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>一个服务失败，导致整条链路的服务都失败的情形</p><ul><li>熔断降级（解决）</li><li>限流（预防）</li></ul><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815170352777.png" alt="image-20230815170352777"></p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>Hystrix熔断机制，用于监控微服务调用情况，默认是关闭的，如果需要开启需要在引导类上添加注解：@EnableCircuitBreaker</p><p>如果检测到10秒内请求的失败率超过50%，就触发熔断机制。之后每隔5秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815170719342.png" alt="image-20230815170719342"></p><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>为什么需要监控？</p><ul><li>问题定位</li><li>性能分析</li><li>服务关系</li><li>服务告警</li></ul><p>监控方法</p><ul><li>SpringBoo-admin</li><li><strong>prometheus+Grafana</strong>：搭建困难</li><li>zipkin</li><li><strong>skywalking</strong></li></ul><p>最后两个都是链路追踪工具</p><h3 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h3><p>一个分布式系统的应用持续性能监控工具（Application Performance Managment），提供了完善的链路追踪能力，apache的顶级项目</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815191746310.png" alt="image-20230815191746310"></p><ul><li>服务（service）：业务资源应用系统（微服务）</li><li>端点（endpoint）：应用系统对外暴露的功能接口（接口）</li><li>实例（instance）：物理机</li></ul><p>图中&#x2F;api&#x2F;user&#x2F;login就是端点</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>为什么要限流</p><ol><li>并发很大（突发流量）</li><li>防止用户恶意刷接口</li></ol><p>限流的实现方式：</p><ul><li>Tomcat：可以设置最大连接数</li><li>Nginx，漏桶算法</li><li>网关，令牌桶算法</li><li>自定义拦截器</li></ul><h3 id="Nginx限流"><a href="#Nginx限流" class="headerlink" title="Nginx限流"></a>Nginx限流</h3><h4 id="控制速率（突发流量）"><a href="#控制速率（突发流量）" class="headerlink" title="控制速率（突发流量）"></a>控制速率（突发流量）</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815203203943.png" alt="image-20230815203203943"></p><ul><li>语法：<code>limit_req_zone key zone rate</code></li><li>key：定义限流对象，binary_remote_addr就是一种key，基于客户端ip限流</li><li>Zone：定义共享存储区来存储访问信息，10m可以存储16wip地址访问信息</li><li>Rate：最大访问速率，rate&#x3D;10r&#x2F;s 表示每秒最多10个请求</li><li>burst&#x3D;20：相当于桶的大小</li><li>Nodelay：快速处理</li></ul><h4 id="控制并发连接数"><a href="#控制并发连接数" class="headerlink" title="控制并发连接数"></a>控制并发连接数</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815203703750.png" alt="image-20230815203703750"></p><ul><li>limit_conn perip 20：对应的key是$binary_remote_addr，表示限制单个IP同时最多能持有20个连接</li><li>limit_conn perserver 100：对应的key是$server_name，表示虚拟主机（server）同时能处理并发连接的总数</li></ul><h3 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815204335128.png" alt="image-20230815204335128"></p><ul><li>key-resolver：定义限流对象（ip、路径、参数），需代码实现，使用spel表达式获取</li><li>replenishRate：令牌桶每秒填充平均速率</li><li>urstCapacity：令牌桶总容量</li></ul><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance（分区容错性）</li></ul><p><strong>分布式系统无法同时满足这三个指标</strong></p><h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到大的数据必须一致</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815210633139.png" alt="image-20230815210633139" style="zoom:50%;"><h3 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h3><p>Availability（可用性）：用户访问集群中的任意健康节点，必须得到响应，而不是超时或拒绝</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815211028026.png" alt="image-20230815211028026" style="zoom:50%;"><h3 id="Partition-tolerance"><a href="#Partition-tolerance" class="headerlink" title="Partition tolerance"></a>Partition tolerance</h3><p>Partition（分区）：因为网络故障或其他原因导致分布式系统中的部分节点与其他节点时区连接，形成独立分区</p><p>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815211508318.png" alt="image-20230815211508318" style="zoom:50%;"><p>结论：</p><ul><li>分布式系统节点之间肯定是需要网络连接的，分区（P）是必然存在的</li><li>如果保证访问的高可用性（A），可用持续对外提供服务，但不能保证数据的强一致性——&gt;AP</li><li>如果保证访问的数据强一致性（C），就要放弃高可用性——&gt;CP</li></ul><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li>Basically Available（基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li><li>Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li><li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815213248862.png" alt="image-20230815213248862" style="zoom:50%;"><p><strong>解决分布式事务的思想和模型：</strong></p><ul><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后同一提交或回滚（CP）</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul><li>Seata框架（XA、AT、TCC）</li><li>MQ</li></ul><h3 id="Seatac框架"><a href="#Seatac框架" class="headerlink" title="Seatac框架"></a>Seatac框架</h3><p>Seata事务管理中有三个重要的角色：</p><ul><li>TC（Transaction Coordinate）-事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚</li><li>TM（Transaction Manager）-事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务</li><li>RM（Resource Manager）-资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815215443226.png" alt="image-20230815215443226"></p><h3 id="Seata的XA模式"><a href="#Seata的XA模式" class="headerlink" title="Seata的XA模式"></a>Seata的XA模式</h3><p><strong>CP模式</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815220333781.png" alt="image-20230815220333781"></p><h3 id="Seata的AT模式"><a href="#Seata的AT模式" class="headerlink" title="Seata的AT模式"></a>Seata的AT模式</h3><p><strong>AP模式</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815220604180.png" alt="image-20230815220604180"></p><h3 id="Seata的TCC模式"><a href="#Seata的TCC模式" class="headerlink" title="Seata的TCC模式"></a>Seata的TCC模式</h3><p>AP模式</p><p>人工编码实现</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815220856088.png" alt="image-20230815220856088"></p><h3 id="MQ分布式事务"><a href="#MQ分布式事务" class="headerlink" title="MQ分布式事务"></a>MQ分布式事务</h3><p>在A服务写数据时，需要在同一个事务内发送消息到另外一个事务，异步，性能最好</p><p>异步，实时性不是很高，不考虑一致性的情况下可以使用</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815221057016.png" alt="image-20230815221057016"></p><h2 id="分布式服务的接口幂等性"><a href="#分布式服务的接口幂等性" class="headerlink" title="分布式服务的接口幂等性"></a>分布式服务的接口幂等性</h2><p>幂等：多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用结果是一样的</p><p>需要幂等场景</p><ul><li>用户重复点击（网络波动）</li><li>MQ消息重复</li><li>应用使用失败或者超时重试机制</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815223214674.png" alt="image-20230815223214674"></p><h3 id="token-redis"><a href="#token-redis" class="headerlink" title="token+redis"></a>token+redis</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815223441455.png" alt="image-20230815223441455"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815223557463.png" alt="image-20230815223557463"></p><h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p><strong>xxl-job</strong></p><p>xxl-job解决的问题：</p><ul><li>解决集群任务重复执行问题</li><li>cron表达式定义灵活</li><li>定时任务失败了，重试和统计</li><li>任务量大，分片执行</li></ul><h3 id="xxl-job路由策略"><a href="#xxl-job路由策略" class="headerlink" title="xxl-job路由策略"></a>xxl-job路由策略</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815224606625.png" alt="image-20230815224606625"></p><h3 id="xxl-job任务执行失败"><a href="#xxl-job任务执行失败" class="headerlink" title="xxl-job任务执行失败"></a>xxl-job任务执行失败</h3><p>故障转移+失败重试，查看日志分析——&gt;邮件告警</p><h3 id="大数量的任务同时都需要执行"><a href="#大数量的任务同时都需要执行" class="headerlink" title="大数量的任务同时都需要执行"></a>大数量的任务同时都需要执行</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815225101129.png" alt="image-20230815225101129"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次关于微服务及其业务相关的一些常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架面试篇</title>
      <link href="/2023/08/15/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/15/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring框架中的bean是单例的</p><ul><li>singleton：bean在每个Spring IOC容器中只有一个实例</li><li>prototype：一个bean的定义可以有多个实例</li></ul><p> <strong>不是线程安全的</strong></p><p>Spring框架中有一个@scope注解，默认的值就是singleton，单例的。</p><p>因为一般在spring的bean都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决问题</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP称为面向切面编程，用于将那些与业务无光，但对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性</p><h3 id="什么地方用到了AOP"><a href="#什么地方用到了AOP" class="headerlink" title="什么地方用到了AOP"></a>什么地方用到了AOP</h3><p>记录操作日志，缓存，spring实现的事务，权限</p><p>核心是：使用aop中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等），获取到这些参数以后，保存到数据库</p><h3 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a>Spring中的事务是如何实现的</h3><ul><li>编程式事务控制：需要使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li><li>声明式事务管理：声明式事务管理建立在AOP之上。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法之前加入一个事务，在执行完目标方法之后根据情况提交或者回滚事务</li></ul><h2 id="事务失效的场景"><a href="#事务失效的场景" class="headerlink" title="事务失效的场景"></a>事务失效的场景</h2><ul><li>异常捕获处理</li><li>抛出检查异常</li><li>非public方法</li></ul><h3 id="异常捕获处理"><a href="#异常捕获处理" class="headerlink" title="异常捕获处理"></a>异常捕获处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//转账的用户不能为空</span></span><br><span class="line">        Account fromAccount accountDao.selectByld(from);</span><br><span class="line">        <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">        <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">            accountDao.updateByld(fromAccount);</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//被转账的用户</span></span><br><span class="line">            Account toAccount accountDao.selectByld(to);</span><br><span class="line">            toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">            accountDao.updateByld(toAccount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：事务通知值捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知则无法知悉</p><p>解决：在catch块中添加<code>throw new RuntimeException(e)</code>抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//转账的用户不能为空</span></span><br><span class="line">        Account fromAccount accountDao.selectByld(from);</span><br><span class="line">        <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">        <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">            accountDao.updateByld(fromAccount);</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//被转账的用户</span></span><br><span class="line">            Account toAccount accountDao.selectByld(to);</span><br><span class="line">            toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">            accountDao.updateByld(toAccount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抛出检查性异常"><a href="#抛出检查性异常" class="headerlink" title="抛出检查性异常"></a>抛出检查性异常</h3><p>什么是检查性异常？</p><ul><li>所有的检查性异常都继承自java.lang.Exception；所有的非检查性异常都继承自java.lang.RuntimeException。</li><li>检查性异常和非检查性异常最主要的区别在于其处理异常的方式：检查性异常必须使用try catch或者throws等关键字进行处理，否则编译器会报错;非检查性异常一般是程序代码写的不够严谨而导致的问题，可以通过修改代码来规避。</li><li>常见的运行时异常：空指针异常(NullPointerException)、除零异常(ArithmeticException)、数组越界异常(ArrayIndexOutOfBoundsException)等;</li><li>常见的检查性异常：输入输出异常(IOException)、文件不存在异常(FileNotFoundException)、SQL语句异常(SQLException)等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">    <span class="comment">//转账的用户不能为空</span></span><br><span class="line">    Account fromAccount accountDao.selectByld(from);</span><br><span class="line">    <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">    <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">        accountDao.updateByld(fromAccount);</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        <span class="comment">//被转账的用户</span></span><br><span class="line">        Account toAccount accountDao.selectByld(to);</span><br><span class="line">        toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateByld(toAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：Spring默认只回滚非检查性异常</p><p>解决：配置rollbackFfor属性</p><p><code>@Transactional(rollbackFor=Exception.calss)</code></p><h3 id="非public方法导致的事务失效"><a href="#非public方法导致的事务失效" class="headerlink" title="非public方法导致的事务失效"></a>非public方法导致的事务失效</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Integer from, Integer to, Double money)</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">    <span class="comment">//转账的用户不能为空</span></span><br><span class="line">    Account fromAccount accountDao.selectByld(from);</span><br><span class="line">    <span class="comment">//判断用户的钱是否够转账</span></span><br><span class="line">    <span class="keyword">if</span> (fromAccount.getMoney() - money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fromAccount.setMoney(fromAccount.getMoney() - money);</span><br><span class="line">        accountDao.updateByld(fromAccount);</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">        <span class="comment">//被转账的用户</span></span><br><span class="line">        Account toAccount accountDao.selectByld(to);</span><br><span class="line">        toAccount.setMoney(toAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateByld(toAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：Spring为方法创建代理、添加事务通知、前提条件都是该方法是public的</p><p>解决：改为public方法</p><h2 id="Spring的bean的生命周期"><a href="#Spring的bean的生命周期" class="headerlink" title="Spring的bean的生命周期"></a>Spring的bean的生命周期</h2><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>Spring容器在进行实例化时，会将xml配置的<bean>的信息封装成一个BeanDefinition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean</bean></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaolmpl&quot;</span><span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.itheima.service.UserServicelmpl&quot;</span><span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span><span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814201434684.png" alt="image-20230814201434684"></p><ul><li>beanClassName:bean的类名</li><li>initMethodName：初始化方法名称</li><li>properryValues：bean的属性值</li><li>scope：作用域</li><li>lazyInit：延迟初始化</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814203852453.png" alt="image-20230814203852453"></p><ol><li>通过BeanDefinition获取bean的定义信息</li><li>调用构造函数实例化bean</li><li>bean的依赖注入</li><li>处理Aware接口（BeanNameAware、BeanFactoryAware、ApplicationContextAware）</li><li>Bean的后置处理器BeanPostProcessor-前置</li><li>初始化方法（InitializingBean、init-method）</li><li>Bean的后置处理器BeanPostProcessor-后置</li><li>销毁Bean</li></ol><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>下面先看两段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建A对象的同时需要使用B对象，在创建B对象的同时需要使用到A对象</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814204917847.png" alt="image-20230814204917847"></p><h3 id="三级缓存解决循环依赖"><a href="#三级缓存解决循环依赖" class="headerlink" title="三级缓存解决循环依赖"></a>三级缓存解决循环依赖</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210703972.png" alt="image-20230814210703972"></p><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210713822.png" alt="image-20230814210713822"></p><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210810279.png" alt="image-20230814210810279"></p><p><strong>二级缓存不能解决代理对象</strong></p><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814210902661.png" alt="image-20230814210902661"></p><h3 id="构造方法出现了循环依赖"><a href="#构造方法出现了循环依赖" class="headerlink" title="构造方法出现了循环依赖"></a>构造方法出现了循环依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//B成员变量</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法执行了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//B成员变量</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法执行了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的依赖注入</p><p>报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure><p>解决：</p><p>使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A的构造方法执行了&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.b=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><blockquote><p>SpringMVC的执行流程是这个框架最核心的内容</p><ul><li>视图阶段（老旧JSP等）</li><li>前后端分离阶段（接口开发，异步）</li></ul></blockquote><h3 id="视图阶段（JSP）"><a href="#视图阶段（JSP）" class="headerlink" title="视图阶段（JSP）"></a>视图阶段（JSP）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814223414623.png" alt="image-20230814223414623"></p><ol><li>用户发送请求到前端控制器DispatcherServlet</li><li>DispatcherServlet受到请求后调用HandlerMapping（处理器映射器）</li><li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），再一起返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配器调用具体的处理器（Handler&#x2F;Controller）</li><li>Controller执行完成后返回ModelAndView对象</li><li>HandlerAdapter将Controller执行结果返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）</li><li>ViewResolver解析后返回具体的View（视图）</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充到视图中）</li><li>DispatcherServlet响应用户</li></ol><h3 id="前后端分离阶段（接口开发，异步请求）"><a href="#前后端分离阶段（接口开发，异步请求）" class="headerlink" title="前后端分离阶段（接口开发，异步请求）"></a>前后端分离阶段（接口开发，异步请求）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814223642023.png" alt="image-20230814223642023"></p><ol><li>用户发送请求到前端控制器DispatcherServlet</li><li>DispatcherServlet受到请求后调用HandlerMapping（处理器映射器）</li><li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），再一起返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配器调用具体的处理器（Handler&#x2F;Controller）</li><li>方法上添加了@ResponseBody</li><li>通过HttpMessageConverter来返回结果转换为JSON并响应</li></ol><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>在SpringBoot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是：</p><ul><li>@SpringBootConfiguration：该注解与@Configuration注解作用相同，用来声明当前也是一个配置类</li><li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包</li><li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814225822043.png" alt="image-20230814225822043"></p><p>@EnableAutoConfiguration是实现自动化配置的核心注解。该注解通过@Import注解导入对应的配置选择器。内部就是读取了该项目和该项目引用的Jar包的classpath路径下META-INF&#x2F;spring.factories文件中的所配置的类的全类名。在这些配置类中定义的Bean会根据<strong>条件注解</strong>所指定的条件来决定是否需要将其导入到Spring容器中。</p><p>条件判断会有像@ConditionOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入到spring容器中使用。</p><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814230657815.png" alt="image-20230814230657815"></p><h2 id="SpringMVC-1"><a href="#SpringMVC-1" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814230715312.png" alt="image-20230814230715312"></p><h2 id="SpringBoot-1"><a href="#SpringBoot-1" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230814230831291.png" alt="image-20230814230831291"></p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程"></a>Mybatis执行流程</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815095250611.png" alt="image-20230815095250611"></p><ol><li>读取Mybatis配置文件：mybatis-config.xml加载运行环境和映射文件</li><li>构造会话工厂SqlSessionFactory</li><li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li><li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li><li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li><li>输入参数映射</li><li>输出结果映射</li></ol><h2 id="Mybatis延迟加载"><a href="#Mybatis延迟加载" class="headerlink" title="Mybatis延迟加载"></a>Mybatis延迟加载</h2><p>延迟加载：需要用到数据时才进行加载，不需要用到数据时就不加载</p><p>Mybatis支持延迟加载，但默认没有开启</p><ul><li>Mybatis中支持一对一关联对象和一对多关联集合对象的延迟加载</li><li>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyloadingEnabled=true|false</code>,默认关闭</li></ul><h3 id="延迟加载底层原理"><a href="#延迟加载底层原理" class="headerlink" title="延迟加载底层原理"></a>延迟加载底层原理</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230815100624740.png" alt="image-20230815100624740"></p><ol><li>使用CGLIB创建目标对象的代理对象</li><li>当调用目标方法<code>user.getOrderList()</code>时，进入拦截器<code>invoke</code>方法，发现<code>user.getOrderList()</code>是<code>null</code>值，执行sql查询order列表</li><li>把order查询上来，然后调用<code>user.setOrderList(List&lt;Order&gt; orderList)</code>，接着完成<code>user,getOrderList()</code>方法的调用</li></ol><h2 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h2><ul><li>本地缓存，基于PerpetualCache，本质是一个HashMap</li><li>一级缓存：作用域是session级别</li><li>二级缓存：作用域是namespace和mapper的作用域，不依赖于session</li></ul><h3 id="一级缓存-1"><a href="#一级缓存-1" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认开启了一级缓存</p><h3 id="二级缓存-1"><a href="#二级缓存-1" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存是基于namespace和mapper的作用域其作用的，不是依赖于SQL Session，默认也是采用PerpetualCache的HashMap存储</p><p><strong>默认关闭</strong></p><p>开启：</p><ol><li><p>全局配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>映射文件</p><p>使用<cache>标签让当前mapper生效二级缓存</cache></p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>对于缓存数据更新机制，当某一个作用域（一级缓存Session&#x2F;二级缓存Namespaces）进行了增删改操作后，默认该作用域下的所有select中的缓存将被clear</li><li>二级缓存需要缓存的数据实现Serializable接口</li><li>只有会话提交或关闭以后，一级缓存中的数据才会被转移到二级缓存中</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本次关于常用框架一些常用面试的分享就先到这里，后续会跟进一些面试题请持续关注。内存如有不足或错误的地方，请联系小编来及时改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试篇</title>
      <link href="/2023/08/08/MySQL%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/08/MySQL%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="优化之定位慢查询"><a href="#优化之定位慢查询" class="headerlink" title="优化之定位慢查询"></a>优化之定位慢查询</h2><ul><li>聚合查询</li><li>多表查询</li><li>表数据量过大查询</li><li>深度分页查询</li></ul><p>表象：页面加载过慢、接口压测响应时间过长（超过1s）</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><ul><li>调试工具：Arthas</li><li>运维工具：Prometheus、Skywalking</li></ul><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>MySQL自带慢日志</strong></p><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志</p><p>如果需要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启MySQL慢日志查询开关</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="comment">#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p><p><code>/var/lib/mysql/localhost-slow.log</code></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811194645962.png" alt="image-20230811194645962"></p><h2 id="SQL语句执行很慢，如何分析"><a href="#SQL语句执行很慢，如何分析" class="headerlink" title="SQL语句执行很慢，如何分析"></a>SQL语句执行很慢，如何分析</h2><p>可以采用<strong>EXPLAIN</strong>或者<strong>DESC</strong>命令获取MySQL如何执行SELECT语句的信息</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811200331680.png" alt="image-20230811200331680"></p><ul><li><p>possible_keys 当前sql可能会使用到索引</p></li><li><p>key当前sql实际命中的索引</p></li><li><p>key_len 索引占用的大小</p></li></ul><p>通过它们两个查看是否可能会命中索引</p><ul><li><p>Extra 额外的优化建议</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811200634608.png" alt="image-20230811200634608"></p></li><li><p>type 这条sql的连接类型，性能由好到差为NULL、system、const、eq_ref、ref、range、index、all</p><ul><li>system:查询系统中的表</li><li>const：根据主键查询</li><li>eq_ref：主键索引查询或唯一索引查询</li><li>ref：索引查询</li><li>range：范围查询</li><li><strong>index：索引树查询</strong></li><li><strong>all：全盘扫描</strong></li></ul></li></ul><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>可以采用MySQL自带的分析工具EXPLAIN</p><ul><li>通过key和key_len检查是否命中了索引（索引本身存在是否失效的情况）</li><li>通过type字段查看sql是否有进一步优化的空间，是否存在全索引扫描或全盘扫描</li><li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库还维护者满足特定查询算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><h3 id="数据结构对比"><a href="#数据结构对比" class="headerlink" title="数据结构对比"></a>数据结构对比</h3><p>  <img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811203948819.png" alt="image-20230811203948819"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811204005723.png" alt="image-20230811204005723"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230811204024947.png" alt="image-20230811204024947"></p><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul><li>索引是帮助MySQL高效获取数据的数据结构（有序）</li><li>提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p><ul><li>阶数更多，路径更短</li><li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子节点存储数据</li><li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li></ul><h2 id="聚簇索引（聚集索引）和非聚簇索引（二级索引）"><a href="#聚簇索引（聚集索引）和非聚簇索引（二级索引）" class="headerlink" title="聚簇索引（聚集索引）和非聚簇索引（二级索引）"></a>聚簇索引（聚集索引）和非聚簇索引（二级索引）</h2><ul><li><strong>聚集索引：</strong>将数据存储与索引放到一块，索引结构的叶子节点保存行数据（必须用，而且只有一个）</li><li><strong>二级索引：</strong>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键（可以存在多个）</li></ul><p>聚集索引选举规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812151510853.png" alt="image-20230812151510853"></p><p>通过二级索引找到对应的主键值，然后再通过主键值找到聚集索引中所对应的整行数据，这个过程就是回表</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能找到（没有进行回表查询）</p><ul><li>使用id查询，直接走聚集索引查询，一次索引查询，直接返回数据，性能高</li><li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用<code>select *</code></li></ul><h3 id="MySQL超大分页处理"><a href="#MySQL超大分页处理" class="headerlink" title="MySQL超大分页处理"></a>MySQL超大分页处理</h3><p>在数据量比较大的时候，如果进行limit分页查询，在查询时，越往后，分页1查询效率越低</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812154000508.png" alt="image-20230812154000508"></p><p>因为，当在进行分页查询时，如果执行limit 9000000，10，此时需要MySQL排序前9000010记录，仅仅返回9000000-9000010的记录，其他记录丢弃，查询排序的代价非常大</p><p><strong>优化思路：</strong>一般分页查询时，通过创建覆盖索引能够比较好的提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from tb_sku t,</span><br><span class="line">(select id from tb_sku order by id limiit 9000000,10) a</span><br><span class="line">where t.id=a.id;</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812154511068.png" alt="image-20230812154511068"></p><h2 id="索引创建的原则"><a href="#索引创建的原则" class="headerlink" title="索引创建的原则"></a>索引创建的原则</h2><p>索引一般包括：</p><ul><li>主键索引</li><li>唯一索引</li><li>根据业务创建的索引（复合索引）</li></ul><p><strong>原则：</strong></p><ul><li>针对于数据量较大，且查询比较频繁的表建立索引。（单表超过10w数据，增加用户体验）</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL指，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ul><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>怎么判断索引是否失效了呢？ <strong>执行计划explain</strong></p><ol><li><p>违反最左前缀法则</p><p>如果索引了多列，要遵循最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引</p><p>如果符合最左法则，但是出现跳跃了某一列，只有最左列索引生效</p></li><li><p>范围查询右边地列，不能使用索引</p></li><li><p>不要在索引列上进行运算操作，索引将失效</p></li><li><p>字符串不加单引号，造成索引失效</p><p>MySQL的查询优化器，会自动地进行类型转换，造成索引失效</p></li><li><p>以%开头的like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p></li></ol><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ul><li>表的设计优化（参考阿里开发手册《嵩山版》）</li><li>索引优化</li><li>SQL语句优化</li><li>主从复制、读写分离</li><li>分库分表</li></ul><h3 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h3><ul><li>比如设置合适地数值（tinyint、int、bigint），要根据实际情况选择</li><li>比如设置合适地字符串类型（char、varchar）char定长效率高，varchar可变长度，效率较低</li></ul><h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><ul><li>select语句务必指明字段名称（避免直接使用select *）</li><li>SQL语句要避免造成索引失效地写法</li><li>尽量使用union all代替union 因为union会多过滤一次，效率低</li><li>避免在where子句中对字段进行表达式操作</li><li>Join优化：能用innerjoin就不用left join、right join，如必须使用一定要以小表为驱动，内连接会对两个表进行优化，优先把小的表放到外边，把大地表放到里边。left join或right join，不会重新调整顺序</li></ul><h3 id="主从复制、读写分离"><a href="#主从复制、读写分离" class="headerlink" title="主从复制、读写分离"></a>主从复制、读写分离</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230812172114879.png" alt="image-20230812172114879"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败</p><p><strong>ACID：</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或者回滚，它对数据库中的数据的改变就是永久的。</li></ul><h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><ul><li>脏读：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>不可重复读： 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li>幻读：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>不可重复读和幻读区别：</strong></p><p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交（READ UNCOMMITTED）：什么都不能解决</li><li>读提交 （READ COMMITTED）：解决了脏读</li><li>可重复读 （REPEATABLE READ）：解决不可重复读和脏读</li><li>串行化 （SERIALIZABLE）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。<strong>解决了幻读</strong>的提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。</li></ul><h2 id="undo-log和redo-log的区别"><a href="#undo-log和redo-log的区别" class="headerlink" title="undo log和redo log的区别"></a>undo log和redo log的区别</h2><ul><li>缓冲池（buffer pool）：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li><li>数据页（page）：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16kb。页中存储的是行数据</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813094355800.png" alt="image-20230813094355800"></p><p>如果服务器宕机，可能内存中的数据还没有同步到磁盘中，会出现数据不一致的问题</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong></p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813094855143.png" alt="image-20230813094855143"></p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和<strong>MVCC</strong>（多版本并发控制）。undo log和redo log记录物理日志不一样，它是逻辑日志</p><ul><li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li><li>当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并且进行回滚</li></ul><p><strong>undo log可以实现事务的一致性和原子性</strong></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>redo log：记录的是数据页的物理变化，服务器宕机可以用来同步数据</li><li>undo log：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据</li><li>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</li></ul><h2 id="事务的隔离性如何保证"><a href="#事务的隔离性如何保证" class="headerlink" title="事务的隔离性如何保证"></a>事务的隔离性如何保证</h2><p>锁：排他锁（如一个事务获取了一个数据行的排他锁，其他事务就不能在获取该行的其他锁）</p><p>mvcc：多版本并发控制</p><h3 id="解释一下MVCC"><a href="#解释一下MVCC" class="headerlink" title="解释一下MVCC"></a>解释一下MVCC</h3><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p><p>MVCC的具体实现，主要依赖于数据库记录中的隐式字段、undo log日志、readView</p><h3 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC-实现原理"></a>MVCC-实现原理</h3><ul><li><p>记录中的隐藏字段</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813105731519.png" alt="image-20230813105731519"></p></li><li><p>undo log</p><ul><li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志</li><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除</li><li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除</li></ul></li><li><p>undo log版本链</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813120842925.png" alt="image-20230813120842925"></p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生产一条记录版本链表，链表的头部是最新的旧记录，链表的尾部是最早的旧记录</p></li><li><p>readvi ew</p><p>ReadView（读视图）是<strong>快照读</strong>SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p><ul><li><p>当前读</p><p>读取的是记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select…lock in share mode（共享锁），select…for update、update、insert、delete（排他锁）都是一种当前读</p></li><li><p>快照读</p><p>简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p><ul><li>Read Committed：每次select，都生成一个快照读</li><li>Repeatable Read：开启事务后第一个select语句语句才是快照读的地方</li></ul></li></ul></li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813150523257.png" alt="image-20230813150523257"></p><p>其中m_ids是<strong>未提交的事务</strong>  </p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813150838902.png" alt="image-20230813150838902"></p><p>  <img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813151138712.png" alt="image-20230813151138712"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813151203898.png" alt="image-20230813151203898"></p><h2 id="MySQL主从同步原理"><a href="#MySQL主从同步原理" class="headerlink" title="MySQL主从同步原理"></a>MySQL主从同步原理</h2><p>MySQL主从复制的核心就是二进制日志</p><blockquote><p>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句</p></blockquote><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813151916561.png" alt="image-20230813151916561"></p><p>复制分为三步：</p><ol><li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li><li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志RelayLog</li><li>slave重做中继日志中的事件，将改变反映它自己的数据</li></ol><h2 id="MySQL分库分表"><a href="#MySQL分库分表" class="headerlink" title="MySQL分库分表"></a>MySQL分库分表</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813152351552.png" alt="image-20230813152351552"></p><p>分库分表的时机：</p><ul><li><strong>前提</strong>，项目业务数据逐渐增多，或业务发展比较迅速（单表的数据量达到1000W或20G）</li><li>优化解决不了性能的问题（主从读写分离、查询索引…）</li><li>IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询，连接数太多）</li></ul><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>以表为依据，根据业务将不同表拆分到不同库中</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813152821813.png" alt="image-20230813152821813"></p><p>特点：</p><ul><li>按业务对数据分级管理、维护、监控、扩展</li><li>在高并发下，提高磁盘IO的数据量连接数</li></ul><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>以字段为依据，根据字段属性将字段拆分到不同表中</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813153037699.png" alt="image-20230813153037699"></p><p>拆分规则：</p><ul><li>把不常用的字段单独放在一张表</li><li>把text、blob等大字段拆分出来放到附表中</li></ul><p>特点：</p><ul><li>冷热数据分离</li><li>减少IO过度争抢，两表互不影响</li></ul><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>将一个库的数据库拆分到多个库中</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230813153341310.png" alt="image-20230813153341310"></p><p>路由规则：</p><ul><li>根据id节点取模</li><li>按id也就是范围路由，节点1（1-100W），节点2（100W-200W）</li></ul><p>特点：</p><ul><li>解决了单库大数量，高并发的性能瓶颈</li><li>提高了系统的稳定性和可用性</li></ul><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>将一个表的数据拆分到多个表中（可以在同一个库内）</p><p>特点：</p><ul><li>优化单一表数据量过大而产生的性能问题</li><li>避免IO争抢并减少锁表的几率</li></ul><h3 id="分库之后的问题"><a href="#分库之后的问题" class="headerlink" title="分库之后的问题"></a>分库之后的问题</h3><ul><li>分布式事务一致性问题</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul><p><strong>解决：</strong></p><p>分库分表中间件：</p><ul><li>sharding-sphere</li><li>mycat</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次关于MySQL面试常被问到的问题分享就到这了，小编也是通过网上的学习来总结的。如有不足和错误的地方请联系小编来改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试篇</title>
      <link href="/2023/08/04/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/08/04/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>查询到一个不存在的的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>缓存空数据，查询返回的数据为空，空结果也缓存</strong></p><p>优点：简单</p><p>缺点：消耗内存，可能会发生数据不一致的问题（后续数据库中又有数据了）</p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p><strong>布隆过滤器</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809193034083.png" alt="image-20230809193034083"></p><p>优点：内存占用少，没有多余key</p><p>缺点：实现复杂（Redisson、Guava），存在误判</p><p><a href="https://blog.csdn.net/dreaming9420/article/details/124153422">布隆+redisson配置</a></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>给某一个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这写并发的请求可能会瞬间吧DB压垮</p><h3 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>互斥锁</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809195304787.png" alt="image-20230809195304787"></p><h3 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h3><p><strong>逻辑过期</strong></p><p>不能保证数据的绝对一致</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809195327521.png" alt="image-20230809195327521"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量的请求到达数据库，带来巨大压力</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>给不同的key的TTL添加随机值</p></li><li><p>利用Redis集群提高高服务的可用性 （哨兵模式、集群模式）</p></li><li><p>给缓存业务添加降级限流策略  （nginx、SpringCloud gateway）</p></li><li><p>给业务添加多级缓存 （Guava、Caffeine）</p><h2 id="穿透、击穿、雪崩总结"><a href="#穿透、击穿、雪崩总结" class="headerlink" title="穿透、击穿、雪崩总结"></a>穿透、击穿、雪崩总结</h2></li></ul><blockquote><p>穿透无中生有key，布隆过滤null隔离</p><p>缓存击穿过期key，锁与非期解难题</p><p>雪崩大量过期key，过期时间要随机</p><p>面试必考三兄弟，可用限流来保底</p></blockquote><h2 id="双写一致"><a href="#双写一致" class="headerlink" title="双写一致"></a>双写一致</h2><p>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p><ul><li>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</li><li>写操作：延迟双删</li></ul><p>删除缓存——修改数据库—(延迟)—删除缓存</p><p>注意：先删除缓存回事先修改数据库都会出问题-脏数据(所以需要删除两次缓存)</p><h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p><strong>分布式锁</strong></p><p>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</p><p>排他锁：独占锁writeLock，加锁之后，阻塞其他线程的读写操作</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809205812468.png" alt="image-20230809205812468"></p><h3 id="延迟一致性"><a href="#延迟一致性" class="headerlink" title="延迟一致性"></a>延迟一致性</h3><p><strong>异步通知保证数据的最终一致性</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809205915306.png" alt="image-20230809205915306"></p><p>基于Canal的异步通知</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809205944365.png" alt="image-20230809205944365"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>允许延迟一致的业务，采用异步通知<ul><li>使用MQ中间件，更新数据之后，通知缓存删除</li><li>利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存</li></ul></li><li>强一致性的，采用Redisson提供的读写锁<ul><li>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</li><li>排他锁：独占锁writeLock，加锁之后，阻塞其他线程的读写操作</li></ul></li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB全称Redis Database Backup file（Redis数据备份文件），也叫做Redis数据快照。简单来说就是把内存中的所有数据记录到磁盘中。当Redis实例故障重启后，从磁盘中读取快照文件，恢复数据。</p><p><strong>主动备份</strong></p><p>save：由Redis主进程来执行RDB，会阻塞所有命令</p><p>bgsave：开启子进程执行RDB，避免主进程受到影响</p><p><strong>自动备份</strong></p><p>Redis内部有触发RDB的机制，可以在Redis.conf文件中找到，格式如下：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810143040716.png" alt="image-20230810143040716"></p><p><strong>RDB的执行原理</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810144106530.png" alt="image-20230810144106530"></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p>AOF默认是关闭的，需要修改redis.conf配置文件开启AOF：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810145042104.png" alt="image-20230810145042104"></p><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810145200302.png" alt="image-20230810145200302"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810145219166.png" alt="image-20230810145219166"></p><p> 因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<strong>bgrewriteaof</strong>命令，可以让AOF文件执行重写功能，用最少的命令达到相同的效果。</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810150041188.png" alt="image-20230810150041188"></p><p>Redis也会在触发阈值时自动取重写AOF文件。阈值也可以在redis.conf中配置：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810150218610.png" alt="image-20230810150218610"></p><h3 id="RBD和AOF对比"><a href="#RBD和AOF对比" class="headerlink" title="RBD和AOF对比"></a>RBD和AOF对比</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810150545557.png" alt="image-20230810150545557"></p><h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><p>Redis对数据设置数据的有效时间，数据过期之后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>设置过期Key的过期时间后，我们不去管它，当需要该key时，我们再检查是否过期，如果过期，我们就删除它，反之返回该key</p><p><strong>优点：</strong>对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p><p><strong>缺点：</strong>对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>每隔一段时间，我们就会对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key）</p><p>定期清理有两种模式：</p><ul><li>SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf的<strong>hz</strong>选项来调整这个次数</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><p><strong>优点：</strong>可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存</p><p><strong>缺点：</strong>难以确定删除操作执行的时长和频率</p><p><strong>Redis的过期删除策略：惰性删除+定期删除两种策略配合使用</strong></p><h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>当Redis中的内存不够用时，此时在向Redis中添加新的key,那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>Redis支持八种不同策略来选择要删除的key：</p><ul><li>noeviction:不淘汰如任何的key，但是内存满时不允许写入新数据，<strong>默认</strong></li><li>volatile-ttl：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key，随机进行淘汰</li><li>volatile-random：对设置了TTL的key，随机进行淘汰</li><li>allkeys-lru：对全体key，基于LRU算法进行淘汰</li><li>volatile-lru：对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu：对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu：对设置了TTL的key，基于LFU算法进行淘汰</li></ul><blockquote><ul><li>LRU（Least Recently Used）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰的优先级越高</li><li>LFU（Least Frequently Used）最少频率使用。会统计每一个key的访问频率，值越小淘汰优先级越高</li></ul></blockquote><p><strong>记单词</strong></p><blockquote><ul><li>eviction：驱逐</li><li>volatile：挥发性的</li><li>Least：最少</li><li>Recently：最近</li><li>Frequently：频率</li></ul></blockquote><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul><li>优先使用allkeys-lru策略。充分利用LRU算法的优势，把最近常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用</li><li>如果业务的数据访问频率差别不大，没有明显的冷热数据区分，建议使用allkeys-random，随机选择淘汰</li><li>如果业务中有置顶的需求，可以使用volatile-lru策略，同时把置顶的数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据</li><li>如果业务中有短时高频访问的数据，可以使用allkeys-lfu或volatile-lfu策略</li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>Redis实现分布式锁主要利用Redis的**<code>setnx</code>**命令。setnx是SET if not exists（如果不存在，则SET）的简写</p><p>获取锁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加锁，nx是互斥，ex是设置超时时间</span></span><br><span class="line">SET lock value NX EX 10</span><br></pre></td></tr></table></figure><p>问题来了，为什么不用setnx，然后再设置过期时间勒？</p><p>因为如果用<strong>两条命令的话，可能不能保证原子性</strong></p><p>释放锁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可</span></span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure><p>Redis实现分布式锁如何合理控制锁的有效时长？不能让它一直占着锁啊或者不能让它没有实现业务就释放锁啊</p><ul><li>根据业务执行时间预估（难以预估）</li><li>给锁续期（Redisson的看门狗）</li></ul><h3 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h3><p><strong>底层是setnx和lua脚本（保证原子性）</strong></p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810185856392.png" alt="image-20230810185856392"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redisLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//获取锁（重入锁），执行锁的名称</span></span><br><span class="line">    RLock lock=redissonClient.getLock(<span class="string">&quot;lockName&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别为：获取锁的最大等待时间（期间会重试），锁自动释放的时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock) &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>看门狗默认是每隔10秒续期</li><li>如果设置了锁自动释放的时间，那么Redisson认为你能把握业务执行的时间，看门狗机制就会失效</li><li>加锁、设置过期时间等操作都是基于lua脚本完成，保证了原子性</li></ul><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add1</span><span class="params">()</span> &#123;</span><br><span class="line">    RLock lock redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> isLock lock.tryLock(;</span><br><span class="line">    ∥执行业务</span><br><span class="line">    add2();</span><br><span class="line">    ∥释放锁</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add2</span><span class="params">()</span> &#123;</span><br><span class="line">    RLock lock redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> isLock lock.tryLock(;</span><br><span class="line">    ∥执行业务</span><br><span class="line">    ∥释放锁</span><br><span class="line">    lock.unlock(;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810191218071.png" alt="image-20230810191218071"></p><p><strong>必须要同一线程</strong></p><h4 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810191708302.png" alt="image-20230810191708302"></p><p>RedLock（红锁）：不能再一个redis实例上创建锁，应该是在多个redis实例上创建锁（n&#x2F;2+1），避免在一个redis实例上加锁</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810191739505.png" alt="image-20230810191739505"></p><blockquote><ul><li>CAP：C（一致性），A（可用性），P（分区容错）</li><li>AP思想：高可用和分区容错性</li><li>CP思想：一致性和分区容错性</li></ul></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810194450035.png" alt="image-20230810194450035"></p><h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><h4 id="主从全量同步"><a href="#主从全量同步" class="headerlink" title="主从全量同步"></a>主从<strong>全量同步</strong></h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810195159915.png" alt="image-20230810195159915"></p><p>Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p><p>offset：偏移量，随着记录在repl_baklog中的数据增多而越来越大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后与master，需要更新</p><h4 id="主从增量同步（slave重启或者后期数据变化）"><a href="#主从增量同步（slave重启或者后期数据变化）" class="headerlink" title="主从增量同步（slave重启或者后期数据变化）"></a>主从<strong>增量同步</strong>（slave重启或者后期数据变化）</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810195621517.png" alt="image-20230810195621517"></p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><ul><li><strong>监控：</strong>Sentinel会不断检查您的master和slave是否按照预期工作</li><li><strong>自动故障恢复：</strong>如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也将以新的master为主</li><li><strong>通知：</strong>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新的信息推给Redis的客户端</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810210534973.png" alt="image-20230810210534973"></p><h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p>Sentinel基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：如果超过指定数量（quorum）的sentinel都认为i该实例主观下线，则该实例<strong>客观下线</strong>。quorum最好超过Sentinel实例数量的一半。</li></ul><h3 id="哨兵选主规则"><a href="#哨兵选主规则" class="headerlink" title="哨兵选主规则"></a>哨兵选主规则</h3><ul><li>首先判断主与从节点断开时间长短，如超过指定值就排除该从节点</li><li>如果判断从节点的slave-priority值，越小优先级越高</li><li>如果slave-priority一样，则判断slave节点的offset值，越大优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高</li></ul><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>由于某种网络原因，主节点与sentinel集群断开连接了，但是没有宕机，sentinel集群会在剩下的从节点中选举一个为主节点。然后原来的主节点恢复后，只能成为新主节点的从节点。那么问题来了，在那段时间，客户端给老主节点的数据都丢失了</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810211746776.png" alt="image-20230810211746776"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810212046177.png" alt="image-20230810212046177"></p><p><strong>解决：</strong>Redis中有两个参数配置</p><p><code>min-replicas-to-write 1</code> 表示最少的salve节点为1个</p><p><code>min-replicas-max-lag 5</code> 表示数据复制和同步的延迟不能超过5秒</p><h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul><p>使用分片集群可以解决上诉问题，分片集群特征：</p><ul><li>集群中有多个master，每个master保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping检测彼此健康状态</li><li>客户端1请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810214027959.png" alt="image-20230810214027959"></p><h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><p>Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置到哪个槽，集群中每个节点负责一部分hash槽。</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810214435441.png" alt="image-20230810214435441"></p><h2 id="Redis是单线程的，但是为什么还是那么快-1"><a href="#Redis是单线程的，但是为什么还是那么快-1" class="headerlink" title="Redis是单线程的，但是为什么还是那么快-1"></a>Redis是单线程的，但是为什么还是那么快-1</h2><ul><li><p>Redis是纯内存操作，执行速度非常快</p></li><li><p>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</p></li><li><p>使用I&#x2F;O多路复用模型，非阻塞IO</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810221709994.png" alt="image-20230810221709994"></p></li></ul><h2 id="I-x2F-O多路复用模型-2"><a href="#I-x2F-O多路复用模型-2" class="headerlink" title="I&#x2F;O多路复用模型-2"></a>I&#x2F;O多路复用模型-2</h2><p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p><p><strong>先搞清下面概率：</strong></p><ul><li>用户空间和内核空间</li><li>常见的IO模型<ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li></ul></li><li>Redis网络模型</li></ul><h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><ul><li>Liux系统中一个进程使用的内存情况划分两部分：内核空间、用户空间</li><li>用户空间只能执行受限的命令(Rig3)，而且不能直接调用系统资源，必须通过内核提供的接口来访问</li><li>内核空间可以执行特权命令(Rig0)，调用一切系统资源</li></ul><p>Lux系统为了提高引O效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲☒</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220055789.png" alt="image-20230810220055789"></p><p>下面讲的模型是为了解决等待数据就绪时间和读数据读来读去的问题</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220313091.png" alt="image-20230810220313091"></p><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220452514.png" alt="image-20230810220452514"></p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810220821787.png" alt="image-20230810220821787"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810221022716.png" alt="image-20230810221022716"></p><h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230810221353978.png" alt="image-20230810221353978"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次关于Redis面试常被问到的问题分享就到这了，小编也是通过网上的学习来总结的。如有不足和错误的地方请联系小编来改正</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础篇</title>
      <link href="/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2023/08/01/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的十大数据类型"><a href="#Redis的十大数据类型" class="headerlink" title="Redis的十大数据类型"></a>Redis的十大数据类型</h2><h3 id="redis字符串（String）"><a href="#redis字符串（String）" class="headerlink" title="redis字符串（String）"></a>redis字符串（String）</h3><ul><li>string是redis最基本的类型，一个key对应一个value</li><li>string类型是二进制安全的，意思是redis的string可以包含任何数据，比如1jpg图片或者序列化的对象</li><li>string类型是redis对基本的数据类型，一个redis中字符串value最多可以是512M</li></ul><h3 id="redis列表（List）"><a href="#redis列表（List）" class="headerlink" title="redis列表（List）"></a>redis列表（List）</h3><ul><li>redis列表是最简单的字符串列表，按照插入的顺序排列。你可以添加一个元素到列表的头部（左边）或者是尾部（右边）</li><li>它的底层实际上是个双端链表，最多可以包含2^32-1个元素（4294967295，每个列表超过40亿个元素）</li></ul><h3 id="redis哈希表（Hash）"><a href="#redis哈希表（Hash）" class="headerlink" title="redis哈希表（Hash）"></a>redis哈希表（Hash）</h3><ul><li>redis hash是一个string类型的field（字段）和value（值）的映射表，hash特别适合用于存储对象。</li><li>redis中每个hash可以存储2^32-1个键值对</li></ul><h3 id="redis集合（Set）"><a href="#redis集合（Set）" class="headerlink" title="redis集合（Set）"></a>redis集合（Set）</h3><ul><li>redis的Set是String类型的无序集合。集合的成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是intset或者hashtable</li><li>redis中Set集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)。</li><li>集合中最大的成员数为2^32-1</li></ul><h3 id="reids有序集合（ZSet）"><a href="#reids有序集合（ZSet）" class="headerlink" title="reids有序集合（ZSet）"></a>reids有序集合（ZSet）</h3><ul><li>ZSet(sorted set：有序集合)</li><li>redis zset和set一样也是string类型元素的集合，且不允许有重复的成员</li><li>不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序</li><li>zset的成员是唯一的，但分数（score）却可以重复</li><li>zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1</li></ul><h3 id="redis地理空间（GEO）"><a href="#redis地理空间（GEO）" class="headerlink" title="redis地理空间（GEO）"></a>redis地理空间（GEO）</h3><ul><li>reids GEO主要用于存储地理位置信息，并对存储的信息进行操作，包括添加地理位置的坐标、获取地理位置的坐标、计算两个地理位置之间的距离、根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</li></ul><h3 id="redis基数统计（HyperLogLog）"><a href="#redis基数统计（HyperLogLog）" class="headerlink" title="redis基数统计（HyperLogLog）"></a>redis基数统计（HyperLogLog）</h3><ul><li>HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是：在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定且是很小的</li><li>在redis里面，每个HyperLogLog键只需要花费12KB内存就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多消耗的内存就越多的集合形成了鲜明的对比。</li><li>但是，因为HyperLogLog只会根据输入的元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</li></ul><h3 id="redis位图（bigmap）"><a href="#redis位图（bigmap）" class="headerlink" title="redis位图（bigmap）"></a>redis位图（bigmap）</h3><ul><li><p>Bit arrays（or simply bitmaps，我们可以称之为位图）</p></li><li><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604193941229.png" alt="image-20230604193941229"></p></li><li><p>由0和1状态表现的二进制位的bit数组</p></li></ul><h3 id="redis位域（bitfield）"><a href="#redis位域（bitfield）" class="headerlink" title="redis位域（bitfield）"></a>redis位域（bitfield）</h3><ul><li>通过bitfield命令可以一次性操作多个<strong>比特位域</strong>（指的是连续的多个比特位），它会执行一系列操作并且返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</li><li>说白了就是通过bitfield命令我们可以一次性对多个比特位域进行操作</li></ul><h3 id="redis流（Stream）"><a href="#redis流（Stream）" class="headerlink" title="redis流（Stream）"></a>redis流（Stream）</h3><ul><li>redis Stream是redis 5.0版本新增加的数据结构。</li><li>redis Stream主要用于消息队列（MQ），redis本身是有一个redis发布订阅（pub&#x2F;sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开，redis宕机等，消息就会被丢弃。</li><li>简单来说发布订阅可以分发消息，但无法记录历史消息</li><li>而redis Stream提供的消息持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</li></ul><h2 id="Redis键（Key）"><a href="#Redis键（Key）" class="headerlink" title="Redis键（Key）"></a>Redis键（Key）</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ul><li>del key：删除存在的key</li><li>dump key：序列化给定key，并返回被序列化的值</li><li>exists key：检查给定key是否存在</li><li>expire key seconds：为给定的key设置过期时间</li><li>keys pattern：查找所有符合给定模式（pattern）的key</li><li>move key db：将当前数据库的key移动到给定的数据库db中</li><li>persist  key：移除key的过期时间，key将持久保持</li><li>pttl key：以毫秒返回key的剩余的过期时间</li><li>ttl key：以秒为单位，返回给定key的剩余生存时间</li><li>randomkey：从当前数据库随机返回一个key</li><li>rename key newkey：修改key的名称</li><li>renamenx key newkey：仅当newkey不存在时，将key改名为newkey</li><li>type key：返回key所存储的值的类型</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>keys *：查看当前库的所有key</li><li>unlink key：非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续的异步中操作</li><li>select dbindex（0-15）：切换数据库，默认为0</li><li>dbsize：查看当前数据库key的数量</li><li>flushdb：清空当前库</li><li>flushall：通杀全部库</li></ul><h2 id="数据类型命令及落地运用"><a href="#数据类型命令及落地运用" class="headerlink" title="数据类型命令及落地运用"></a>数据类型命令及落地运用</h2><h3 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604212922726.png" alt="image-20230604212922726"></p><h4 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h4><ul><li>set key value</li><li>get key</li></ul><h4 id="同时设置-x2F-获取多个键值"><a href="#同时设置-x2F-获取多个键值" class="headerlink" title="同时设置&#x2F;获取多个键值"></a>同时设置&#x2F;获取多个键值</h4><ul><li>mset key value[key value….]</li><li>mget key[key…]</li><li>msetnx：同时设置一个或多个键值对时当且仅当所有给定的key都不存在</li></ul><h4 id="获取-x2F-设置指定范围的值"><a href="#获取-x2F-设置指定范围的值" class="headerlink" title="获取&#x2F;设置指定范围的值"></a>获取&#x2F;设置指定范围的值</h4><ul><li>getrange&#x2F;setrange key between…and</li></ul><h4 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h4><p>一定要是数字才能进行加减</p><ul><li>递增&#x2F;递减：incr key&#x2F;decr key</li><li>增加&#x2F;减少指定的整数：incrby&#x2F;decrby key 多少</li></ul><h4 id="获取字符串长度和内容追加"><a href="#获取字符串长度和内容追加" class="headerlink" title="获取字符串长度和内容追加"></a>获取字符串长度和内容追加</h4><ul><li>strlen key</li><li>append key value</li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li>setnx key value：只有在key不存在时设置key的值</li><li>setex：设置带过期时间的key，动态设置</li></ul><h4 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h4><ul><li>getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)</li></ul><h3 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604213144877.png" alt="image-20230604213144877"></p><h4 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h4><p>单key多value</p><ul><li><p>一个双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。</p></li><li><p>left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p></li><li><p>它的底层实际是个<strong>双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</strong></p></li></ul><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ul><li>lpush&#x2F;rpush&#x2F;lrange</li><li>lpop&#x2F;rpop</li><li>lindex：按照索引下标获得元素（从上到下）</li><li>llen：获取列表中元素的个数</li><li>lrem key 数字N 给定值v1：删除N个值等于v1的元素</li><li>ltrim key 开始index 结束index：截取指定范围的值后再赋值给key</li><li>rpoplpush 源列表 目的列表：移除列表的最后一个元素，并将该元素添加到另一个列表并返回</li><li>lset key index value：将下标位置的值设置为value</li><li>linsert key before&#x2F;after ：在list某个已有值的前后再添加具体值</li></ul><p>微信公众号订阅的消息</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604215441175.png" alt="image-20230604215441175"></p><h3 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604215608650.png" alt="image-20230604215608650"></p><p><strong>KV模式不变，但V是一个键值对</strong></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>JD购物车早期，设计目前不再采用，当前中小厂可用</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220140355.png" alt="image-20230604220140355"></p><h3 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220501578.png" alt="image-20230604220501578"></p><p><strong>单值多value，且无重复</strong></p><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>微信抽奖小程序</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604220652689.png" alt="image-20230604220652689"></p><p>朋友圈点赞</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222142611.png" alt="image-20230604222142611"></p><h3 id="Redis有序集合（ZSet）"><a href="#Redis有序集合（ZSet）" class="headerlink" title="Redis有序集合（ZSet）"></a>Redis有序集合（ZSet）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222402880.png" alt="image-20230604222402880"></p><p>在set的基础上，每个value前加了一个score分数值。之前set k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2</p><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222638776.png" alt="image-20230604222638776"></p><h3 id="Redis位图（bitmap）"><a href="#Redis位图（bitmap）" class="headerlink" title="Redis位图（bitmap）"></a>Redis位图（bitmap）</h3><p>由0和1状态表现的二进制位的bit数组</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222850415.png" alt="image-20230604222850415"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604222947562.png" alt="image-20230604222947562"></p><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223220863.png" alt="image-20230604223220863"></p><h3 id="Redis基数统计（HyperLogLog）"><a href="#Redis基数统计（HyperLogLog）" class="headerlink" title="Redis基数统计（HyperLogLog）"></a>Redis基数统计（HyperLogLog）</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223534692.png" alt="image-20230604223534692"></p><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604223630392.png" alt="image-20230604223630392"></p><h3 id="Redis地理空间（GEO）"><a href="#Redis地理空间（GEO）" class="headerlink" title="Redis地理空间（GEO）"></a>Redis地理空间（GEO）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>移动互联网时代LBS应用越来越多，交友软件中附近的小姐姐、外卖软件中附近的美食店铺、高德地图附近的核酸检查点等等，那这种附近各种形形色色的XXX地址位置选择是如何实现的？</li><li>地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。</li><li>例如滴滴打车，最直观的操作就是实时记录更新各个车的位置，然后当我们要找车时，在数据库中查找距离我们(坐标x0,y0)附近r公里范围内部的车辆</li></ul><p>使用下面的SQL即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> taxi <span class="keyword">from</span> position <span class="keyword">where</span> x0<span class="operator">-</span>r <span class="operator">&lt;</span> x <span class="operator">&lt;</span> x0 <span class="operator">+</span> r <span class="keyword">and</span> y0<span class="operator">-</span>r <span class="operator">&lt;</span> y <span class="operator">&lt;</span> y0<span class="operator">+</span>r</span><br></pre></td></tr></table></figure><p>但是这样会出现什么问题？</p><ul><li>查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的</li><li>这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问</li><li>精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差</li></ul><h3 id="Redis流（Stream）"><a href="#Redis流（Stream）" class="headerlink" title="Redis流（Stream）"></a>Redis流（Stream）</h3><p>Redis版的MQ消息中间件+阻塞队列</p><p>Stream还是不能百分百等价于Kafka、RabbitMQ来使用，生产案例少</p><h3 id="Redis位域（bitfield）"><a href="#Redis位域（bitfield）" class="headerlink" title="Redis位域（bitfield）"></a>Redis位域（bitfield）</h3><p>将一个Redis字符串看作是一个由二进制位组成的数组，并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604225341790.png" alt="image-20230604225341790"></p><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul><li>实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写道磁盘上，也就是快照。这样一来即使故障宕机，快照也不会丢失，数据的可靠性也就得到了保证。</li><li>这个快照文件就称为RDB文件（dump.rdb）</li></ul><h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot内存快照，它恢复时再将硬盘快照文件直接读回到内存里</li><li>redis的数据都在内存中，保存备份时它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中，一锅端</li></ul><h4 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h4><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li>Save：在主程序中执行会阻塞当前的Redis服务器，直到持久化工作完成。执行sava命令期间，Redis不能处理其他命令，线上禁止使用</li><li>BGSAVE（默认）：Redis会在后台异步进行快照操作，不阻塞快照的同时还可以响应客户端请求，该触发方式会fork一个子进程由子进程复制持久化过程</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>适合大规模的数据恢复</li><li>按照业务定时备份</li><li>对数据完整性和一致性要求不高</li><li>RDB文件在内存中的加载速度要比AOF快得多</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong></li><li>内存数据的全量同步，如果数据量太大会导致I&#x2F;O严重影响服务器性能</li><li>RDB依赖于主进程的fork，在更大的数据集中，这可能导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑</li></ul><h4 id="什么时候会触发RDB快照"><a href="#什么时候会触发RDB快照" class="headerlink" title="什么时候会触发RDB快照"></a>什么时候会触发RDB快照</h4><ul><li>配置文件中默认的快照配置</li><li>手动sava&#x2F;bgsave命令</li><li>执行flushall&#x2F;flushdb命令也会产生dump.rdb文件，但是里面是空的，无意义</li><li>执行shutdown且没有设置开启AOF持久化</li><li>主从复制时，主节点自动触发</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230604235839606.png" alt="image-20230604235839606"></p><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><ul><li>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li><li>默认情况下，redis是没有开启AOF的。开启AOF功能需要设置配置：appendonly yes</li><li>AOF保存的是appendonly.aof文件</li></ul><h4 id="AOF持久化工作流程"><a href="#AOF持久化工作流程" class="headerlink" title="AOF持久化工作流程"></a>AOF持久化工作流程</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605001309817.png" alt="image-20230605001309817"></p><h4 id="AOF缓冲区三种写回策略"><a href="#AOF缓冲区三种写回策略" class="headerlink" title="AOF缓冲区三种写回策略"></a>AOF缓冲区三种写回策略</h4><ul><li>Always:同步写回，每个写命令执行完立刻同步的将日志写回磁盘</li><li>everysec：每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓存区中的内容写入磁盘</li><li>no:操作系统控制的写回，每个写命令执行完，只是先把日志文件写到AOF文件的内存缓存区，由操作系统决定何时将缓冲区内容写回到磁盘</li></ul><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605185533896.png" alt="image-20230605185533896"></p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>更好的保护数据不丢失、性能高、可做紧急恢复</p><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul><li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li><li>aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li></ul><h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><ul><li>由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。</li><li>为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的峰值时，Redis就会<strong>自动</strong>启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集或者可以手动使用命令 bgrewriteaof 来重新。</li></ul><h5 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h5><ol><li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li><li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</li><li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li><li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中</li><li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li></ol><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605190311924.png" alt="image-20230605190311924"></p><h3 id="RDB-AOF混合持久化"><a href="#RDB-AOF混合持久化" class="headerlink" title="RDB+AOF混合持久化"></a>RDB+AOF混合持久化</h3><p>结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。</p><h4 id="开启混合方式设置"><a href="#开启混合方式设置" class="headerlink" title="开启混合方式设置"></a>开启混合方式设置</h4><p>设置aof-use-rdb-preamble的值为 yes  yes表示开启，设置为no表示禁用</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>RDB镜像做全量持久化，AOF做增量持久化</strong></p><p>先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。**—-》AOF包括了RDB头部+AOF混写**</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>可以一次性执行多个命令，本质是一组命令的集合。一个事务的所有命令都会被序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞</p><h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>一个队列中，一次性、顺序性、排他性地执行一系列命令</p><h3 id="Redis事务VS数据量事务"><a href="#Redis事务VS数据量事务" class="headerlink" title="Redis事务VS数据量事务"></a>Redis事务VS数据量事务</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605191245403.png" alt="image-20230605191245403"></p><h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605191354653.png" alt="image-20230605191354653"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li>开启：以multi开始一个事务</li><li>入队：将多个命令入队到事务中，接到这些命令不会立刻执行，而是放到等待执行地事务队列里面</li><li>执行：由exec命令触发事务</li></ul><h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>由一个面试题引出管道</p><p><strong>如何优化频繁命令往返造成地性能瓶颈？</strong></p><p>Redis是一种基于客户端-服务端模型以及请求&#x2F;响应协议的TCP服务。一个请求会遵循以下步骤：</p><ol><li>客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。</li><li>服务端处理命令，并将结果返回给客户端。</li></ol><p><strong>上述两步称为：Round Trip Time(简称RTT,数据包往返于两端的时间)</strong></p><p>如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好</p><h3 id="解决思路（使用管道）"><a href="#解决思路（使用管道）" class="headerlink" title="解决思路（使用管道）"></a>解决思路（使用管道）</h3><p>管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230605205315616.png" alt="image-20230605205315616"></p><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><h4 id="Pipeline与原生批量命令对比"><a href="#Pipeline与原生批量命令对比" class="headerlink" title="Pipeline与原生批量命令对比"></a>Pipeline与原生批量命令对比</h4><ul><li>原生批量命令是原子性（例如：mset，mget），pipeline是非原子性</li><li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令</li><li>原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成</li></ul><h4 id="Pipeline与事务对比"><a href="#Pipeline与事务对比" class="headerlink" title="Pipeline与事务对比"></a>Pipeline与事务对比</h4><ul><li>事务具有原子性，管道不具有原子性</li><li>管道一次性将多条命令发送到服务器，事务是一条一条地发，事务只有在接收到exec命令之后才会执行，管道不会</li><li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会</li></ul><h4 id="使用Pipeline注意事项"><a href="#使用Pipeline注意事项" class="headerlink" title="使用Pipeline注意事项"></a>使用Pipeline注意事项</h4><ul><li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中发生异常，将会继续执行后续的指令</li><li>使用pipeline组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存</li></ul><h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种消息通信模式：发送者（PUBLISH）发送消息，订阅者（SUBSCRIBE）接受消息，可以实现进程间的消息传递</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>发布的消息在Redis系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃。</li><li>消息只管发送，对于发布者而言消息是即发即失的，不管接受，也没有ACK机制，无法保证消息的消费成功</li><li>以上缺点导致Redis的Pub&#x2F;Sub模式就像个小玩具，在生产环境中无用武之地，为此Redis5.0版本新增了Stream数据结构，不但支持多播，还支持数据持久化，相比Pub&#x2F;Sub更加的强大</li></ul><h2 id="Redis复制（replica）"><a href="#Redis复制（replica）" class="headerlink" title="Redis复制（replica）"></a>Redis复制（replica）</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p>就是主从复制，master以写为主，Slave以读为主。当master数据变化的时候，自动将新的数据异步同步到其他slave数据库</p><h3 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>读写分离</li><li>容灾恢复</li><li>数据备份</li><li>水平扩容支持高并发</li></ul><h3 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a>怎么玩</h3><p><strong>配从（库）不配主（库）</strong></p><p><strong>权限细节-重要</strong>：</p><p>master如果配置了requirepass参数，需要密码登录，那么slave就要配置masterauth来设置校验密码，否则的话master就会拒绝slave的访问请求</p><p><strong>基本操作命令</strong></p><ul><li><p>info replication:可以查看复制节点的主从关系和配置信息</p></li><li><p>replicaof 主库IP 主库端口（一般写入redis.conf配置文件内）</p></li><li><p>slaveof 主库IP 主库端口</p><ul><li>每次与master断开之后，都需要重写连接，除非你配置进redis.conf文件</li><li>在运行期间修改slave节点的信息，如果该数据库已经是某个朱主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，重新拜码头</li></ul></li><li><p>slaveof no one：使当前数据库停止与其他数据库的同步，转为主数据库，自立为王</p></li></ul><h3 id="复制原理和工作流程"><a href="#复制原理和工作流程" class="headerlink" title="复制原理和工作流程"></a>复制原理和工作流程</h3><ul><li><p>slave启动，同步初请</p><ul><li>slave启动成功连接到master后会发送一个sync命令</li><li>slave首次全新连接master，一次完全同步（全量复制）将自动执行，slave自身原有的数据会被master数据覆盖清除</li></ul></li><li><p>首次连接，全量复制</p><ul><li>master节点受到sync命令后开始在后台保存快照（即RDB持久化，主从复制时会触发RDB），同时收集所有接受到的用于修改数据集命令缓存起来，master节点执行RDB持久化完后，master将rdb快照文件和所有缓存的命令发送到所有slave，以完成一次完全同步</li><li>而slave服务在接受到数据库文件数据后，将其存盘并加载到内存中，从而完成复制初始化</li></ul></li><li><p>心跳持续，保持通信：repl-ping-replica-period 10（配置文件）</p></li><li><p>进入平稳，增量复制：master继续将新的所有收集到的修改命令自动依次传给slave，完成同步</p></li><li><p>从机下线，重连续传：master会检查backlog里面的offset，master和slave都会保存一个复制的offset还有一个masterId，offset是保存在backlog中的。master智慧把已经复制的offset后面的数据复制给slave，类似于断点续传</p></li></ul><h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><ul><li>复制延迟，信号衰减：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li><li>master挂了如何办?:默认情况下，不会再slave节点中自动重选一个master</li></ul><h2 id="Redis哨兵（sentinel）"><a href="#Redis哨兵（sentinel）" class="headerlink" title="Redis哨兵（sentinel）"></a>Redis哨兵（sentinel）</h2><h3 id="是什么-5"><a href="#是什么-5" class="headerlink" title="是什么"></a>是什么</h3><ul><li>吹哨人巡查监控后台master主机是否故障，如果故障了根据<strong>投票数</strong>自动将某一个从库转化为新主库，继续对外服务</li><li>哨兵的作用<ul><li>监控redis运行状态，包括master和slave</li><li>当master down机，能自动将slave切换成新master</li></ul></li></ul><h3 id="能干嘛-3"><a href="#能干嘛-3" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>主从监控：监控主从redis库是否正常</li><li>消息通知：哨兵可以将故障转移的结果发送给客户端</li><li>故障转移：如果master异常，则会进行主从切换，将其中一个slave作为新master</li><li>配置中心：客户端通过连接哨兵来获得当前Redis服务的主节点地址</li></ul><h3 id="怎么玩-2"><a href="#怎么玩-2" class="headerlink" title="怎么玩"></a>怎么玩</h3><ul><li>3个哨兵：自动监控和维护集群，不存放数据，只是吹哨人</li><li>1主2从：用于数据读取和存放</li></ul><h3 id="哨兵运行流程和选举流程"><a href="#哨兵运行流程和选举流程" class="headerlink" title="哨兵运行流程和选举流程"></a>哨兵运行流程和选举流程</h3><p>当一个主从配置中的master失效之后，sentinel可以选举出一个新的master用于自动接替原master的工作，主从配置中的其他Redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换</p><p><strong>运行流程，故障切换</strong></p><ul><li><p>三个哨兵监控一主二从，正常运行中</p></li><li><p>SDown主观下线（Subjectively Down）：所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。主观下线就是说如果服务器在[sentinel down-after-milliseconds]给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了</p></li><li><p>ODown客观下线（Objectively Down）：<img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606014519549.png" alt="image-20230606014519549"></p></li><li><p>选举出领导者哨兵（哨兵中选出兵王）：当主节点被判断客观下线以后，各个哨兵节点会进行协商，先选举出一个<strong>领导哨兵节点（兵王）</strong>并由该领导者节点，也即被选举出的兵王进行failover（故障迁移）</p><ul><li>哨兵领导者如何选出来的？Raft算法：监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路<strong>是先到先得</strong>：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者</li></ul></li><li><p>由兵王开始推动故障切换流程并选出一个新master</p><ul><li>新主登基</li><li>群臣俯首</li><li>旧主拜服</li></ul></li></ul><p>上述的failover流程操作均由sentinel自己独立完成，完全无需人工干预</p><h3 id="哨兵的使用建议"><a href="#哨兵的使用建议" class="headerlink" title="哨兵的使用建议"></a>哨兵的使用建议</h3><ul><li>哨兵节点的数量应为多个，哨兵本身应该为集群，保证高可用</li><li>哨兵节点的数量应该是奇数</li><li>各个哨兵节点的配置应一致</li><li>如果哨兵节点部署在Docker等容器里面，尤其要注意端口的正确映射</li><li>哨兵集群+主从复制，<strong>并不能保证数据零丢失</strong>（承上启下引出集群）</li></ul><h2 id="Redis集群（cluster）"><a href="#Redis集群（cluster）" class="headerlink" title="Redis集群（cluster）"></a>Redis集群（cluster）</h2><h3 id="是什么-6"><a href="#是什么-6" class="headerlink" title="是什么"></a>是什么</h3><ul><li><p><strong>由于数据量过大</strong>，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。</p></li><li><p>Redis集群是一个提供在多个Redis节点间共享数据的程序集</p></li><li><p>Redis集群可以支持多个master</p></li></ul><h3 id="能干嘛-4"><a href="#能干嘛-4" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li><p>Redis集群支持多个Master，每个Master又可以挂载多个Slave</p><ul><li>读写分离</li><li>支持数据的高可用</li><li>支持海量数据的读写存储操作</li></ul></li><li><p>由于Cluster自带Sentinel的故障迁移机制，内置了高可用的支持，无需再去使用哨兵功能</p></li><li><p>客户端与Redis的节点连接，不再需要连接集群中的所有的节点，只需要任意连接集群中的一个可用节点即可</p></li><li><p>槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</p></li></ul><h3 id="集群算法-分片-槽位slot"><a href="#集群算法-分片-槽位slot" class="headerlink" title="集群算法-分片-槽位slot"></a>集群算法-分片-槽位slot</h3><h4 id="redis集群的槽位slot"><a href="#redis集群的槽位slot" class="headerlink" title="redis集群的槽位slot"></a>redis集群的槽位slot</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191650387.png" alt="image-20230606191650387"></p><h4 id="redis集群的分类"><a href="#redis集群的分类" class="headerlink" title="redis集群的分类"></a>redis集群的分类</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191758578.png" alt="image-20230606191758578"></p><h4 id="它俩的优势"><a href="#它俩的优势" class="headerlink" title="它俩的优势"></a>它俩的优势</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606191915673.png" alt="image-20230606191915673"></p><h4 id="slot槽位映射，一般业界有3种解决方案"><a href="#slot槽位映射，一般业界有3种解决方案" class="headerlink" title="slot槽位映射，一般业界有3种解决方案"></a>slot槽位映射，一般业界有3种解决方案</h4><h5 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h5><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606192717947.png" alt="image-20230606192717947"></p><h5 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h5><p><strong>三大步骤：</strong></p><ul><li><p>算法构建一致性哈希环</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193610219.png" alt="image-20230606193610219"></p></li><li><p>redis服务器IP节点映射</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193652277.png" alt="image-20230606193652277"></p></li><li><p>key落到服务器的落键规则</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606193723898.png" alt="image-20230606193723898"></p></li></ul><p><strong>优点</strong></p><ul><li><p>一致性哈希算法的<strong>容错性</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194015649.png" alt="image-20230606194015649"></p></li><li><p>一致性哈希算法的<strong>扩展性</strong></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194040349.png" alt="image-20230606194040349"></p></li></ul><p><strong>缺点</strong></p><p>一致性哈希算法的<strong>数据倾斜</strong>的问题</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194127978.png" alt="image-20230606194127978"></p><h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194409589.png" alt="image-20230606194409589"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606194444099.png" alt="image-20230606194444099"></p><h4 id="经典面试题：为什么redis集群的最大槽数是16384个"><a href="#经典面试题：为什么redis集群的最大槽数是16384个" class="headerlink" title="经典面试题：为什么redis集群的最大槽数是16384个?"></a>经典面试题：为什么redis集群的最大槽数是16384个?</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606200937900.png" alt="image-20230606200937900"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213142693.png" alt="image-20230606213142693"></p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213156235.png" alt="image-20230606213156235"></p><h4 id="redis集群不保证强一致性"><a href="#redis集群不保证强一致性" class="headerlink" title="redis集群不保证强一致性"></a>redis集群不保证强一致性</h4><p>意味着在特定的条件下，redis集群可能会丢掉一些被系统收到的写入请求命令</p><h3 id="集群常用操作命令和CRC16算法分析"><a href="#集群常用操作命令和CRC16算法分析" class="headerlink" title="集群常用操作命令和CRC16算法分析"></a>集群常用操作命令和CRC16算法分析</h3><ul><li><p>不在同一slot槽位下的多键操作支持不好，通识占位符登场</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213612595.png" alt="image-20230606213612595"></p></li><li><p>Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽</p></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><p>cluster-require-full-coverage：集群是否完整才能对外提供服务</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230606213817703.png" alt="image-20230606213817703"></p></li><li><p>cluster countkeysinslot 槽位数字编号：1，该槽位被占用，0，该槽位没有被占用</p></li><li><p>cluster keyslot 键名称：该键应该存在哪个槽位上</p></li></ul><h2 id="SpringBoot集成Redis"><a href="#SpringBoot集成Redis" class="headerlink" title="SpringBoot集成Redis"></a>SpringBoot集成Redis</h2><h3 id="集成Jedis"><a href="#集成Jedis" class="headerlink" title="集成Jedis"></a>集成Jedis</h3><h3 id="集成lettuce"><a href="#集成lettuce" class="headerlink" title="集成lettuce"></a>集成lettuce</h3><h3 id="集成RedisTemplate-推荐使用"><a href="#集成RedisTemplate-推荐使用" class="headerlink" title="集成RedisTemplate-推荐使用"></a>集成RedisTemplate-推荐使用</h3><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>上面的都是自己通过学习Redis网课的时候整理的Redis的基本知识，后续也会更新Redis的高级部分。如有不足和错误的地方请联系小编来改正。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arrays.asList()避坑指南</title>
      <link href="/2023/07/20/Arrays-asList-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"/>
      <url>/2023/07/20/Arrays-asList-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近使⽤ <code>Arrays.asList()</code> 遇到了⼀些坑。所以，⾃⼰对于这块⼩知识点进⾏了简单的总结。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Arrays.asList()</code> 在平时开发中还是⽐较常⻅的，我们可以使⽤它将⼀个数组转换为⼀个 List 集 合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;；</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上⾯两个语句等价于下⾯⼀条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure><p>JDK 源码对于这个⽅法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*返回由指定数组⽀持的固定⼤⼩的列表。此⽅法作为基于数组和基于集合的API之间的桥梁，与 Collection.toArray()结合使⽤。返回的List是可序列化并实现RandomAccess接⼝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="《阿⾥巴巴-Java-开发⼿册》对其的描述"><a href="#《阿⾥巴巴-Java-开发⼿册》对其的描述" class="headerlink" title="《阿⾥巴巴 Java 开发⼿册》对其的描述"></a>《阿⾥巴巴 Java 开发⼿册》对其的描述</h2><p><code>Arrays.asList()</code> 将数组转换为集合后,底层其实还是数组，《阿⾥巴巴 Java 开发⼿册》对于这个 ⽅法有如下描述：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809144507650.png" alt="image-20230809144507650"></p><h2 id="使⽤时的注意事项总结"><a href="#使⽤时的注意事项总结" class="headerlink" title="使⽤时的注意事项总结"></a>使⽤时的注意事项总结</h2><p><strong>传递的数组必须是对象数组，⽽不是基本类型。</strong></p><p><strong>Arrays.asList() 是泛型⽅法，传⼊的对象必须是对象数组。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span> [] array=(<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当传⼊⼀个原⽣数据类型数组时， Arrays.asList() 的真正得到的参数就不是数组中的元素，⽽是 数组对象本身！此时 List 的唯⼀元素就是这个数组，这也就解释了上⾯的代码。</p><p>使⽤集合的修改⽅法: add() 、 remove() 、 clear() 会抛出异常:<code>UnsupportedOperationException</code></p><p>Arrays.asList() ⽅法返回的并不是 java.util.ArrayList ，⽽是 java.util.Arrays 的 ⼀个内部类,这个内部类并没有实现集合的修改⽅法或者说并没有重写这些⽅法。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次关于Arrays.asList的一些坑就讲到这里了，大部分是通过网上学习才知道的，如有错误和不足请联系小编改正。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的七种遍历方式与性能分析</title>
      <link href="/2023/07/09/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2023/07/09/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 JDK 1.8 Streams API 的发布，使得 HashMap 拥有了更多的遍历的方式。</p><h2 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h2><p>HashMap遍历从大的方向来说，可以分为四类：</p><blockquote><ul><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）；</li><li>Streams API 遍历（JDK 1.8+）；</li></ul></blockquote><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><blockquote><ul><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ul></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1-迭代器-EntrySet"><a href="#1-迭代器-EntrySet" class="headerlink" title="1.迭代器 EntrySet"></a>1.迭代器 EntrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-迭代器KeySet"><a href="#2-迭代器KeySet" class="headerlink" title="2.迭代器KeySet"></a>2.迭代器KeySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ForEach-EntrySet"><a href="#3-ForEach-EntrySet" class="headerlink" title="3.ForEach EntrySet"></a>3.ForEach EntrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-ForEach-KeySet"><a href="#4-ForEach-KeySet" class="headerlink" title="4.ForEach KeySet"></a>4.ForEach KeySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Lambda"><a href="#5-Lambda" class="headerlink" title="5.Lambda"></a>5.Lambda</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Streams-API-单线程"><a href="#6-Streams-API-单线程" class="headerlink" title="6.Streams API 单线程"></a>6.Streams API 单线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Streams-API-多线程"><a href="#7-Streams-API-多线程" class="headerlink" title="7.Streams API 多线程"></a>7.Streams API 多线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>接下来我们使用 Oracle 官方提供的性能测试工具 JMH（Java Microbenchmark Harness，JAVA 微基准测试套件）来测试一下这 7 种循环的性能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后编写测试代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.Throughput)</span> <span class="comment">// 测试类型：吞吐量</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 预热 2 轮，每次 1s</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 测试 5 轮，每次 3s</span></span><br><span class="line"><span class="meta">@Fork(1)</span> <span class="comment">// fork 1 个线程</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 每个测试线程一个实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapCycle</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>() &#123;&#123;</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            put(i, <span class="string">&quot;val:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="comment">// 启动基准测试</span></span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(HashMapCycle.class.getSimpleName()) <span class="comment">// 要导入的测试类</span></span><br><span class="line">                .output(<span class="string">&quot;/Users/admin/Desktop/jmh-map.log&quot;</span>) <span class="comment">// 输出测试结果的文件</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run(); <span class="comment">// 执行测试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 单线程遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 多线程遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有被添加了 <code>@Benchmark</code> 注解的方法都会被测试，测试结果如下：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/640.png" alt="640"></p><p>其中 Score 列表示平均执行时间， <code>±</code> 符号表示误差。从以上结果可以看出，<strong>如果加上后面的误差值的话，可以得出的结论是，除了并行循环的 <code>parallelStream</code> 性能比极高之外（多线程方式性能肯定比较高），其他方式的遍历方法在性能方面几乎没有任何差别。</strong></p><h2 id="性能原理分析"><a href="#性能原理分析" class="headerlink" title="性能原理分析"></a>性能原理分析</h2><p>要理解性能测试的结果，我们需要把所有遍历代码通过 <code>javac</code>，编译成字节码来看具体的原因，编译之后我们使用 Idea 打开字节码信息，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="number">0</span>; var1 &lt; <span class="number">2</span>; ++var1) &#123;</span><br><span class="line">                <span class="built_in">this</span>.put(var1, <span class="string">&quot;val:&quot;</span> + var1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMapTest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">        entrySet();</span><br><span class="line">        keySet();</span><br><span class="line">        forEachEntrySet();</span><br><span class="line">        forEachKeySet();</span><br><span class="line">        lambda();</span><br><span class="line">        streamApi();</span><br><span class="line">        parallelStreamApi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">        map.forEach((var0, var1) -&gt; &#123;</span><br><span class="line">            System.out.println(var0);</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">streamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        map.entrySet().stream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallelStreamApi</span><span class="params">()</span> &#123;</span><br><span class="line">        map.entrySet().parallelStream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，除了 Lambda 和 Streams API 之外，通过迭代器循环和 <code>for</code> 循环的遍历的 <code>EntrySet</code> 最终生成的代码是一样的，他们都是在循环中创建了一个遍历对象 <code>Entry</code> ，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而通过迭代器和 <code>for</code> 循环遍历的 <code>KeySet</code> 代码也是一样的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>KeySet</code> 在循环中创建了一个 <code>Integer</code> 的局部变量，并且值是从 <code>map</code> 对象中直接获取的。</p><p><strong>所以通过字节码来看，使用 <code>EntrySet</code> 和 <code>KeySet</code> 代码差别不是很大，并不像网上说的那样 <code>KeySet</code> 的性能远不如 <code>EntrySet</code>，因此从性能的角度来说 <code>EntrySet</code> 和 <code>KeySet</code> 几乎是相近的，但从代码的优雅型和可读性来说，还是推荐使用 <code>EntrySet</code>。</strong></p><h2 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h2><h3 id="1-迭代器方式"><a href="#1-迭代器方式" class="headerlink" title="1.迭代器方式"></a>1.迭代器方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show:<span class="number">0</span></span><br><span class="line">del:<span class="number">1</span></span><br><span class="line">show:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>测试结果：<strong>迭代器中循环删除数据安全</strong>。</p><h3 id="2-For-循环方式"><a href="#2-For-循环方式" class="headerlink" title="2.For 循环方式"></a>2.For 循环方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/641.png" alt="641"></p><p>测试结果：<strong>For 循环中删除数据非安全</strong>。</p><h3 id="3-Lambda-方式"><a href="#3-Lambda-方式" class="headerlink" title="3.Lambda 方式"></a>3.Lambda 方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + key);</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/642.png" alt="642"></p><p>测试结果：<strong>Lambda 循环中删除数据非安全</strong>。</p><p><strong>Lambda 删除的正确方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 map 中的 key 去判断删除</span></span><br><span class="line">map.keySet().removeIf(key -&gt; key == <span class="number">1</span>);</span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，可以先使用 <code>Lambda</code> 的 <code>removeIf</code> 删除多余的数据，再进行循环是一种正确操作集合的方式。</p><h3 id="4-Stream-方式"><a href="#4-Stream-方式" class="headerlink" title="4.Stream 方式"></a>4.Stream 方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/643.png" alt="643"></p><p>测试结果：<strong>Stream 循环中删除数据非安全</strong>。</p><p><strong>Stream 循环的正确方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().filter(m -&gt; <span class="number">1</span> != m.getKey()).forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，可以使用 <code>Stream</code> 中的 <code>filter</code> 过滤掉无用的数据，再进行遍历也是一种安全的操作集合的方式。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们不能在遍历中使用集合 <code>map.remove()</code> 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <code>iterator.remove()</code> 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>阿⾥巴巴⼿册相关的规定：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230809113202544.png" alt="image-20230809113202544"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>部分内容转载自<a href="https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow">Java中文社群</a>,如有侵权，请立刻联系我，进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之享元模式</title>
      <link href="/2023/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li><li>享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</li></ul><h2 id="享元模式原理类图"><a href="#享元模式原理类图" class="headerlink" title="享元模式原理类图"></a>享元模式原理类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230430120243213.png" alt="image-20230430120243213" style="zoom:67%;"><p>说明：</p><ul><li><code>FlyWeigh</code> 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态的接口或实现</li><li><code> ConcreteFlyWeight</code> 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li><li><code>UnSharedConcreteFlyWeight</code> 是不可共享的角色，一般不会出现在享元工厂。</li><li><code>FlyWeightFactory</code> 享元工厂类，用于构建一个池容器(集合)， 同时提供从池中获取对象方法</li></ul><p>上面提到了一个外部状态和内部状态，那么什么是外部状态和内部状态呢？</p><ul><li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态</li><li><strong>内部状态</strong>指对象共享出来的信息，<strong>存储在享元对象内部且不会随环境的改变而改变</strong></li><li><strong>外部状态指对象得以依赖的一个标记</strong>，是<strong>随环境改变而改变的、不可共享的状态</strong>。</li></ul><blockquote><p>举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p></blockquote><h2 id="享元模式的应用示例"><a href="#享元模式的应用示例" class="headerlink" title="享元模式的应用示例"></a>享元模式的应用示例</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230430120652648.png" alt="image-20230430120652648" style="zoom:67%;"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>抽象享元角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-30 12:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象的享元角色</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的享元角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-30 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 具体的享元角色</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title class_">WebSite</span>&#123;</span><br><span class="line">    <span class="comment">//共享的部分，内部状态</span></span><br><span class="line">    <span class="keyword">private</span> String type=<span class="string">&quot;&quot;</span>;<span class="comment">//网站的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteWebSite</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;网站的类型为:&quot;</span>+type+<span class="string">&quot;，使用者是：&quot;</span>+user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>享元工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-30 12:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 网站工厂类。根据需求返回一个网站</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteFactory</span> &#123;</span><br><span class="line">    <span class="comment">//相当于一个池</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,ConcreteWebSite&gt; pool=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> WebSite <span class="title function_">getWebSiteCategory</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pool.containsKey(type))&#123;</span><br><span class="line">            <span class="comment">//创建一个网站，放到池中</span></span><br><span class="line">            pool.put(type,<span class="keyword">new</span> <span class="title class_">ConcreteWebSite</span>(type));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWebSiteCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个工厂类</span></span><br><span class="line">        <span class="type">WebSiteFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSiteFactory</span>();</span><br><span class="line">        <span class="comment">// 客户要一个以新闻形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite1</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);</span><br><span class="line">        webSite1.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite2</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite2.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">        <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite3</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite3.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;smith&quot;</span>));</span><br><span class="line">        <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite4</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite4.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;king&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;网站的分类共=&quot;</span> + factory.getWebSiteCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式的注意事项和细节"><a href="#享元模式的注意事项和细节" class="headerlink" title="享元模式的注意事项和细节"></a>享元模式的注意事项和细节</h2><ul><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 <code>HashMap/HashTable</code> 存储</li><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li><li>享元模式提高了<strong>系统的复杂度</strong>。需要分离出<strong>内部状态和外部状态</strong>，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.</li><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。</li><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之组合模式</title>
      <link href="/2023/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="学校院系展示需求"><a href="#学校院系展示需求" class="headerlink" title="学校院系展示需求"></a>学校院系展示需求</h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230424112820067.png" alt="image-20230424112820067" style="zoom:67%;"><h2 id="传统方式解决"><a href="#传统方式解决" class="headerlink" title="传统方式解决"></a>传统方式解决</h2><p>系继承学院，学院继承学校</p><h2 id="传统方式的问题分析"><a href="#传统方式的问题分析" class="headerlink" title="传统方式的问题分析"></a>传统方式的问题分析</h2><blockquote><ul><li>将<strong>学院看做是学校的子类</strong>，<strong>系是学院的子类</strong>，这样实际上是站在组织大小来进行分层次的</li><li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，<strong>不能很好实现的管理的操作</strong>，比如对学院、系的<strong>添加，删除，遍历</strong>等</li><li>解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 &#x3D;&gt; <strong>组合</strong>模式</li></ul></blockquote><h2 id="组合方式基本介绍"><a href="#组合方式基本介绍" class="headerlink" title="组合方式基本介绍"></a>组合方式基本介绍</h2><blockquote><ul><li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示<strong>整体</strong>-<strong>部分</strong>的层次关系。</li><li>组合模式<strong>依据树形结构来组合对象</strong>，用来表示部分以及整体层次。</li><li>这种类型的设计模式属于结构型模式。</li><li>组合模式使得<strong>用户对单个对象和组合对象的访问具有一致性</strong>，即：组合能让客户以一致的方式处理个别对象以及组合对象</li></ul></blockquote><h2 id="组合模式类图分析"><a href="#组合模式类图分析" class="headerlink" title="组合模式类图分析"></a>组合模式类图分析</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/1.webp" alt="1"></p><ul><li><p><strong>Component</strong> :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口</p></li><li><p><strong>Leaf :</strong> 在组合中表示叶子节点，叶子节点没有子节点</p></li><li><p><strong>Composite</strong> :非叶子节点， 用于存储子部件， 在 Component  接口中实现 子部件的相关操作，比如增加(add),删除</p></li></ul><h2 id="组合模式解决学校院系展示"><a href="#组合模式解决学校院系展示" class="headerlink" title="组合模式解决学校院系展示"></a>组合模式解决学校院系展示</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230424111954059.png" alt="image-20230424111954059" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Component</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrganizationComponent</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">University</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span>&#123;</span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">University</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写add</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写remove</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: College 就是 Composite , 可以管理Department</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">College</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List 中 存放的Department</span></span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">College</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写add</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写remove</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 叶子节点</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-24 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">university</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">University</span>(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot; 中国顶级大学 &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 学院</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">computerCollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot; 计算机学院 &quot;</span>);</span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">infoEngineercollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;信息工程学院&quot;</span>, <span class="string">&quot; 信息工程学院 &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot; 软件工程不错 &quot;</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;网络工程&quot;</span>, <span class="string">&quot; 网络工程不错 &quot;</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;计算机科学与技术&quot;</span>, <span class="string">&quot; 计算机科学与技术是老牌的专业 &quot;</span>));</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;通信工程&quot;</span>, <span class="string">&quot; 通信工程不好学 &quot;</span>));</span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;信息工程&quot;</span>, <span class="string">&quot; 信息工程好学 &quot;</span>));</span><br><span class="line">        <span class="comment">//将学院加入到 学校</span></span><br><span class="line">        university.add(computerCollege);</span><br><span class="line">        university.add(infoEngineercollege);</span><br><span class="line">        university.print();</span><br><span class="line"><span class="comment">/*        infoEngineercollege.print();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式的注意事项和细节"><a href="#组合模式的注意事项和细节" class="headerlink" title="组合模式的注意事项和细节"></a>组合模式的注意事项和细节</h2><ul><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构</li><li>需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.</li><li>要求较高的抽象性，如果<strong>节点和叶子有很多差异性的话</strong>，比如很多方法和属性都不一样<strong>，不适合使用组合模</strong>式</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之组合模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计者模式之装饰者模式</title>
      <link href="/2023/05/11/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/11/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="星巴克咖啡订单项目"><a href="#星巴克咖啡订单项目" class="headerlink" title="星巴克咖啡订单项目"></a>星巴克咖啡订单项目</h2><blockquote><ul><li>咖啡种类&#x2F;单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</li><li>调料：Milk、Soy(豆浆)、Chocolate</li><li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li><li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li></ul></blockquote><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423232927807.png" alt="image-20230423232927807" style="zoom:67%;"><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><ul><li>Drink 是一个抽象类，表示饮料</li><li>des 就是对咖啡的描述, 比如咖啡的名字</li><li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li><li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost</li><li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li><li>问题：<strong>这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸</strong></li></ul></blockquote><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)：</p><h3 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233054151.png" alt="image-20230423233054151" style="zoom:67%;"><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><ul><li>方案 2 可以控制类的数量，不至于造成很多的类</li><li>在增加或者删除调料种类时，代码的维护量很大</li><li>考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int</li><li>考虑使用 <strong>装饰者</strong> 模式</li></ul></blockquote><h2 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h2><ul><li>装饰者模式：<strong>动态的将新功能附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，<strong>装饰者模式也体现了开闭原则(ocp)</strong></li><li>这里提到的动态的将新功能附加到对象和 ocp 原则</li></ul><h2 id="装饰者模式原理"><a href="#装饰者模式原理" class="headerlink" title="装饰者模式原理"></a>装饰者模式原理</h2><ul><li><p>装饰者模式就像打包一个快递</p><ul><li>主体：比如：陶瓷、衣服 (Component) &#x2F;&#x2F; 被装饰者</li><li>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)</li></ul></li><li><p>Component 主体：比如类似前面的 Drink</p></li><li><p>ConcreteComponent 和 Decorator ConcreteComponent：具体的主体， 比如前面的各个单品咖啡</p></li><li><p>Decorator: 装饰者，比如各调料.</p></li></ul><p>在如图的 Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233503512.png" alt="image-20230423233503512" style="zoom:67%;"><h2 id="装饰者模式解决星巴克咖啡订单"><a href="#装饰者模式解决星巴克咖啡订单" class="headerlink" title="装饰者模式解决星巴克咖啡订单"></a>装饰者模式解决星巴克咖啡订单</h2><h3 id="类图分析-2"><a href="#类图分析-2" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233557793.png" alt="image-20230423233557793" style="zoom:67%;"><h3 id="装饰者模式下的订单：2-份巧克力-一份牛奶的-LongBlack"><a href="#装饰者模式下的订单：2-份巧克力-一份牛奶的-LongBlack" class="headerlink" title="装饰者模式下的订单：2 份巧克力+一份牛奶的 LongBlack"></a>装饰者模式下的订单：2 份巧克力+一份牛奶的 LongBlack</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423233642302.png" alt="image-20230423233642302" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String des; <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算费用的抽象方法</span></span><br><span class="line">    <span class="comment">//子类来实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Espresso</span><span class="params">()</span>&#123;</span><br><span class="line">        setDes(<span class="string">&quot;意大利咖啡&quot;</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Drink obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// getPrice 自己价格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line">        <span class="keyword">return</span> des + <span class="string">&quot; &quot;</span> + getPrice() + <span class="string">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Drink obj)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(obj);</span><br><span class="line">        setDes(<span class="string">&quot; 牛奶 &quot;</span>);</span><br><span class="line">        setPrice(<span class="number">2.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Drink</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;费用1=&quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;描述=&quot;</span> + order.getDes());</span><br><span class="line">        <span class="comment">// 2. order 加入一份牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> <span class="title class_">Milk</span>(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之装饰者模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之适配器模式</title>
      <link href="/2023/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="生活中的适配器的例子"><a href="#生活中的适配器的例子" class="headerlink" title="生活中的适配器的例子"></a>生活中的适配器的例子</h2><p>充电器适配器</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423112011229.png" alt="image-20230423112011229"></p><h2 id="适配器模式的基本介绍"><a href="#适配器模式的基本介绍" class="headerlink" title="适配器模式的基本介绍"></a>适配器模式的基本介绍</h2><blockquote><ul><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，<strong>主的目的是兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于结构型模式</li><li>主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模式</strong></li></ul></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><blockquote><ul><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li></ul></blockquote><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423112201602.png" alt="image-20230423112201602" style="zoom: 67%;"><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><figcaption><span>类，通过继承 ```src(source)``` 类，实现 ```dst(destination,Target)``` 类接口，完成 src->dst 的适配。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> ### 应用实例</span><br><span class="line"></span><br><span class="line">以生活中充电器的例子，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电</span><br><span class="line"></span><br><span class="line">#### 类图分析</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423112524411.png&quot; alt=&quot;image-20230423112524411&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">#### 代码演示</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * @Author: abb</span><br><span class="line"> * @DateTime: 2023-04-23 11:27</span><br><span class="line"> * @Description: 被适配器的类</span><br><span class="line"> **/</span><br><span class="line">public class Voltage220V &#123;</span><br><span class="line">    //输出220V的电压</span><br><span class="line">    public int output220V() &#123;</span><br><span class="line">        int src = 220;</span><br><span class="line">        System.out.println(&quot;电压=&quot; + src + &quot;伏&quot;);</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 适配接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 适配器类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title class_">Voltage220V</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取到220V电压</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> output220V();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dstV</span> <span class="operator">=</span> srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 手机</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类适配器模式注意事项和细节"><a href="#类适配器模式注意事项和细节" class="headerlink" title="类适配器模式注意事项和细节"></a>类适配器模式注意事项和细节</h3><blockquote><ul><li>Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</li><li>src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。</li><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。</li></ul></blockquote><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote><ul><li>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</li><li>根据“<strong>合成复用原则</strong>”，在系统中尽量使用<strong>关联关系（聚合）来替代继承</strong>关系。</li><li>对象适配器模式是适配器模式常用的一种</li></ul></blockquote><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423113513517.png" alt="image-20230423113513517" style="zoom:67%;"><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 适配器类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.voltage220V = voltage220v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != voltage220V) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">            System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">            dst = src / <span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 11:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>(<span class="keyword">new</span> <span class="title class_">Voltage220V</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器模式的注意事项和细节"><a href="#对象适配器模式的注意事项和细节" class="headerlink" title="对象适配器模式的注意事项和细节"></a>对象适配器模式的注意事项和细节</h3><blockquote><ul><li><p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。</p></li><li><p>根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst必须是接口。</p></li><li><p>使用成本更低，更灵活。</p></li></ul></blockquote><h2 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote><ul><li>一些书籍称为：适配器模式(Default Adapter Pattern)或<strong>缺省适配器模式</strong>。</li><li>核心思路：当<strong>不需要全部实现接口提供的方法</strong>时，可先<strong>设计一个抽象类</strong>实现<strong>接口</strong>，并为该接口中每个方法提供一个<strong>默认实现（空方法）</strong>，那么该<strong>抽象类的子类可有选择地覆盖父类的某些方法</strong>来实现需求</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ul></blockquote><h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423122531343.png" alt="image-20230423122531343" style="zoom:67%;"><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 12:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 12:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 将Interface的所有方法默认实现</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsAdapter</span> <span class="keyword">implements</span> <span class="title class_">Interface4</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 12:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbsAdapter</span> <span class="variable">absAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbsAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;只实现了m1方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        absAdapter.m1();</span><br><span class="line">        absAdapter.m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式的注意事项和细节"><a href="#适配器模式的注意事项和细节" class="headerlink" title="适配器模式的注意事项和细节"></a>适配器模式的注意事项和细节</h2><blockquote><ul><li>三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。</li><li>类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承</li><li>对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现</li><li>Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。</li><li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li></ul></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之适配器模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之桥接模式</title>
      <link href="/2023/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="手机操作问题引入"><a href="#手机操作问题引入" class="headerlink" title="手机操作问题引入"></a>手机操作问题引入</h2><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423192633013.png" alt="image-20230423192633013" style="zoom:67%;"><h2 id="传统方式解决手机操作问题"><a href="#传统方式解决手机操作问题" class="headerlink" title="传统方式解决手机操作问题"></a>传统方式解决手机操作问题</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423192723970.png" alt="image-20230423192723970" style="zoom:67%;"><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><ul><li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li><li>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</li><li>解决方案-使用<strong>桥接模</strong>式</li></ul></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>桥接模式(Bridge 模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li><li>是一种结构型设计模式</li><li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li></ul><h3 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423192939779.png" alt="image-20230423192939779" style="zoom:67%;"><p>说明：</p><ul><li>Client 类：桥接模式的调用者</li><li>抽象类(Abstraction) :维护了 Implementor &#x2F; 即它的实现类 ConcreteImplementorA.., 二者是聚合关系, Abstraction充当桥接类</li><li>RefinedAbstraction : 是 Abstraction 抽象类的子类</li><li>mplementor : 行为实现类的接口</li><li>ConcreteImplementorA &#x2F;B ：行为的具体实现类</li><li>从 UML 图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li></ul><h2 id="桥接模式解决手机操作问题"><a href="#桥接模式解决手机操作问题" class="headerlink" title="桥接模式解决手机操作问题"></a>桥接模式解决手机操作问题</h2><h3 id="类图分析-2"><a href="#类图分析-2" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423193104591.png" alt="image-20230423193104591" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 品牌接口类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Vivo品牌手机</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vivo</span> <span class="keyword">implements</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; Vivo手机开机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; Vivo手机关机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; Vivo手机打电话 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 手机</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//将品牌加入到手机</span></span><br><span class="line">    <span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        brand.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        brand.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: //折叠式手机类，继承 抽象类 Phone</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoldedPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FoldedPhone</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">        System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.call();</span><br><span class="line">        System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 19:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FoldedPhone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">Vivo</span>());</span><br><span class="line">        phone.open();</span><br><span class="line">        phone.call();</span><br><span class="line">        phone.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式的注意事项和细节"><a href="#桥接模式的注意事项和细节" class="headerlink" title="桥接模式的注意事项和细节"></a>桥接模式的注意事项和细节</h2><ul><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li><li><strong>桥接模式替代多层继承方案</strong>，可以减少<strong>子类的个数</strong>，降低系统的管理和维护成本。</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.</li></ul><h2 id="常见的应用场景"><a href="#常见的应用场景" class="headerlink" title="常见的应用场景"></a>常见的应用场景</h2><ol><li><p>JDBC 驱动程序</p></li><li><p>银行转账系统</p><ul><li><p>转账分类: 网上转账，柜台转账，AMT 转账</p></li><li><p>转账用户类型：普通用户，银卡用户，金卡用户…</p></li></ul></li><li><p>消息管理</p><ul><li><p>消息类型：即时消息，延时消息</p></li><li><p>消息分类：手机短信，邮件消息，QQ 消息…</p></li></ul></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之桥接模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之建造者模式</title>
      <link href="/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="盖房项目需求"><a href="#盖房项目需求" class="headerlink" title="盖房项目需求"></a>盖房项目需求</h2><blockquote><ul><li>需要建房子：这一过程为打桩、砌墙、封顶</li><li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li></ul></blockquote><h2 id="传统方式解决盖房需求"><a href="#传统方式解决盖房需求" class="headerlink" title="传统方式解决盖房需求"></a>传统方式解决盖房需求</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423092004768.png" alt="image-20230423092004768" style="zoom: 80%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHouse</span> &#123;</span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWalls();</span><br><span class="line">        roofed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">AbstractHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子打地基 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子砌墙 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子封顶 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CommonHouse</span> <span class="variable">commonHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonHouse</span>();</span><br><span class="line">        commonHouse.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传统方式分析"><a href="#传统方式分析" class="headerlink" title="传统方式分析"></a>传统方式分析</h2><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。</li><li>解决方案：将产品和产品建造过程解耦 &#x3D;&gt;  <strong>建造者模式</strong>.</li></ul></blockquote><h2 id="建造者模式基本介绍"><a href="#建造者模式基本介绍" class="headerlink" title="建造者模式基本介绍"></a>建造者模式基本介绍</h2><blockquote><ul><li>建造者模式（<strong>Builder Pattern</strong>） 又叫<strong>生成器模式</strong>，是一种对象<strong>构建模式</strong>。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</li><li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。</li></ul></blockquote><h2 id="建造者模式的四个角色"><a href="#建造者模式的四个角色" class="headerlink" title="建造者模式的四个角色"></a>建造者模式的四个角色</h2><blockquote><ul><li><strong>Product（产品角色）</strong>： 一个具体的产品对象。</li><li><strong>Builder（抽象建造者）</strong>： 创建一个 Product 对象的各个部件指定的 <strong>接口&#x2F;抽象类</strong>。</li><li><strong>ConcreteBuilder（具体建造者）</strong>： 实现接口，构建和装配各个部件。</li><li><strong>Director（指挥者）</strong>： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ul></blockquote><h2 id="建造者模式原理类图"><a href="#建造者模式原理类图" class="headerlink" title="建造者模式原理类图"></a>建造者模式原理类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423092452561.png" alt="image-20230423092452561" style="zoom:67%;"><h2 id="建造者模式解决盖房需求应用实例"><a href="#建造者模式解决盖房需求应用实例" class="headerlink" title="建造者模式解决盖房需求应用实例"></a>建造者模式解决盖房需求应用实例</h2><h3 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230423092532697.png" alt="image-20230423092532697" style="zoom:67%;"><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><p>product</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 产品-&gt;product</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBaise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBaise</span><span class="params">(String baise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWall</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWall</span><span class="params">(String wall)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoofed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roofed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoofed</span><span class="params">(String roofed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roofed = roofed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象的构造者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象的构造者</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将建造的流程写好, 抽象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子好， 将产品(房子) 返回</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通房子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通房子</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setBaise(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子打地基5米 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子砌墙10cm &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子屋顶 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指挥者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 指挥者，这里去指定制作流程，返回产品</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseDirector</span> &#123;</span><br><span class="line">    <span class="type">HouseBuilder</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器传入 houseBuilder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过setter 传入 houseBuilder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何处理建造房子的流程，交给指挥者</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">constructHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 9:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//盖普通房子</span></span><br><span class="line">        <span class="type">CommonHouse</span> <span class="variable">commonHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonHouse</span>();</span><br><span class="line">        <span class="comment">//准备创建房子的指挥者</span></span><br><span class="line">        <span class="type">HouseDirector</span> <span class="variable">houseDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>(commonHouse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成盖房子，返回产品(普通房子)</span></span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> houseDirector.constructHouse();</span><br><span class="line">        System.out.println(house.getBaise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式的注意事项和细节"><a href="#建造者模式的注意事项和细节" class="headerlink" title="建造者模式的注意事项和细节"></a>建造者模式的注意事项和细节</h2><ul><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li><li>抽象工厂模式 VS 建造者模式<ul><li>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</li></ul></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之建造者模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之原型模式</title>
      <link href="/2023/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="克隆羊问题"><a href="#克隆羊问题" class="headerlink" title="克隆羊问题"></a>克隆羊问题</h2><p>现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10只羊。</p><h2 id="传统方式解决克隆羊问题"><a href="#传统方式解决克隆羊问题" class="headerlink" title="传统方式解决克隆羊问题"></a>传统方式解决克隆羊问题</h2><h3 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h3><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230422234743493.png" alt="image-20230422234743493" style="zoom:67%;"><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="comment">//传统的方法</span></span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor()); </span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">    </span><br><span class="line">    System.out.println(sheep); </span><br><span class="line">    System.out.println(sheep2); </span><br><span class="line">    System.out.println(sheep3); </span><br><span class="line">    System.out.println(sheep4);</span><br><span class="line">    System.out.println(sheep5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传统方式的优缺点"><a href="#传统方式的优缺点" class="headerlink" title="传统方式的优缺点"></a>传统方式的优缺点</h2><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li></ul></blockquote><h2 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h2><p><strong>思路</strong>：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的Java 类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 &#x3D;&gt;<strong>原型模式</strong></p><h2 id="原型模式基本介绍"><a href="#原型模式基本介绍" class="headerlink" title="原型模式基本介绍"></a>原型模式基本介绍</h2><blockquote><ul><li>原型模式(Prototype 模式)是指：用<strong>原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的</strong>对象</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 <strong>对象.clone()</strong></li><li>形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li></ul></blockquote><h2 id="原型模式原理结构图-uml-类图"><a href="#原型模式原理结构图-uml-类图" class="headerlink" title="原型模式原理结构图-uml 类图"></a>原型模式原理结构图-uml 类图</h2><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230422235313399.png" alt="image-20230422235313399" style="zoom:67%;"><h3 id="原型结构图说明"><a href="#原型结构图说明" class="headerlink" title="原型结构图说明"></a>原型结构图说明</h3><blockquote><ul><li>Prototype : 原型类，声明一个克隆自己的接口</li><li>ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作</li><li>Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样）</li></ul></blockquote><h2 id="原型模式解决克隆羊问题的应用实例"><a href="#原型模式解决克隆羊问题的应用实例" class="headerlink" title="原型模式解决克隆羊问题的应用实例"></a>原型模式解决克隆羊问题的应用实例</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        Sheep sheep=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sheep=(Sheep) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 0:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;zjh&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Sheep sheep1=(Sheep)sheep.clone();</span><br><span class="line">        Sheep sheep2=(Sheep)sheep.clone();</span><br><span class="line">        Sheep sheep3=(Sheep)sheep.clone();</span><br><span class="line">        Sheep sheep4=(Sheep)sheep.clone();</span><br><span class="line">        System.out.println(sheep);</span><br><span class="line">        System.out.println(sheep1);</span><br><span class="line">        System.out.println(sheep2);</span><br><span class="line">        System.out.println(sheep3);</span><br><span class="line">        System.out.println(sheep4);</span><br><span class="line">        System.out.println(sheep1==sheep2);</span><br><span class="line">        System.out.println(sheep==sheep2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝的介绍"><a href="#浅拷贝的介绍" class="headerlink" title="浅拷贝的介绍"></a>浅拷贝的介绍</h2><blockquote><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li><li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>前面我们克隆羊就是浅拷贝</li><li>浅拷贝是使用默认的 clone()方法来实现sheep &#x3D; (Sheep) super.clone();</li></ul></blockquote><h2 id="深拷贝的介绍"><a href="#深拷贝的介绍" class="headerlink" title="深拷贝的介绍"></a>深拷贝的介绍</h2><blockquote><ul><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，<strong>对象进行深拷贝要对整个对象</strong><strong>(包括对象的引用类型)进行拷</strong>贝**</li><li><strong>深拷贝实现方式 1：重写 clone</strong> 方法来实现深拷贝</li><li><strong>深拷贝实现方式 2</strong>：通过<strong>对象序列化</strong>实现深拷贝(推荐)</li></ul></blockquote><h2 id="深拷贝的应用案例"><a href="#深拷贝的应用案例" class="headerlink" title="深拷贝的应用案例"></a>深拷贝的应用案例</h2><h3 id="代码演示（两种方法）"><a href="#代码演示（两种方法）" class="headerlink" title="代码演示（两种方法）"></a>代码演示（两种方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 0:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="built_in">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-23 0:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 两种方式</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepProtoType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>,Cloneable &#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepProtoType</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝--方式一--使用clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        Object deep=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这里完成对基本数据类型(属性)和String的克隆</span></span><br><span class="line">        deep=<span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//对于引用类型进行单独处理</span></span><br><span class="line">        DeepProtoType deepProtoType=(DeepProtoType)deep;</span><br><span class="line">        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deepProtoType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝--方式二--通过对象的序列化</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deepClone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos=<span class="literal">null</span>;</span><br><span class="line">        ObjectOutputStream oos=<span class="literal">null</span>;</span><br><span class="line">        ByteArrayInputStream bis=<span class="literal">null</span>;</span><br><span class="line">        ObjectInputStream ois=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);<span class="comment">//将当前对象以对象流的方式输出</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis=<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="type">DeepProtoType</span> <span class="variable">copyObj</span> <span class="operator">=</span> (DeepProtoType) ois.readObject();</span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">DeepProtoType</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepProtoType</span>();</span><br><span class="line">p.name = <span class="string">&quot;abb&quot;</span>;</span><br><span class="line">p.deepCloneableTarget = <span class="keyword">new</span> <span class="title class_">DeepCloneableTarget</span>(<span class="string">&quot;zjh&quot;</span>, <span class="string">&quot;zjhhhh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1 完成深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="type">DeepProtoType</span> <span class="variable">p2</span> <span class="operator">=</span> (DeepProtoType) p.clone();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2 完成深拷贝</span></span><br><span class="line"><span class="comment">//DeepProtoType p2 = (DeepProtoType) p.deepClone();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;p.name=&quot; + p.name + &quot;p.deepCloneableTarget=&quot; + p.deepCloneableTarget.hashCode());</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;p2.name=&quot; + p.name + &quot;p2.deepCloneableTarget=&quot; + p2.deepCloneableTarget.hashCode());</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式的注意事项和细节"><a href="#原型模式的注意事项和细节" class="headerlink" title="原型模式的注意事项和细节"></a>原型模式的注意事项和细节</h2><blockquote><ul><li>创建新的对象比较复杂时，可以利用原型模式简化<strong>对象的创建过程，同时也能够提高</strong>效率</li><li>不用重新初始化对象，而是<strong>动态地获得对象运行时</strong>的状态</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li><strong>缺点</strong>：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则，这点请同学们注意.</li></ul></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之原型模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h3><blockquote><p>看一个披萨的项目：要便于披萨种类的扩展，要便于维护</p><ul><li>披萨的种类很多(比如 GreekPizz、CheesePizz 等)</li><li>披萨的制作有 prepare，bake, cut, box</li><li>完成披萨店订购功能。</li></ul></blockquote><h3 id="传统方式来解决"><a href="#传统方式来解决" class="headerlink" title="传统方式来解决"></a>传统方式来解决</h3><h4 id="类图分析"><a href="#类图分析" class="headerlink" title="类图分析"></a>类图分析</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E7%89%871.jpg" alt="图片1"></p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出pizza 制作过程</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传统方式的优缺点"><a href="#传统方式的优缺点" class="headerlink" title="传统方式的优缺点"></a>传统方式的优缺点</h4><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的 <strong>ocp</strong> <strong>原则</strong>，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个<strong>Pizza</strong> 的种类(Pepper披萨)，我们需要做如下修改. 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改.</li></ul></blockquote><h4 id="改进的思路分析"><a href="#改进的思路分析" class="headerlink" title="改进的思路分析"></a>改进的思路分析</h4><p>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza</p><p>的代码，往往有多处。</p><p>思路：<strong>把创建</strong> <strong>Pizza</strong> <strong>对象封装到一个类中，这样我们有新的</strong> <strong>Pizza</strong> <strong>种类时，只需要修改该类就可</strong>，其它有创建到 Pizza</p><p>对象的代码就不需要修改了.-&gt; <strong>简单工厂</strong>模式</p><h3 id="简单工厂模式基本介绍"><a href="#简单工厂模式基本介绍" class="headerlink" title="简单工厂模式基本介绍"></a>简单工厂模式基本介绍</h3><blockquote><ul><li>简单工厂模式是属于<strong>创建型模式</strong>，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是<strong>工厂模式家族中最简单实用的</strong>模式</li><li>简单工厂模式：定义了一个创建对象的类，由这个类来<strong>封装实例化对象的行为</strong>(代码)</li><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</li></ul></blockquote><h3 id="简单工厂模式的使用"><a href="#简单工厂模式的使用" class="headerlink" title="简单工厂模式的使用"></a>简单工厂模式的使用</h3><h4 id="类图分析-1"><a href="#类图分析-1" class="headerlink" title="类图分析"></a>类图分析</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E7%89%872.jpg" alt="图片2"></p><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更加orderType 返回对应的Pizza 对象</span></span><br><span class="line"><span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;使用简单工厂模式&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单工厂模式 也叫 静态工厂模式 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title function_">createPizza2</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;使用简单工厂模式2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">SimpleFactory simpleFactory;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line">setFactory(simpleFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入的</span></span><br><span class="line"><span class="built_in">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType(); </span><br><span class="line">pizza = <span class="built_in">this</span>.simpleFactory(orderType);</span><br><span class="line"><span class="comment">//输出pizza</span></span><br><span class="line"><span class="keyword">if</span>(pizza != <span class="literal">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="新的需求"><a href="#新的需求" class="headerlink" title="新的需求"></a>新的需求</h3><p>披萨项目新的需求：客户在点披萨时，可以点<strong>不同口味的披萨</strong>，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用<strong>简单工厂模式</strong>，创建<strong>不同的简单工厂类</strong>，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>使用工厂方法模式</p><h3 id="工厂方法模式介绍"><a href="#工厂方法模式介绍" class="headerlink" title="工厂方法模式介绍"></a>工厂方法模式介绍</h3><blockquote><ul><li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</li><li>工厂方法模式：<strong>定义了一个创建对象的抽象方法</strong>，由子<strong>类决定要实例化的类</strong>。工厂方法模式将<strong>对象的实例化推迟到子类</strong>。</li></ul></blockquote><h3 id="工厂方法模式应用案例"><a href="#工厂方法模式应用案例" class="headerlink" title="工厂方法模式应用案例"></a>工厂方法模式应用案例</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza</p><h4 id="类图分析-2"><a href="#类图分析-2" class="headerlink" title="类图分析"></a>类图分析</h4><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E7%89%873.jpg" alt="图片3"></p><h4 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"><span class="comment">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span></span><br><span class="line"><span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line">pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line"><span class="comment">//输出pizza 制作过程</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>北京子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="抽象工厂模式介绍"><a href="#抽象工厂模式介绍" class="headerlink" title="抽象工厂模式介绍"></a>抽象工厂模式介绍</h3><blockquote><ul><li>抽象工厂模式：定义了一个 <strong>interface</strong> <strong>用于创建相关或有依赖关系的对象簇</strong>，而无需指明具体的类</li><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li><li>将工厂抽象成<strong>两层</strong>，<strong>AbsFactory(抽象工厂)</strong> 和 <strong>具体实现的工厂子类</strong>。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li></ul></blockquote><h3 id="抽象工厂模式应用实例"><a href="#抽象工厂模式应用实例" class="headerlink" title="抽象工厂模式应用实例"></a>抽象工厂模式应用实例</h3><h4 id="类图分析-3"><a href="#类图分析-3" class="headerlink" title="类图分析"></a>类图分析</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230422231431718.png" alt="image-20230422231431718" style="zoom:67%;"><h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line">    <span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        Pizza pizza=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza=<span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;</span><br><span class="line">            pizza=<span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    AbsFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        setFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 用户输入</span></span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            <span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">            pizza = factory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="literal">null</span>) &#123; <span class="comment">// 订购ok</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式小结"><a href="#工厂模式小结" class="headerlink" title="工厂模式小结"></a>工厂模式小结</h2><ul><li><p>工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p></li><li><p>三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)</p></li><li><p>设计模式的依赖抽象原则</p><ul><li>创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</li><li>不要覆盖基类中已经实现的方法。</li></ul></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之工厂模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2023/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a>单例设计模式介绍</h2><p>所谓类的单例设计模式，就是<strong>采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</strong>， 并且该类只提供一个取得其对象实例的方法(静态方法)。</p><p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p><h2 id="单例设计模式的八种方式"><a href="#单例设计模式的八种方式" class="headerlink" title="单例设计模式的八种方式"></a>单例设计模式的八种方式</h2><blockquote><ul><li><strong>饿汉式(静态常量)</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式(线程不安全)</li><li>懒汉式(线程安全，同步方法)</li><li>懒汉式(线程安全，同步代码块)</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ul></blockquote><h2 id="饿汉式（静态变量）"><a href="#饿汉式（静态变量）" class="headerlink" title="饿汉式（静态变量）"></a>饿汉式（静态变量）</h2><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>步骤如下：</p><blockquote><ul><li>构造器私有化 (防止 new )</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。getInstance</li><li>代码实现</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 8:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 饿汉式（静态变量）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//3、提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</li><li>这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</li><li>结论：这种单例模式可用，可能造成内存浪费</li></ul></blockquote><h2 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h2><h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><p>这种方式和上面的方式其实类似，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 8:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 饿汉式（静态代码块）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//在静态代码块中，创建单例对象</span></span><br><span class="line">        instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>结论：这种单例模式可用，但是可能造成内存浪费</li></ul></blockquote><h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 懒汉式（线程不安全）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、提供一个公有的静态方法，只有使用到该方法时，才去创建instance，即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了 if (singleton &#x3D;&#x3D; null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会<strong>产生多个实例</strong>。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，<strong>不要使用</strong>这种方式.</li></ul></blockquote><h2 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h2><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 懒汉式（线程安全、同步方法）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、提供一个公有的静态方法，只有使用到该方法时，才去创建instance，即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>解决了<strong>线程安全</strong>问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。<strong>方法进行同步效率太</strong>低</li><li>结论：在实际开发中，<strong>不推荐</strong>使用这种方式</li></ul></blockquote><h2 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h2><h3 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 懒汉式（线程安全、同步代码块）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、提供一个公有的静态方法，只有使用到该方法时，才去创建instance，即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><ul><li>上述代码其实没有实现单例，假如有两个线程a,b同时进入了if判断，a在进行了对象的创建时，虽然b在外面等待，但是当a创建完毕之后，b线程会进入代码块执行对象的创建，这样就创建了两个对象，不符合单例设计模式。</li><li>不使用</li></ul><h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h2><h3 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 双重检查</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//volatile是Java提供的一种轻量级的同步机制。</span></span><br><span class="line">    <span class="comment">//当一个线程修改共享变量后他会立即被更新到主内存中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">    <span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton &#x3D;&#x3D; null)检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton &#x3D;&#x3D; null)，直接 return 实例化对象，也避免的反复进行方法同步.</li><li>线程安全；延迟加载；效率较高</li><li>结论：在实际开发中，<strong>推荐使用这种单例设计模</strong>式</li></ul></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h3 id="代码演示-4"><a href="#代码演示-4" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 10:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 静态内部类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写一个静态内部类，该类有一个静态属性INSTANCE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个公有的静态方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li><li>结论：<strong>推荐</strong>使用.</li></ul></blockquote><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="代码演示-5"><a href="#代码演示-5" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-21 11:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 枚举</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">        System.out.println(instance.hashCode()); </span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line">        instance.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote><ul><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li><li>这种方式是 <strong>Effective Java</strong> <strong>作者</strong> <strong>Josh Bloch</strong> <strong>提倡</strong>的方</li><li>结论：<strong>推荐</strong>使用</li></ul></blockquote><h2 id="单例设计模式注意事项和细节"><a href="#单例设计模式注意事项和细节" class="headerlink" title="单例设计模式注意事项和细节"></a>单例设计模式注意事项和细节</h2><blockquote><ul><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li><li>单例模式<strong>使用的场景</strong>：需要<strong>频繁的进行创建和销毁的对象</strong>、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、<strong>工具类对象</strong>、频繁访问数据库或文件的对象(比如<strong>数据源、session 工厂</strong>等)</li></ul></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次的设计模式之单例模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/2023/04/26/UML%E7%B1%BB%E5%9B%BE/"/>
      <url>/2023/04/26/UML%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>UML图有很多种，但是并非必须掌握所有的UML图，才能完整系统分析和设计工作。一般说来，在UML图中，只要掌握类图、用例图、时序图的使用，就能完成大部分的工作。对于程序员来说，最频繁使用的莫过于类图。因此，这里我只讲解UML类图。</p><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图中最基本的元素是类、接口。软件设计师设计出类图后，程序员就可以用代码实现类图中包含的内容。</p><h3 id="1-1-UML图"><a href="#1-1-UML图" class="headerlink" title="1.1.UML图"></a>1.1.UML图</h3><ul><li>用例图(use case)</li><li>静态结构图： 类图、对象图、包图、组件图、部署图</li><li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li><li><strong>类图是描述类与类之间的关系的，是UML图中最核心的</strong></li></ul><h3 id="1-2-UML类图"><a href="#1-2-UML类图" class="headerlink" title="1.2.UML类图"></a>1.2.UML类图</h3><ul><li>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。</li><li>类之间的关系： <strong><code>依赖、泛化（继承）、实现、关联、聚合与组合</code></strong></li></ul><h3 id="1-3-类图关系"><a href="#1-3-类图关系" class="headerlink" title="1.3.类图关系"></a>1.3.类图关系</h3><blockquote><ul><li>设计一个类中的信息和行为要 <code>高内聚</code></li><li>设计多个类, 类之间要 <code>低耦合</code></li></ul></blockquote><p>面向对象是符合人们对现实世界的思维模式，利用面向对象设计，特别是采用各种设计模式来解决问题时，会设计多个类，然后创建多个对象，一个设计良好的类，应该是兼顾信息和行为并且高内聚。而不同的类之间，应该做到松耦合。</p><p>当面对应用系统或者需要解决的问题经常是复杂的、高度抽象的，我们 创建的多个对象往往是有联系的，通常对象之间的关系可以分为以下几类：</p><ul><li>泛化关系</li><li>实现关系</li><li>依赖关系</li><li>关联关系</li><li>聚合关系</li><li>组合关系</li></ul><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224123104360.png" alt="img" style="zoom:67%;"><h2 id="2-依赖关系（Dependence）"><a href="#2-依赖关系（Dependence）" class="headerlink" title="2.依赖关系（Dependence）"></a>2.依赖关系（Dependence）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224105438325.png" alt="img"></p><ul><li>只要是在<strong>类中用到了对方，那么他们之间就存在依赖关系</strong>。如果没有对方，连编绎都通过不了</li><li>依赖（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。</li></ul><h2 id="3-泛化关系（generalization）"><a href="#3-泛化关系（generalization）" class="headerlink" title="3.泛化关系（generalization）"></a>3.泛化关系（generalization）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224104304237.png" alt="img"></p><ul><li>泛化关系其实就是<code>继承关系</code>：指的是一个类（称为子类、子接口）继承(<code>extends</code>)另外的一个类（称为父类、父接口）的功能，并可以增加自己额外的一些功能，<strong>继承是类与类或者接口与接口之间最常见的关系；</strong></li><li>Java代码中，对象之间的泛化关系可以直接翻译为关键字 <code>extends</code>。</li><li>他是<strong>依赖关系</strong>的<strong>特例</strong></li></ul><h2 id="4-实现关系（realization）"><a href="#4-实现关系（realization）" class="headerlink" title="4.实现关系（realization）"></a>4.实现关系（realization）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224104937159.png" alt="img"></p><ul><li>实现关系实际上就<strong>是</strong> <strong>A</strong> <strong>类实现</strong> <strong>B</strong> <strong>接口</strong>，他是<strong>依赖关系的特</strong>例</li><li>在Java代码中，实现关系可以直接翻译为关键字 <code>implements</code>。</li></ul><h2 id="5-关联关系（association）"><a href="#5-关联关系（association）" class="headerlink" title="5.关联关系（association）"></a>5.关联关系（association）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/2020022411311616.png" alt="img"></p><ul><li>关联关系（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在Java中，关联关系的代码表现形式为一个对象含有另一个对象的引用。也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。</li><li>关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。</li></ul><h3 id="5-1-按多重性分类"><a href="#5-1-按多重性分类" class="headerlink" title="5.1.按多重性分类"></a>5.1.按多重性分类</h3><ul><li>一对一：一个A对象属于一个B对象，一个B对象属于一个A对象。</li><li>一对多：一个A对象包含多个B对象。</li><li>多对一：多个A对象属于一个B对象，并且多个A对象中的每个A对象只能属于一个B对象。</li><li>多对多：一个A对象属于多个B对象，一个B对象属于多个A对象。</li></ul><h3 id="5-2-按导航性分类"><a href="#5-2-按导航性分类" class="headerlink" title="5.2.按导航性分类"></a>5.2.按导航性分类</h3><ul><li>单向：只能从A通过属性导航到B，B不能导航到A。</li><li>双向：A可以通过属性导航到B，B也可以通过属性导航到A。</li></ul><h2 id="6-聚合关系（aggregtion）"><a href="#6-聚合关系（aggregtion）" class="headerlink" title="6.聚合关系（aggregtion）"></a>6.聚合关系（aggregtion）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/2020022412311785.png" alt="img"></p><ul><li>聚合（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。</li><li>与关联关系一样，**<code>聚合关系</code>** 也是通过<code>实例变量</code>实现的。**<code>但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。</code>**</li><li>聚合关系表示整体和个体的关系，整体和个体可以相互独立存在，一定是有两个模块分别管理整体和个体。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Mouse mouse; <span class="comment">//鼠标可以和computer分离</span></span><br><span class="line"><span class="keyword">private</span> Moniter moniter;<span class="comment">//显示器可以和Computer分离</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoniter</span><span class="params">(Moniter moniter)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.moniter = moniter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的类图：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230419205622690.png" alt="image-20230419205622690"></p><h2 id="7-组合关系（composition）"><a href="#7-组合关系（composition）" class="headerlink" title="7.组合关系（composition）"></a>7.组合关系（composition）</h2><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/20200224123131234.png" alt="img"></p><ul><li><p>组合（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 “contains a” 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。如果<code>A</code>组合<code>B</code>，则<code>A</code>需要知道<code>B</code>的生存周期，即可能<code>A</code>负责生成或者释放<code>B</code>，或者<code>A</code>通过某种途径知道<code>B</code>的生成和释放。</p></li><li><p>例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。</p></li><li><p>但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那么 IDCard 和 Person 就是组合了.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Head</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Head</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应的类图：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230419210202946.png" alt="image-20230419210202946"></p><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>这次的设计模式之UML类图的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之七大原则</title>
      <link href="/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h2><h3 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1.基本介绍"></a>1.1.基本介绍</h3><p>对类来说的，<strong>即一个类应该只负责一项职责</strong>。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p><h3 id="1-2-应用实例"><a href="#1-2-应用实例" class="headerlink" title="1.2.应用实例"></a>1.2.应用实例</h3><h4 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>在方式1 的run方法中，违反了单一职责原则</li><li>解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</li></ol></blockquote><h4 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RoadVehicle</span> <span class="variable">roadVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoadVehicle</span>();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        <span class="type">AirVehicle</span> <span class="variable">airVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirVehicle</span>();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoadVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>遵守单一职责原则</li><li>但是这样做的改动很大，即将类分解，同时修改客户端</li><li>改进：直接修改Vehicle 类，改动的代码会比较少&#x3D;&gt;方案3</li></ol></blockquote><h4 id="1-2-3-方式三"><a href="#1-2-3-方式三" class="headerlink" title="1.2.3.方式三"></a>1.2.3.方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle2</span> <span class="variable">vehicle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle2</span>();</span><br><span class="line">        vehicle2.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAir</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runWater</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>这种修改方法没有对原来的类做大的修改，只是增加方法</li><li>这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</li></ol></blockquote><h3 id="1-3-单一职责原则细节"><a href="#1-3-单一职责原则细节" class="headerlink" title="1.3.单一职责原则细节"></a>1.3.单一职责原则细节</h3><blockquote><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol></blockquote><h2 id="2-接口隔离原则"><a href="#2-接口隔离原则" class="headerlink" title="2.接口隔离原则"></a>2.接口隔离原则</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1.基本介绍"></a>2.1.基本介绍</h3><ul><li><p>客户端不应该依赖它不需要的接口，即<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p></li><li><p>看图：</p></li><li><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230418232111042.png" alt="image-20230418232111042" style="zoom:67%;"></li><li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C</p><p>来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p></li><li><p>按隔离原则应当这样处理：</p><p><strong>将接口</strong> <strong>Interface1</strong> 拆分为**独立的几个接口(这里我们拆分成3个接口)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则:</p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230418232808656.png" alt="image-20230418232808656" style="zoom:67%;"></li></ul><h3 id="2-2-应用实例"><a href="#2-2-应用实例" class="headerlink" title="2.2.应用实例"></a>2.2.应用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Segregation1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> <span class="title class_">B</span>()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"></span><br><span class="line">        c.depend1(<span class="keyword">new</span> <span class="title class_">D</span>()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">        c.depend4(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface3 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h2><h3 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1.基本介绍"></a>3.1.基本介绍</h3><ul><li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象</p></li><li><p>抽象不应该依赖细节，细节应该依赖抽象</p></li></ul><ul><li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用<strong>接口或抽象类</strong>的目的是制定好<strong>规范</strong>，而不涉及任何具体的操作，把<strong>展现细节的任务交给他们的实现类</strong>去完成</li></ul><h3 id="3-2-应用实例"><a href="#3-2-应用实例" class="headerlink" title="3.2.应用实例"></a>3.2.应用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependecyInversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户端无需改变</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.receive(<span class="keyword">new</span> <span class="title class_">Email</span>());</span><br><span class="line">        person.receive(<span class="keyword">new</span> <span class="title class_">WeiXin</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeiXin</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(IReceiver receiver )</span> &#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-依赖关系传递的三种方式"><a href="#3-3-依赖关系传递的三种方式" class="headerlink" title="3.3.依赖关系传递的三种方式"></a>3.3.依赖关系传递的三种方式</h3><ol><li>接口传递</li><li>构造方法传递</li><li>setter方法传递</li></ol><h3 id="3-4-依赖倒转原则的细节"><a href="#3-4-依赖倒转原则的细节" class="headerlink" title="3.4.依赖倒转原则的细节"></a>3.4.依赖倒转原则的细节</h3><blockquote><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的<strong>声明类型尽量是抽象类或接口</strong>, 这样我们的变量引用和实际对象间，就存在<strong>一个缓冲层</strong>，利于程序扩展和优化</li><li>继承时遵循<strong>里氏替换</strong>原则</li></ul></blockquote><h2 id="4-里氏替换原则"><a href="#4-里氏替换原则" class="headerlink" title="4.里氏替换原则"></a>4.里氏替换原则</h2><h3 id="4-1-OO中的继承性的思考和说明"><a href="#4-1-OO中的继承性的思考和说明" class="headerlink" title="4.1.OO中的继承性的思考和说明"></a>4.1.OO中的继承性的思考和说明</h3><blockquote><ul><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来<strong>侵入性</strong>，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：<strong>在编程中，如何正确的使用继承</strong>? &#x3D;&gt; <strong>里氏替换</strong>原则</li></ul></blockquote><h3 id="4-2-基本介绍"><a href="#4-2-基本介绍" class="headerlink" title="4.2.基本介绍"></a>4.2.基本介绍</h3><blockquote><ul><li>里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。</li><li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型T2 是类型 T1 的子类型。<strong>换句话说，所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li><li>在使用继承时，遵循里氏替换原则，在<strong>子类中尽量不要重写父类的方法</strong></li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合，组合，依赖 **  来解决问题。.</li></ul></blockquote><h3 id="4-3-问题的引出"><a href="#4-3-问题的引出" class="headerlink" title="4.3.问题的引出"></a>4.3.问题的引出</h3><p>请发现下面代码的问题;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-解决问题"><a href="#4-4-解决问题" class="headerlink" title="4.4.解决问题"></a>4.4.解决问题</h3><blockquote><ul><li>我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</li><li>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类</strong>，原有的继承关系去掉，采用<strong>依赖，聚合，组合</strong>等关系代替.</li></ul></blockquote><p>改进UML类图：</p><p><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/image-20230419092158189.png" alt="image-20230419092158189"></p><p>解决代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">        <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h2><h3 id="5-1-开闭原则"><a href="#5-1-开闭原则" class="headerlink" title="5.1.开闭原则"></a>5.1.开闭原则</h3><blockquote><ul><li>开闭原则（Open Closed Principle）是编程中<strong>最基础、最重要</strong>的设计原则</li><li>一个软件实体如类，模块和函数应该**对扩展开放(对提供方)**，对修改关闭(对使用方)<strong>。用抽象构建框架，用实现扩展细节。</strong></li><li>当软件需要变化时，尽量<strong>通过扩展软件</strong>实体的行为来实现变化，而不是<strong>通过修改</strong>已有的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ul></blockquote><h3 id="5-2-发现问题"><a href="#5-2-发现问题" class="headerlink" title="5.2.发现问题"></a>5.2.发现问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Opc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">            drawRectangle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">            drawCircle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">            drawTriangle(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTriangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的优缺点：</p><blockquote><ul><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个图形种类 三角形，修改的地方较多</li></ul></blockquote><h3 id="5-3-解决问题"><a href="#5-3-解决问题" class="headerlink" title="5.3.解决问题"></a>5.3.解决问题</h3><p>思路：把创建 <strong>Shape</strong> <strong>类做成抽象类</strong>，并提供一个<strong>抽象的</strong> <strong>draw</strong> 方法，让<strong>子类去实现即可</strong>，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，<strong>使用方的代码就不需要修</strong> -&gt; 满足了开闭原则</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">OtherGraphic</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherGraphic</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    OtherGraphic() &#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则"></a>6.迪米特法则</h2><h3 id="6-1-基本介绍"><a href="#6-1-基本介绍" class="headerlink" title="6.1.基本介绍"></a>6.1.基本介绍</h3><blockquote><ul><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即一个类<strong>对自己依赖的类知道的越少越好</strong>。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li><li><strong>直接的朋友</strong>：每个对象都会与其他对象有<strong>耦合关系</strong>，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量</strong>，<strong>方法参数</strong>，<strong>方法返回值</strong>中的类为直接的朋友，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li></ul></blockquote><h3 id="6-2-应用实例"><a href="#6-2-应用实例" class="headerlink" title="6.2.应用实例"></a>6.2.应用实例</h3><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demeter1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        <span class="type">SchoolManager</span> <span class="variable">schoolManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolManager</span>();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManager</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">        <span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">        <span class="comment">//3. 违反了 迪米特法则</span></span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以上代码的问题：</p><blockquote><ul><li>这里的 CollegeEmployee 不是  SchoolManager的直接朋友</li><li>CollegeEmployee 是以局部变量方式出现在 SchoolManager</li><li>违反了 迪米特法则</li><li>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</li></ul></blockquote><p>改进之后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demeter2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        <span class="type">SchoolManager</span> <span class="variable">schoolManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolManager</span>();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManager</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出学院员工的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">        sub.printEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-迪米特法则的细节"><a href="#6-3-迪米特法则的细节" class="headerlink" title="6.3.迪米特法则的细节"></a>6.3.迪米特法则的细节</h3><blockquote><ul><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li></ul></blockquote><h2 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7.合成复用原则"></a>7.合成复用原则</h2><h3 id="7-1-基本介绍"><a href="#7-1-基本介绍" class="headerlink" title="7.1.基本介绍"></a>7.1.基本介绍</h3><p>原则是尽量使用合成聚合的方式，而不是使用继承</p><h3 id="7-2-设计原则核心思想"><a href="#7-2-设计原则核心思想" class="headerlink" title="7.2.设计原则核心思想"></a>7.2.设计原则核心思想</h3><blockquote><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的<strong>松耦合设计而努</strong>力</li></ul></blockquote><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>这次的设计模式之七大原则的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之代理模式</title>
      <link href="/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>最近要进行软件工程设计模式的小组讨论了，正好借着这个机会来复习一下设计模式，这次为大家带来我在学习代理模式的一些笔记和心得。</p><h2 id="2-代理模式的基本介绍"><a href="#2-代理模式的基本介绍" class="headerlink" title="2.代理模式的基本介绍"></a>2.代理模式的基本介绍</h2><blockquote><ul><li>代理模式：为一个对象<strong>提供一个替身</strong>，以控制对这个对象的访问，则通过代理对象访问目标对象。这样做的好处是：可以对目标对象实现的基础上，增强额外的功能。</li><li>被代理的对象可以是远程对象、创建开销大的对象或者是需要安全控制的对象。</li><li>代理模式主要有三种<strong>静态代理</strong>、<strong>动态代理（JDK代理、接口代理）</strong>、<strong>Cglib代理（可以在内存中动态的创建对象，而不需要实现接口。属于动态代理的范畴）</strong></li></ul></blockquote><h2 id="3-静态代理"><a href="#3-静态代理" class="headerlink" title="3.静态代理"></a>3.静态代理</h2><h3 id="3-1-静态代理模式的基本介绍"><a href="#3-1-静态代理模式的基本介绍" class="headerlink" title="3.1.静态代理模式的基本介绍"></a>3.1.静态代理模式的基本介绍</h3><p>静态代理在使用时，需要定义接口或者父类，被代理对象（目标对象）与代理对象一起实现相同的接口或者是继承相同的父类</p><h3 id="3-2-应用实例"><a href="#3-2-应用实例" class="headerlink" title="3.2.应用实例"></a>3.2.应用实例</h3><h4 id="3-2-1-具体要求"><a href="#3-2-1-具体要求" class="headerlink" title="3.2.1.具体要求"></a>3.2.1.具体要求</h4><blockquote><ol><li>定义一个接口：<code>ITeacherDAO</code></li><li>目标对象<code>TeacherDAO</code>实现接口<code>ITeacherDAO</code></li><li>使用静态代理的方式，就需要代理对象<code>TeacherDAOProxy</code>也实现<code>ITeacherDAO</code></li><li>调用的时候通过调用代理对象的方法来调用目标对象</li><li><strong>特别注意</strong>：代理对象要与目标对象实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。</li></ol></blockquote><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml.png" alt="staticProxy" style="zoom:67%;"><h4 id="3-2-2-代码演示"><a href="#3-2-2-代码演示" class="headerlink" title="3.2.2.代码演示"></a>3.2.2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//讲课的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 目标对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理对象，静态代理</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAOProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITeacherDAO target;<span class="comment">//目标对象，通过接口来聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherDAOProxy</span><span class="params">(ITeacherDAO target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增强功能...&quot;</span>);</span><br><span class="line">        target.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;增强功能...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象（被代理对象）</span></span><br><span class="line">        TeacherDAO teacherDAO=<span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line">        <span class="comment">//创建代理对象，同时将被代理对象传给代理对象</span></span><br><span class="line">        <span class="type">TeacherDAOProxy</span> <span class="variable">teacherDAOProxy</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TeacherDAOProxy</span>(teacherDAO);</span><br><span class="line">        <span class="comment">//通过代理对象调用到被代理对象的方法</span></span><br><span class="line">        teacherDAOProxy.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-静态代理的优缺点"><a href="#3-3-静态代理的优缺点" class="headerlink" title="3.3.静态代理的优缺点"></a>3.3.静态代理的优缺点</h3><h4 id="3-3-1-优点"><a href="#3-3-1-优点" class="headerlink" title="3.3.1.优点"></a>3.3.1.优点</h4><p>在不修改目标对象功能的前提下，能通过代理对象对目标功能进行扩展</p><h4 id="3-3-2-缺点"><a href="#3-3-2-缺点" class="headerlink" title="3.3.2.缺点"></a>3.3.2.缺点</h4><ul><li>因为代理对象需要与目标对象实现一样的接口，所以会有很多的代理类</li><li>一旦接口增加方法，目标对象与代理对象都要维护</li></ul><h2 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h2><h3 id="4-1-动态代理的基本介绍"><a href="#4-1-动态代理的基本介绍" class="headerlink" title="4.1.动态代理的基本介绍"></a>4.1.动态代理的基本介绍</h3><blockquote><ul><li>代理对象不需要实现接口，但是目标对象需要实现接口，否则不能使用动态代理</li><li>代理对象的生成，是利用JDK中的API，动态的在内存中构建代理对象</li><li>动态代理要叫：JDK代理、接口代理</li></ul></blockquote><h3 id="4-2-JDK中生成代理对象的API"><a href="#4-2-JDK中生成代理对象的API" class="headerlink" title="4.2.JDK中生成代理对象的API"></a>4.2.JDK中生成代理对象的API</h3><blockquote><ul><li>代理类所在的包：<code>java.lang.reflect.Proxy</code></li><li>JDK的代理实现只需要使用<code>newProxyInstance</code>方法,完整写法<code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></li></ul></blockquote><h3 id="4-3-应用实例"><a href="#4-3-应用实例" class="headerlink" title="4.3.应用实例"></a>4.3.应用实例</h3><h4 id="4-3-1-具体要求"><a href="#4-3-1-具体要求" class="headerlink" title="4.3.1.具体要求"></a>4.3.1.具体要求</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml2.png" alt="dynamicProxy" style="zoom:67%;"><h4 id="4-3-2-代码实现"><a href="#4-3-2-代码实现" class="headerlink" title="4.3.2.代码实现"></a>4.3.2.代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//讲课的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 11:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 目标对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 14:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理工厂类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象，Object</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给目标对象生成一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">         *                                           Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">         *                                           InvocationHandler h)</span></span><br><span class="line"><span class="comment">         * ClassLoader loader:指定目标对象使用的类加载器，获取类加载器的方法固定</span></span><br><span class="line"><span class="comment">         * Class&lt;?&gt;[] interfaces:目标对象实现鹅接口类型，使用泛型的方法确定类型</span></span><br><span class="line"><span class="comment">         * InvocationHandler h:事件处理，执行目标对象方法时，会促发事件处理器的方法，</span></span><br><span class="line"><span class="comment">         * 会把当前执行的目标对象方法作为一个参数传入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;JDK代理开始...&quot;</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理提交...&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 14:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        ITeacherDAO target=<span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给目标对象，创建代理对象，转化为ITeacherDAO</span></span><br><span class="line">        <span class="type">ITeacherDAO</span> <span class="variable">proxyInstance</span> <span class="operator">=</span>(ITeacherDAO) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//class com.sun.proxy.$Proxy0内存中动态生成了代理对象</span></span><br><span class="line">        System.out.println(proxyInstance.getClass());</span><br><span class="line">        <span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">        proxyInstance.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Cglib代理"><a href="#5-Cglib代理" class="headerlink" title="5.Cglib代理"></a>5.Cglib代理</h2><h3 id="5-1-Cglib代理模式的基本介绍"><a href="#5-1-Cglib代理模式的基本介绍" class="headerlink" title="5.1.Cglib代理模式的基本介绍"></a>5.1.Cglib代理模式的基本介绍</h3><blockquote><ul><li>静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可以使用目标对象的子类来实现代理，这就是Cglib代理</li><li>Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展，有时候也将<strong>Cglib代理归属到动态代理</strong></li><li>Cglib是一个强大的高性能的代码生成包，它可以在运行期间扩展java类与实现java接口。它广泛的被许多AOP框架使用，比如Spring AOP，实现方法拦截。</li><li>在AOP编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理</li></ul></li><li>Cglib包的底层是通过使用字节码处理框架ASM来转化字节码并生成新的</li></ul></blockquote><h3 id="5-2-应用实例"><a href="#5-2-应用实例" class="headerlink" title="5.2.应用实例"></a>5.2.应用实例</h3><h4 id="5-2-1-Cglib代理模式的实现步骤"><a href="#5-2-1-Cglib代理模式的实现步骤" class="headerlink" title="5.2.1.Cglib代理模式的实现步骤"></a>5.2.1.Cglib代理模式的实现步骤</h4><blockquote><ol><li>需要引入Cglib的jar文件<ul><li>asm.jar</li><li>asm-commons.jar</li><li>asm-tree.jar</li><li>cglib-2.2.jar</li></ul></li><li>在内存中动态构建子类，注意代理的内不能为**<code>final</code>**,否则会报<code>java.lang.IllegalArgumentException</code></li><li>目标对象的方法如果为<code>final/static</code>，那么就不会被拦截，即不会执行目标对象额外的业务方法</li></ol></blockquote><h4 id="5-2-2-具体要求"><a href="#5-2-2-具体要求" class="headerlink" title="5.2.2.具体要求"></a>5.2.2.具体要求</h4><img src="https://zengjiahao0531.oss-cn-beijing.aliyuncs.com/img/uml3.png" alt="Cglib代理" style="zoom:67%;"><h4 id="5-2-3-代码实现"><a href="#5-2-3-代码实现" class="headerlink" title="5.2.3.代码实现"></a>5.2.3.代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 15:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDAO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师讲课中...,我是Cglib代理，不需要实现接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 15:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代理工厂</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象：是target对象的代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、创建一个工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2、设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3、设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4、创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写intercept方法，会调用目标对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理模式开始...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理提交...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: abb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023-04-17 16:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">TeacherDAO</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDAO</span>();</span><br><span class="line">        <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        <span class="type">TeacherDAO</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (TeacherDAO) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//执行代理对象的方法,触发intercept方法，从而实现对目标对象的调用</span></span><br><span class="line">        proxyInstance.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-代理模式的变体"><a href="#6-代理模式的变体" class="headerlink" title="6.代理模式的变体"></a>6.代理模式的变体</h2><h3 id="6-1-几种常见的代理模式介绍"><a href="#6-1-几种常见的代理模式介绍" class="headerlink" title="6.1.几种常见的代理模式介绍"></a>6.1.几种常见的代理模式介绍</h3><h4 id="6-1-1-防火墙代理"><a href="#6-1-1-防火墙代理" class="headerlink" title="6.1.1.防火墙代理"></a>6.1.1.防火墙代理</h4><p>内网通过代理穿透防火墙，实现对公网的访问</p><h4 id="6-1-2-缓存代理"><a href="#6-1-2-缓存代理" class="headerlink" title="6.1.2.缓存代理"></a>6.1.2.缓存代理</h4><p>比如：当请求图片文件等资源时，先缓存代理取，如果取到资源则ok，如果去报道资源，再到公网或者数据库取，然后缓存。</p><h4 id="6-1-3-远程代理"><a href="#6-1-3-远程代理" class="headerlink" title="6.1.3.远程代理"></a>6.1.3.远程代理</h4><p><strong>远程对象的本地代表</strong>，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p><h4 id="6-1-4-同步代理"><a href="#6-1-4-同步代理" class="headerlink" title="6.1.4.同步代理"></a>6.1.4.同步代理</h4><p>主要运用在多线程编程中，完成多线程间同步工作。</p><h2 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7.结束语"></a>7.结束语</h2><p>这次的设计模式之代理模式的学习到此就结束了，不知道大家是否已经了解并且掌握了呢，如有知识点和内容上面的错误，请及时联系我来改正</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo+github从0到1搭建个人博客</title>
      <link href="/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><h3 id="1-1-想说的话"><a href="#1-1-想说的话" class="headerlink" title="1.1.想说的话"></a>1.1.想说的话</h3><p>最近在学习 markdown 语法的时候，想着何不搭建一个个人的博客网站来进行分享一下自己的学习经验和心得了，于是马上开干，很快啊，一个简单的 blog 网站就诞生了，下面就来和大家分享一下使用 hexo+GitHub 从 0 到 1 搭建个人博客。</p><h3 id="1-2-准备工作"><a href="#1-2-准备工作" class="headerlink" title="1.2.准备工作"></a>1.2.准备工作</h3><p>在进行搭建博客之前，你需要:</p><blockquote><ul><li>拥有一个 GitHub 账号，没有的话去注册一个</li><li>安装了 node.js、npm，并且了解相关的知识</li><li>安装了 git</li></ul></blockquote><p>小编使用的环境：</p><blockquote><ul><li>Windows10</li><li><a href="mailto:&#110;&#111;&#100;&#x65;&#46;&#x6a;&#115;&#64;&#49;&#x38;&#x2e;&#x31;&#x35;&#46;&#x30;">&#110;&#111;&#100;&#x65;&#46;&#x6a;&#115;&#64;&#49;&#x38;&#x2e;&#x31;&#x35;&#46;&#x30;</a></li><li><a href="mailto:&#x67;&#105;&#116;&#64;&#50;&#x2e;&#51;&#x39;&#x2e;&#50;">&#x67;&#105;&#116;&#64;&#50;&#x2e;&#51;&#x39;&#x2e;&#50;</a></li><li><a href="mailto:&#104;&#x65;&#x78;&#111;&#x40;&#54;&#x2e;&#x33;&#46;&#48;">&#104;&#x65;&#x78;&#111;&#x40;&#54;&#x2e;&#x33;&#46;&#48;</a></li></ul></blockquote><h2 id="2-搭建-GitHub-博客"><a href="#2-搭建-GitHub-博客" class="headerlink" title="2.搭建 GitHub 博客"></a>2.搭建 GitHub 博客</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1.创建仓库"></a>2.1.创建仓库</h3><p>新建一个名为<code>你的github用户名.github.io</code>的仓库，比如说，如果你的 github 用户名是 zengjiahao1222，那么你就新建<code>zengjiahao1222.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就 s 是<a href="http://zengjiahao1222.github.io](http://test.github.io/)">http://zengjiahao1222.github.io](http://test.github.io/)</a> 了！</p><p>注意事项：</p><blockquote><ol><li>注册的邮箱一定要验证，否则不会成功</li><li>仓库名字必须是<code>username.github.io</code>,其中 username 是你的 GitHub 的用户名</li><li>仓库创建成功不会立即生效，需要过一段时间，大概 10-30 分钟。这个我踩坑了！！！</li></ol></blockquote><h3 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2.绑定域名"></a>2.2.绑定域名</h3><p>这个不绑定也是可以的，就用默认的<code>xxx.github.io</code>也是可以进行访问的，但是如果你想更加个性化，并且想拥有一个自己的域名，那就去买一个域名吧。</p><p>这里推荐去阿里云注册域名，大公司，有保障！！！</p><h2 id="3-配置-SSH-key"><a href="#3-配置-SSH-key" class="headerlink" title="3.配置 SSH key"></a>3.配置 SSH key</h2><h3 id="3-1-Github-配置-SSH-Key"><a href="#3-1-Github-配置-SSH-Key" class="headerlink" title="3.1.Github 配置 SSH Key"></a>3.1.Github 配置 SSH Key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用 git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure><p>然后连续 3 次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的 github 主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key——&gt;将刚复制的内容粘贴到 key 那里，title 随便填，保存:</p><p><img src="/2023/04/12/%E4%BD%BF%E7%94%A8hexo-github%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh.png" alt="配置"></p><h3 id="3-2-测试配置是否成功"><a href="#3-2-测试配置是否成功" class="headerlink" title="3.2.测试配置是否成功"></a>3.2.测试配置是否成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com <span class="comment"># 注意邮箱地址不用改</span></span><br></pre></td></tr></table></figure><p>如果提示<code>Hi zengjiahao1222! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>，那么恭喜你 SSH 已经配置成功</p><p>此时你还需要配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;liuxianan&quot;</span>// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><h2 id="4-使用-hexo-框架写博客"><a href="#4-使用-hexo-框架写博客" class="headerlink" title="4.使用 hexo 框架写博客"></a>4.使用 hexo 框架写博客</h2><h3 id="4-1-hexo-简介"><a href="#4-1-hexo-简介" class="headerlink" title="4.1.hexo 简介"></a>4.1.hexo 简介</h3><p>Hexo 是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持 Markdown 格式，有众多优秀插件和主题。</p><p>官网：<a href="http://hexo.io/">http://hexo.io</a></p><p>github：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h3 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2.原理"></a>4.2.原理</h3><p>由于 github pages 存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以 hexo 所做的就是将这些 md 文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到 github。</p><h3 id="4-3-安装"><a href="#4-3-安装" class="headerlink" title="4.3.安装"></a>4.3.安装</h3><p>建议使用 git bash 来执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>hexo 有 2 种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</p><h3 id="4-4-初始化"><a href="#4-4-初始化" class="headerlink" title="4.4.初始化"></a>4.4.初始化</h3><p>在电脑的某个地方新建一个名为 hexo 的文件夹（名字可以随便取），比如我的是<code>D:\hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /d/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo 会自动下载一些文件到这个目录，包括 node_modules</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo 就会在 public 文件夹生成相关 html 文件，这些文件将来都是要提交到 github 去的：</p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容</p><p>第一次初始化的时候 hexo 已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：</p><h3 id="4-5-修改主题"><a href="#4-5-修改主题" class="headerlink" title="4.5.修改主题"></a>4.5.修改主题</h3><p>个人觉得官方主题有点不好看，所有就继续了主题的更换，我在进行了一圈主题对比后，个人比较喜欢<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></p><p>首先我们来下载这个主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /d/hexo/</span><br><span class="line">$ npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ol><li>还可以用<code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code>来代替，但是我用这个在后续的修改主题样式的过程中经常出现样式不生效的情况，换成这个<code>npm install hexo-theme-butterfly</code>安装方式后基本解决了这个问题。</li><li>值得一提的是，通过 npm 安装并不会在 themes 里生成主题文件夹，而是在 node_modules 里生成</li><li>butterfly 主题美化教程<a href="https://butterfly.js.org/">butterfly</a></li></ol></blockquote><p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。每次修改了配置文件都要记得先进行<code>hexo clean</code>来清理一下<code>public</code>的内容，然后<code>hexo g</code></p><h3 id="4-5-上传到-Github"><a href="#4-5-上传到-Github" class="headerlink" title="4.5.上传到 Github"></a>4.5.上传到 Github</h3><p>我们先来安装一个插件，要不然后续的<code>hexo d</code>操作会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关 deploy 的部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:zengjiahao1222/zengjiahao1222.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><blockquote><p>在这里，branch 要写 main，因为 2020 年 10 月 1 日 GitHub 官方将默认分支 master 改为了 main</p></blockquote><h3 id="4-6-常用-hexo-命令"><a href="#4-6-常用-hexo-命令" class="headerlink" title="4.6.常用 hexo 命令"></a>4.6.常用 hexo 命令</h3><p>常见命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure><h3 id="4-7-写博客"><a href="#4-7-写博客" class="headerlink" title="4.7.写博客"></a>4.7.写博客</h3><p>定位到我们的 hexo 根目录，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br></pre></td></tr></table></figure><p>hexo 会帮我们在<code>_posts</code>下生成相关 md 文件,我们只需要打开这个文件就可以开始写博客了。当然你也可以直接自己新建 md 文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1, tag2, tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line"><span class="section">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><h4 id="4-7-1-写博客的工具"><a href="#4-7-1-写博客的工具" class="headerlink" title="4.7.1.写博客的工具"></a>4.7.1.写博客的工具</h4><p>这里推荐 Typora</p><h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5.结束语"></a>5.结束语</h2><p>这次的用 hexo+github 搭建个人博客网站的教程到此就结束了，不知道大家是否已经搭建完成了呢，如有知识点和内容上面的错误，请及时联系我来改正</p><p>部分内容转载自<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">小茗同学的博客园</a>,如有侵权，请立刻联系我，进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 小白 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
